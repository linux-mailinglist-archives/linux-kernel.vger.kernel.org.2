Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 975D63D30FC
	for <lists+linux-kernel@lfdr.de>; Fri, 23 Jul 2021 02:44:05 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233013AbhGWADA (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Thu, 22 Jul 2021 20:03:00 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44960 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232912AbhGWACI (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 22 Jul 2021 20:02:08 -0400
Received: from mail-wm1-x334.google.com (mail-wm1-x334.google.com [IPv6:2a00:1450:4864:20::334])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 84521C0613C1
        for <linux-kernel@vger.kernel.org>; Thu, 22 Jul 2021 17:42:39 -0700 (PDT)
Received: by mail-wm1-x334.google.com with SMTP id g12so4329748wme.2
        for <linux-kernel@vger.kernel.org>; Thu, 22 Jul 2021 17:42:39 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=philpotter-co-uk.20150623.gappssmtp.com; s=20150623;
        h=from:to:cc:subject:date:message-id:in-reply-to:references
         :mime-version:content-transfer-encoding;
        bh=w5qi6jyQIcm/oEdRAWq/UdMGrGzrlng2Ec2yXoB0ydo=;
        b=pVuo+iicclraH7gzRvBxbathRCyQ1ddoizUuHfTSRps9e0sXpr9R8JFETYOyiECpLT
         pqQivWxCdV8F4p0ouOkMjjDoRiTY8pZ4eUEOQZSbcIegg6TW9P6iMBXS/r45QgKR44+X
         YeYCIXpCpsTUUzagjCpE9D72yZ9cbI1YUWvQ+gpEO7TZhvQssx8zxpRqS37pCtedqmUJ
         t+R0KtgbbpK5OJixWMJIa/PwcT/R3i4Ytr7LaTCNwdGooOF2HOQRd9RrK5h31Fyb4Czg
         9RXzUNPJi3r1wz6Ekd6kR/pUTdDETywlF1etHZc7Cno1Dd8oiZ6oEEAOnOVo3SHTkETr
         ZPwg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references:mime-version:content-transfer-encoding;
        bh=w5qi6jyQIcm/oEdRAWq/UdMGrGzrlng2Ec2yXoB0ydo=;
        b=C7BunZzCwiN0pEoSoKrfSxVV8sceHY3ATjwdVCqzNcWnt0uNaoucUt2hQudnDMHoL2
         bfrV2TygyZo4Sm+hziTNrhn8jwuvJMkdiDc8en0SGCjwm+2Bn+HB3j/UL3aS1aYKAbc+
         WNG426XGPmRRShxzmV9LeixK2sdsIlX1XwfCpTr8ZyxqNCQn9AP+1IpjIQZ8pvMaB+DB
         G3+UjUXQgVmpK3iUYw6P1L74SzusCSrqLL8QVmy5V4HH8hor7PCsv0DuhYDKfpOk749/
         lgLVHQCAnDgEflQ4kRxxuD+Q2Auo6li4s1PeBwV6VndcQcKqBFQqt/5ArxXYIYAlBeAd
         sXfA==
X-Gm-Message-State: AOAM5321JDsE6VT8Ylz7qxi95vi7NoWxQAXOZXzwEn26FMjPLZ7QeE1C
        L8AboxOLgogUKoDwz8VASwY1eQ==
X-Google-Smtp-Source: ABdhPJwDd9EihuNwqCbaYBwFqqAaSjBROnhwpl00v34a9zTlJoeyMXbqMwClk8wduKqlDkz6E60hkA==
X-Received: by 2002:a7b:c193:: with SMTP id y19mr11813518wmi.86.1627000957000;
        Thu, 22 Jul 2021 17:42:37 -0700 (PDT)
Received: from localhost.localdomain (2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.a.1.e.e.d.f.d.0.b.8.0.1.0.0.2.ip6.arpa. [2001:8b0:dfde:e1a0::2])
        by smtp.gmail.com with ESMTPSA id m4sm31630498wrs.14.2021.07.22.17.42.33
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Thu, 22 Jul 2021 17:42:35 -0700 (PDT)
From:   Phillip Potter <phil@philpotter.co.uk>
To:     gregkh@linuxfoundation.org
Cc:     Larry.Finger@lwfinger.net, dan.carpenter@oracle.com,
        linux-kernel@vger.kernel.org, linux-staging@lists.linux.dev,
        fabioaiuto83@gmail.com
Subject: [PATCH 5/7] staging: rtl8188eu: introduce new include dir for RTL8188eu driver
Date:   Fri, 23 Jul 2021 01:42:12 +0100
Message-Id: <20210723004214.912295-6-phil@philpotter.co.uk>
X-Mailer: git-send-email 2.31.1
In-Reply-To: <20210723004214.912295-1-phil@philpotter.co.uk>
References: <20210723004214.912295-1-phil@philpotter.co.uk>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

This patchset is split in order to keep the file sizes down. This
include directory is part of the newer/better driver from GitHub
modified by Larry Finger. Import this as the basis for all future
work going forward.

Suggested-by: Larry Finger <Larry.Finger@lwfinger.net>
Signed-off-by: Phillip Potter <phil@philpotter.co.uk>
---
 .../rtl8188eu/include/Hal8188EPhyCfg.h        |  230 +++
 .../rtl8188eu/include/Hal8188EPhyReg.h        | 1089 ++++++++++
 .../rtl8188eu/include/Hal8188EPwrSeq.h        |  159 ++
 .../rtl8188eu/include/Hal8188FPhyCfg.h        |  123 ++
 .../rtl8188eu/include/Hal8188FPhyReg.h        | 1154 +++++++++++
 .../rtl8188eu/include/Hal8188FPwrSeq.h        |  198 ++
 .../staging/rtl8188eu/include/HalPwrSeqCmd.h  |  119 ++
 drivers/staging/rtl8188eu/include/HalVerDef.h |  156 ++
 drivers/staging/rtl8188eu/include/autoconf.h  |  340 ++++
 .../staging/rtl8188eu/include/basic_types.h   |  255 +++
 drivers/staging/rtl8188eu/include/circ_buf.h  |   12 +
 drivers/staging/rtl8188eu/include/cmd_osdep.h |   15 +
 .../staging/rtl8188eu/include/custom_gpio.h   |   22 +
 drivers/staging/rtl8188eu/include/drv_conf.h  |  270 +++
 drivers/staging/rtl8188eu/include/drv_types.h | 1395 +++++++++++++
 .../rtl8188eu/include/drv_types_linux.h       |    8 +
 drivers/staging/rtl8188eu/include/ethernet.h  |   25 +
 drivers/staging/rtl8188eu/include/h2clbk.h    |   15 +
 .../staging/rtl8188eu/include/hal_btcoex.h    |   77 +
 .../rtl8188eu/include/hal_btcoex_wifionly.h   |   47 +
 drivers/staging/rtl8188eu/include/hal_com.h   |  669 ++++++
 .../staging/rtl8188eu/include/hal_com_h2c.h   |  535 +++++
 .../staging/rtl8188eu/include/hal_com_led.h   |  268 +++
 .../rtl8188eu/include/hal_com_phycfg.h        |  332 +++
 .../staging/rtl8188eu/include/hal_com_reg.h   | 1795 +++++++++++++++++
 drivers/staging/rtl8188eu/include/hal_data.h  |  901 +++++++++
 .../staging/rtl8188eu/include/hal_ic_cfg.h    |   38 +
 drivers/staging/rtl8188eu/include/hal_intf.h  |  644 ++++++
 drivers/staging/rtl8188eu/include/hal_pg.h    |  785 +++++++
 drivers/staging/rtl8188eu/include/hal_phy.h   |  227 +++
 .../staging/rtl8188eu/include/hal_phy_reg.h   |   14 +
 drivers/staging/rtl8188eu/include/hal_sdio.h  |   20 +
 drivers/staging/rtl8188eu/include/ieee80211.h | 1668 +++++++++++++++
 .../staging/rtl8188eu/include/ieee80211_ext.h |  277 +++
 drivers/staging/rtl8188eu/include/if_ether.h  |   95 +
 drivers/staging/rtl8188eu/include/ip.h        |  121 ++
 .../rtl8188eu/include/linux/wireless.h        |   70 +
 .../staging/rtl8188eu/include/mlme_osdep.h    |   20 +
 .../staging/rtl8188eu/include/mp_custom_oid.h |  337 ++++
 drivers/staging/rtl8188eu/include/nic_spec.h  |   30 +
 .../staging/rtl8188eu/include/osdep_intf.h    |  121 ++
 .../staging/rtl8188eu/include/osdep_service.h |  567 ++++++
 .../rtl8188eu/include/osdep_service_linux.h   |  442 ++++
 .../staging/rtl8188eu/include/recv_osdep.h    |   50 +
 .../staging/rtl8188eu/include/rtl8188e_cmd.h  |  112 +
 .../staging/rtl8188eu/include/rtl8188e_dm.h   |   16 +
 .../staging/rtl8188eu/include/rtl8188e_hal.h  |  277 +++
 .../staging/rtl8188eu/include/rtl8188e_led.h  |   14 +
 .../staging/rtl8188eu/include/rtl8188e_recv.h |  117 ++
 .../staging/rtl8188eu/include/rtl8188e_rf.h   |   16 +
 .../staging/rtl8188eu/include/rtl8188e_spec.h |  137 ++
 .../rtl8188eu/include/rtl8188e_sreset.h       |   13 +
 .../staging/rtl8188eu/include/rtl8188e_xmit.h |  270 +++
 .../staging/rtl8188eu/include/rtw_android.h   |   99 +
 drivers/staging/rtl8188eu/include/rtw_ap.h    |   72 +
 .../rtl8188eu/include/rtw_beamforming.h       |  374 ++++
 .../staging/rtl8188eu/include/rtw_br_ext.h    |   56 +
 drivers/staging/rtl8188eu/include/rtw_bt_mp.h |  277 +++
 .../staging/rtl8188eu/include/rtw_btcoex.h    |  428 ++++
 .../rtl8188eu/include/rtw_btcoex_wifionly.h   |   11 +
 drivers/staging/rtl8188eu/include/rtw_cmd.h   | 1280 ++++++++++++
 drivers/staging/rtl8188eu/include/rtw_debug.h |  596 ++++++
 .../staging/rtl8188eu/include/rtw_eeprom.h    |  103 +
 drivers/staging/rtl8188eu/include/rtw_efuse.h |  227 +++
 drivers/staging/rtl8188eu/include/rtw_event.h |  119 ++
 drivers/staging/rtl8188eu/include/rtw_ht.h    |  203 ++
 drivers/staging/rtl8188eu/include/rtw_io.h    |  431 ++++
 drivers/staging/rtl8188eu/include/rtw_ioctl.h |  174 ++
 .../rtl8188eu/include/rtw_ioctl_query.h       |    7 +
 .../staging/rtl8188eu/include/rtw_ioctl_rtl.h |   64 +
 .../staging/rtl8188eu/include/rtw_ioctl_set.h |   36 +
 drivers/staging/rtl8188eu/include/rtw_iol.h   |  120 ++
 drivers/staging/rtl8188eu/include/rtw_mcc.h   |  205 ++
 drivers/staging/rtl8188eu/include/rtw_mem.h   |   25 +
 drivers/staging/rtl8188eu/include/rtw_mi.h    |  220 ++
 drivers/staging/rtl8188eu/include/rtw_mlme.h  | 1176 +++++++++++
 .../staging/rtl8188eu/include/rtw_mlme_ext.h  | 1257 ++++++++++++
 drivers/staging/rtl8188eu/include/rtw_mp.h    |  823 ++++++++
 .../staging/rtl8188eu/include/rtw_mp_ioctl.h  |  535 +++++
 .../rtl8188eu/include/rtw_mp_phy_regdef.h     | 1074 ++++++++++
 drivers/staging/rtl8188eu/include/rtw_odm.h   |   39 +
 drivers/staging/rtl8188eu/include/rtw_p2p.h   |  152 ++
 .../staging/rtl8188eu/include/rtw_pwrctrl.h   |  543 +++++
 drivers/staging/rtl8188eu/include/rtw_qos.h   |   18 +
 drivers/staging/rtl8188eu/include/rtw_recv.h  |  690 +++++++
 drivers/staging/rtl8188eu/include/rtw_rf.h    |  270 +++
 drivers/staging/rtl8188eu/include/rtw_sdio.h  |   15 +
 .../staging/rtl8188eu/include/rtw_security.h  |  475 +++++
 .../staging/rtl8188eu/include/rtw_sreset.h    |   44 +
 drivers/staging/rtl8188eu/include/rtw_tdls.h  |  157 ++
 .../staging/rtl8188eu/include/rtw_version.h   |    1 +
 drivers/staging/rtl8188eu/include/rtw_vht.h   |  128 ++
 drivers/staging/rtl8188eu/include/rtw_wapi.h  |  214 ++
 .../staging/rtl8188eu/include/rtw_wifi_regd.h |   25 +
 drivers/staging/rtl8188eu/include/rtw_xmit.h  |  699 +++++++
 drivers/staging/rtl8188eu/include/sta_info.h  |  647 ++++++
 drivers/staging/rtl8188eu/include/usb_hal.h   |   21 +
 drivers/staging/rtl8188eu/include/usb_ops.h   |   60 +
 .../staging/rtl8188eu/include/usb_ops_linux.h |   87 +
 .../staging/rtl8188eu/include/usb_osintf.h    |   17 +
 .../rtl8188eu/include/usb_vendor_req.h        |   37 +
 drivers/staging/rtl8188eu/include/wifi.h      | 1252 ++++++++++++
 .../staging/rtl8188eu/include/wlan_bssdef.h   |  347 ++++
 .../staging/rtl8188eu/include/xmit_osdep.h    |   47 +
 104 files changed, 32684 insertions(+)
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188EPhyReg.h
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188EPwrSeq.h
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188FPhyCfg.h
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188FPhyReg.h
 create mode 100644 drivers/staging/rtl8188eu/include/Hal8188FPwrSeq.h
 create mode 100644 drivers/staging/rtl8188eu/include/HalPwrSeqCmd.h
 create mode 100644 drivers/staging/rtl8188eu/include/HalVerDef.h
 create mode 100644 drivers/staging/rtl8188eu/include/autoconf.h
 create mode 100644 drivers/staging/rtl8188eu/include/basic_types.h
 create mode 100644 drivers/staging/rtl8188eu/include/circ_buf.h
 create mode 100644 drivers/staging/rtl8188eu/include/cmd_osdep.h
 create mode 100644 drivers/staging/rtl8188eu/include/custom_gpio.h
 create mode 100644 drivers/staging/rtl8188eu/include/drv_conf.h
 create mode 100644 drivers/staging/rtl8188eu/include/drv_types.h
 create mode 100644 drivers/staging/rtl8188eu/include/drv_types_linux.h
 create mode 100644 drivers/staging/rtl8188eu/include/ethernet.h
 create mode 100644 drivers/staging/rtl8188eu/include/h2clbk.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_btcoex.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_btcoex_wifionly.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_com.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_com_h2c.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_com_led.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_com_phycfg.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_com_reg.h
 create mode 100755 drivers/staging/rtl8188eu/include/hal_data.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_ic_cfg.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_intf.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_pg.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_phy.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_phy_reg.h
 create mode 100644 drivers/staging/rtl8188eu/include/hal_sdio.h
 create mode 100644 drivers/staging/rtl8188eu/include/ieee80211.h
 create mode 100644 drivers/staging/rtl8188eu/include/ieee80211_ext.h
 create mode 100644 drivers/staging/rtl8188eu/include/if_ether.h
 create mode 100644 drivers/staging/rtl8188eu/include/ip.h
 create mode 100644 drivers/staging/rtl8188eu/include/linux/wireless.h
 create mode 100644 drivers/staging/rtl8188eu/include/mlme_osdep.h
 create mode 100644 drivers/staging/rtl8188eu/include/mp_custom_oid.h
 create mode 100644 drivers/staging/rtl8188eu/include/nic_spec.h
 create mode 100644 drivers/staging/rtl8188eu/include/osdep_intf.h
 create mode 100644 drivers/staging/rtl8188eu/include/osdep_service.h
 create mode 100644 drivers/staging/rtl8188eu/include/osdep_service_linux.h
 create mode 100644 drivers/staging/rtl8188eu/include/recv_osdep.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_cmd.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_dm.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_hal.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_led.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_recv.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_rf.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_spec.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_sreset.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtl8188e_xmit.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_android.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ap.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_beamforming.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_br_ext.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_bt_mp.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_btcoex.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_btcoex_wifionly.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_cmd.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_debug.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_eeprom.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_efuse.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_event.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ht.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_io.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ioctl.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ioctl_query.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ioctl_rtl.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_ioctl_set.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_iol.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mcc.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mem.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mi.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mlme.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mlme_ext.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mp.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mp_ioctl.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_mp_phy_regdef.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_odm.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_p2p.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_pwrctrl.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_qos.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_recv.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_rf.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_sdio.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_security.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_sreset.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_tdls.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_version.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_vht.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_wapi.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_wifi_regd.h
 create mode 100644 drivers/staging/rtl8188eu/include/rtw_xmit.h
 create mode 100644 drivers/staging/rtl8188eu/include/sta_info.h
 create mode 100644 drivers/staging/rtl8188eu/include/usb_hal.h
 create mode 100644 drivers/staging/rtl8188eu/include/usb_ops.h
 create mode 100644 drivers/staging/rtl8188eu/include/usb_ops_linux.h
 create mode 100644 drivers/staging/rtl8188eu/include/usb_osintf.h
 create mode 100644 drivers/staging/rtl8188eu/include/usb_vendor_req.h
 create mode 100644 drivers/staging/rtl8188eu/include/wifi.h
 create mode 100644 drivers/staging/rtl8188eu/include/wlan_bssdef.h
 create mode 100644 drivers/staging/rtl8188eu/include/xmit_osdep.h

diff --git a/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h b/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
new file mode 100644
index 000000000000..bc592b0ab918
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
@@ -0,0 +1,230 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __INC_HAL8188EPHYCFG_H__
+#define __INC_HAL8188EPHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		/* us */
+#define AntennaDiversityValue		0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+	#define MAX_AGGR_NUM	0x0B
+#else
+	#define MAX_AGGR_NUM	0x07
+#endif /* CONFIG_PCI_HCI */
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+#define	MAX_TX_COUNT_8188E			1
+
+/* BB/RF related */
+
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+/*
+ * BB and RF register read/write
+ *   */
+u32	PHY_QueryBBReg8188E(PADAPTER	Adapter,
+			    u32		RegAddr,
+			    u32		BitMask);
+void	PHY_SetBBReg8188E(PADAPTER	Adapter,
+			  u32		RegAddr,
+			  u32		BitMask,
+			  u32		Data);
+u32	PHY_QueryRFReg8188E(PADAPTER	Adapter,
+			    u8				eRFPath,
+			    u32				RegAddr,
+			    u32				BitMask);
+void	PHY_SetRFReg8188E(PADAPTER		Adapter,
+			  u8				eRFPath,
+			  u32				RegAddr,
+			  u32				BitMask,
+			  u32				Data);
+
+/*
+ * Initialization related function
+ */
+/* MAC/BB/RF HAL config */
+int	PHY_MACConfig8188E(PADAPTER	Adapter);
+int	PHY_BBConfig8188E(PADAPTER	Adapter);
+int	PHY_RFConfig8188E(PADAPTER	Adapter);
+
+/* RF config */
+int	rtl8188e_PHY_ConfigRFWithParaFile(PADAPTER Adapter, u8 *pFileName, u8 eRFPath);
+
+/*
+ * RF Power setting
+ */
+/* extern	bool	PHY_SetRFPowerState(PADAPTER			Adapter,
+ *									RT_RF_POWER_STATE	eRFPowerState); */
+
+/*
+ * BB TX Power R/W
+ *   */
+void	PHY_GetTxPowerLevel8188E(PADAPTER		Adapter,
+				 s32		*powerlevel);
+void	PHY_SetTxPowerLevel8188E(PADAPTER		Adapter,
+				 u8			channel);
+bool	PHY_UpdateTxPowerDbm8188E(PADAPTER	Adapter,
+				  int		powerInDbm);
+
+void
+PHY_SetTxPowerIndex_8188E(
+	PADAPTER			Adapter,
+	u32					PowerIndex,
+	u8					RFPath,
+	u8					Rate
+);
+
+u8
+PHY_GetTxPowerIndex_8188E(
+	PADAPTER		pAdapter,
+	u8				RFPath,
+	u8				Rate,
+	u8				BandWidth,
+	u8				Channel,
+	struct txpwr_idx_comp *tic
+);
+
+/*
+ * Switch bandwidth for 8192S
+ */
+/* extern	void	PHY_SetBWModeCallback8192C(	PRT_TIMER		pTimer	); */
+void	PHY_SetBWMode8188E(PADAPTER			pAdapter,
+			   CHANNEL_WIDTH	ChnlWidth,
+			   unsigned char	Offset);
+
+/*
+ * Set FW CMD IO for 8192S.
+ */
+/* extern	bool HalSetIO8192C(PADAPTER			Adapter,
+ *									IO_TYPE				IOType); */
+
+/*
+ * Set A2 entry to fw for 8192S
+ *   */
+extern	void FillA2Entry8192C(PADAPTER			Adapter,
+			      u8				index,
+			      u8				*val);
+
+
+/*
+ * channel switch related funciton
+ */
+/* extern	void	PHY_SwChnlCallback8192C(	PRT_TIMER		pTimer	); */
+void	PHY_SwChnl8188E(PADAPTER		pAdapter,
+			u8			channel);
+
+void
+PHY_SetSwChnlBWMode8188E(
+	PADAPTER			Adapter,
+	u8					channel,
+	CHANNEL_WIDTH	Bandwidth,
+	u8					Offset40,
+	u8					Offset80
+);
+
+void
+PHY_SetRFEReg_8188E(
+	PADAPTER		Adapter
+);
+/*
+ * BB/MAC/RF other monitor API
+ *   */
+void phy_set_rf_path_switch_8188e(PADAPTER	pAdapter, bool		bMain);
+
+extern	void
+PHY_SwitchEphyParameter(
+	PADAPTER			Adapter
+);
+
+extern	void
+PHY_EnableHostClkReq(
+	PADAPTER			Adapter
+);
+
+bool
+SetAntennaConfig92C(
+	PADAPTER	Adapter,
+	u8		DefaultAnt
+);
+
+/*--------------------------Exported Function prototype---------------------*/
+
+/*
+ * Initialization related function
+ *
+ * MAC/BB/RF HAL config */
+/* extern s32 PHY_MACConfig8723(PADAPTER padapter);
+ * s32 PHY_BBConfig8723(PADAPTER padapter);
+ * s32 PHY_RFConfig8723(PADAPTER padapter); */
+
+
+
+/* ******************************************************************
+ * Note: If SIC_ENABLE under PCIE, because of the slow operation
+ *	you should
+ * 	2) "#define RTL8723_FPGA_VERIFICATION	1"				in Precomp.h.WlanE.Windows
+ * 	3) "#define RTL8190_Download_Firmware_From_Header	0"	in Precomp.h.WlanE.Windows if needed.
+ *   */
+#if (RTL8188E_FPGAtrue_PHY_VERIFICATION == 1)
+	#define	SIC_ENABLE				1
+	#define	SIC_HW_SUPPORT		1
+#else
+	#define	SIC_ENABLE				0
+	#define	SIC_HW_SUPPORT		0
+#endif
+/* ****************************************************************** */
+
+
+#define	SIC_MAX_POLL_CNT		5
+
+#if (SIC_HW_SUPPORT == 1)
+	#define	SIC_CMD_READY			0
+	#define	SIC_CMD_PREWRITE		0x1
+		#define	SIC_CMD_WRITE			0x40
+		#define	SIC_CMD_PREREAD		0x2
+		#define	SIC_CMD_READ			0x80
+		#define	SIC_CMD_INIT			0xf0
+		#define	SIC_INIT_VAL			0xff
+
+		#define	SIC_INIT_REG			0x1b7
+		#define	SIC_CMD_REG			0x1EB		/* 1byte */
+		#define	SIC_ADDR_REG			0x1E8		/* 1b4~1b5, 2 bytes */
+		#define	SIC_DATA_REG			0x1EC		/* 1b0~1b3 */
+#else
+	#define	SIC_CMD_READY			0
+	#define	SIC_CMD_WRITE			1
+	#define	SIC_CMD_READ			2
+
+		#define	SIC_CMD_REG			0x1EB		/* 1byte */
+		#define	SIC_ADDR_REG			0x1E8		/* 1b9~1ba, 2 bytes */
+		#define	SIC_DATA_REG			0x1EC		/* 1bc~1bf */
+#endif
+
+#if (SIC_ENABLE == 1)
+	void SIC_Init(PADAPTER Adapter);
+#endif
+
+
+#endif /* __INC_HAL8192CPHYCFG_H */
diff --git a/drivers/staging/rtl8188eu/include/Hal8188EPhyReg.h b/drivers/staging/rtl8188eu/include/Hal8188EPhyReg.h
new file mode 100644
index 000000000000..9d6f0c15ac34
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188EPhyReg.h
@@ -0,0 +1,1089 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __INC_HAL8188EPHYREG_H__
+#define __INC_HAL8188EPHYREG_H__
+/*--------------------------Define Parameters-------------------------------*/
+/*
+ * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+ * 3. RF register 0x00-2E
+ * 4. Bit Mask for BB/RF register
+ * 5. Other defintion for BB/RF R/W
+ *   */
+
+
+/*
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 1. Page1(0x100)
+ *   */
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart				0x104
+#define		rPMAC_TxLegacySIG			0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum			0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble		0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK		0x170
+#define		rPMAC_OFDMRxCRC32Er		0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus				0x18c
+
+/*
+ * 2. Page2(0x200)
+ *
+ * The following two definition are only used for USB interface. */
+#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
+#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */
+
+/*
+ * 3. Page8(0x800)
+ *   */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA0_TxInfo					0x804	/* Status report?? */
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */
+
+#define		rFPGA0_RFTiming1				0x810	/* Useless now */
+#define		rFPGA0_RFTiming2				0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter	0x850	/* Useless now */
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888
+#define		rFPGA0_AdDaClockEn			0x888	/* enable ad/da clock1 for dual-phy */
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
+#define		TransceiverA_HSPI_Readback		0x8b8	/* Transceiver A HSPI Readback */
+#define		TransceiverB_HSPI_Readback		0x8bc	/* Transceiver B HSPI Readback */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */
+
+/*
+ * 4. Page9(0x900)
+ *   */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/* Useless now */
+#define		rFPGA1_DebugSelect			0x908	/* Useless now */
+#define		rFPGA1_TxInfo					0x90c	/* Useless now */ /* Status report?? */
+
+/*
+ * 5. PageA(0xA00)
+ *
+ * Set Control channel to upper or lower. These settings are required only for 40MHz */
+#define		rCCK0_System					0xa00
+
+#define		rCCK0_AFESetting				0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */
+
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1			0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2			0xa1c	/* SQ threshold */
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort				0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
+#define		rCCK0_TRSSIReport			0xa50
+#define		rCCK0_RxReport            			0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower      		0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper      		0xa58  /* 0xa5c */
+
+/*
+ * PageB(0xB00)
+ *   */
+#define		rPdp_AntA					0xb00
+#define		rPdp_AntA_4				0xb04
+#define		rConfig_Pmpd_AntA			0xb28
+#define		rConfig_ram64x16				0xb2c
+#define		rConfig_AntA					0xb68
+#define		rConfig_AntB					0xb6c
+#define		rPdp_AntB					0xb70
+#define		rPdp_AntB_4					0xb74
+#define		rConfig_Pmpd_AntB			0xb98
+#define		rAPK							0xbd8
+
+
+
+/*
+ * 6. PageC(0xC00)
+ *   */
+#define		rOFDM0_LSTF					0xc00
+
+#define		rOFDM0_TRxPathEnable			0xc04
+#define		rOFDM0_TRMuxPar				0xc08
+#define		rOFDM0_TRSWIsolation			0xc0c
+
+#define		rOFDM0_XARxAFE				0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance    		0xc14  /* RxIQ imblance matrix */
+#define		rOFDM0_XBRxAFE			0xc18
+#define		rOFDM0_XBRxIQImbalance		0xc1c
+#define		rOFDM0_XCRxAFE			0xc20
+#define		rOFDM0_XCRxIQImbalance		0xc24
+#define		rOFDM0_XDRxAFE			0xc28
+#define		rOFDM0_XDRxIQImbalance		0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC			0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold		0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold			0xc4c /* energy CCA */
+
+#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1		0xc70
+#define		rOFDM0_AGCParameter2		0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter		0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync			0xcf0
+#define		rOFDM0_DFSReport			0xcf4
+
+
+/*
+ * 7. PageD(0xD00)
+ *   */
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO					0xd08	/* No setting now */
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD					0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet				0xd3c
+#define		rOFDM1_csi_fix_mask1				0xd40
+#define		rOFDM1_csi_fix_mask2				0xd44
+#define		rOFDM1_PseudoNoiseStateAB	0xd50
+#define		rOFDM1_PseudoNoiseStateCD	0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1			0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2			0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3			0xda8  /* MCS not support */
+
+#define		rOFDM_ShortCFOAB			0xdac	/* No setting now */
+#define		rOFDM_ShortCFOCD			0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1		0xdc4
+#define		rOFDM_PWMeasure2		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR				0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+/*
+ * 8. PageE(0xE00)
+ *   */
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00		0xe10
+#define		rTxAGC_A_Mcs07_Mcs04		0xe14
+#define		rTxAGC_A_Mcs11_Mcs08		0xe18
+#define		rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00		0x83c
+#define		rTxAGC_B_Mcs07_Mcs04		0x848
+#define		rTxAGC_B_Mcs11_Mcs08		0x84c
+#define		rTxAGC_B_Mcs15_Mcs12		0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS				0xed4
+#define		rRx_TO_Rx					0xed8
+#define		rStandby						0xedc
+#define		rSleep						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+/*
+ * 7. RF Register 0x00-0x2E (RF 8256)
+ * RF-0222D 0x00-3F
+ *
+ * Zebra1 */
+#define		rZebra1_HSSIEnable				0x0	/* Useless now */
+#define		rZebra1_TRxEnable1			0x1
+#define		rZebra1_TRxEnable2			0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	/* RF channel switch */
+
+/* #endif */
+#define		rZebra1_TxGain				0x8	/* Useless now */
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+/* Zebra4 */
+#define		rGlobalCtrl					0	/* Useless now */
+#define		rRTL8256_TxLPF				19
+#define		rRTL8256_RxLPF				11
+
+/* RTL8258 */
+#define		rRTL8258_TxLPF				0x11	/* Useless now */
+#define		rRTL8258_RxLPF				0x13
+#define		rRTL8258_RSSILPF				0xa
+
+/*
+ * RL6052 Register definition
+ *   */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1					0x01	/*  */
+#define		RF_IQADJ_G2					0x02	/*  */
+
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC					0x08	/*  */
+#define		RF_IPA_G						0x09	/*  */
+#define		RF_TXBIAS_G					0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A						0x0C	/*  */
+#define		RF_TXBIAS_A					0x0D
+#define		RF_BS_PA_APSET_G9_G11		0x0E
+#define		RF_BS_IQGEN					0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_TXBIAS					0x16
+#define		RF_POW_ABILITY				0x17	/*  */
+#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1						0x1E	/*  */
+#define		RF_RCK2						0x1F	/*  */
+
+#define		RF_TX_G1						0x20	/*  */
+#define		RF_TX_G2						0x21	/*  */
+#define		RF_TX_G3						0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER_88E					0x42	/*  */
+#define		RF_T_METER					0x24	/*  */
+
+#define		RF_SYN_G1					0x25	/* RF TX Power control */
+#define		RF_SYN_G2					0x26	/* RF TX Power control */
+#define		RF_SYN_G3					0x27	/* RF TX Power control */
+#define		RF_SYN_G4					0x28	/* RF TX Power control */
+#define		RF_SYN_G5					0x29	/* RF TX Power control */
+#define		RF_SYN_G6					0x2A	/* RF TX Power control */
+#define		RF_SYN_G7					0x2B	/* RF TX Power control */
+#define		RF_SYN_G8					0x2C	/* RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/* RF TX PA control */
+#define		RF_TXPA_G1					0x31	/* RF TX PA control */
+#define		RF_TXPA_G2					0x32	/* RF TX PA control */
+#define		RF_TXPA_G3					0x33	/* RF TX PA control */
+#define		RF_TX_BIAS_A					0x35
+#define		RF_TX_BIAS_D					0x36
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	/*	 */
+#define		RF_TRSW						0x3F
+
+#define		RF_TXRF_A2					0x41
+#define		RF_TXPA_G4					0x46
+#define		RF_TXPA_A4					0x4B
+#define	RF_0x52					0x52
+#define		RF_WE_LUT					0xEF
+
+
+/*
+ * Bit Mask
+ *
+ * 1. Page1(0x100) */
+#define		bBBResetB					0x100	/* Useless now? */
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart					0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback				0x10
+#define		bTxLSIG						0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength				0x1ffe0
+#define		bOFDMTxParity				0x20000
+#define		bTxHTSIG1					0xffffff
+#define		bTxHTMCSRate				0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2					0xffffff
+#define		bTxHTSmoothing				0x1
+#define		bTxHTSounding				0x2
+#define		bTxHTReserved				0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC					0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8					0x3fc00
+#define		bCounterReset				0x10000
+#define		bNumOfOFDMTx				0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval				0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader				0xffffffff
+#define		bTxDataInit					0xff
+#define		bTxHTMode					0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed				0xffffffff
+#define		bCCKTxPreamble				0x1
+#define		bCCKTxSFD					0xffff0000
+#define		bCCKTxSIG					0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus				0x2
+
+#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+/* 2. Page8(0x800) */
+#define		bRFMOD						0x1	/* Reg 0x800 rFPGA0_RFMOD */
+#define		bJapanMode					0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn						0x1000000
+#define		bOFDMEn					0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
+#define		bOFDMTxDACPhase		0x40000
+#define		bXATxAGC				0x3f
+
+#define		bAntennaSelect			0x0300
+
+#define		bXBTxAGC                  				0xf00	/* Reg 80c rFPGA0_TxGainStage */
+#define		bXCTxAGC				0xf000
+#define		bXDTxAGC				0xf0000
+
+#define		bPAStart                  				0xf0000000	/* Useless now */
+#define		bTRStart				0x00f00000
+#define		bRFStart				0x0000f000
+#define		bBBStart				0x000000f0
+#define		bBBCCKStart			0x0000000f
+#define		bPAEnd                    				0xf          /* Reg0x814 */
+#define		bTREnd				0x0f000000
+#define		bRFEnd				0x000f0000
+#define		bCCAMask                  				0x000000f0   /* T2R */
+#define		bR2RCCAMask			0x00000f00
+#define		bHSSI_R2TDelay			0xf8000000
+#define		bHSSI_T2RDelay			0xf80000
+#define		bContTxHSSI               			0x400     /* chane gain at continue Tx */
+#define		bIGFromCCK			0x200
+#define		bAGCAddress			0x3f
+#define		bRxHPTx				0x7000
+#define		bRxHPT2R				0x38000
+#define		bRxHPCCKIni			0xc0000
+#define		bAGCTxCode			0xc00000
+#define		bAGCRxCode			0x300000
+
+#define		b3WireDataLength          			0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
+#define		b3WireAddressLength		0x400
+
+#define		b3WireRFPowerDown         		0x1	/* Useless now
+ * #define bHWSISelect		0x8 */
+#define		b5GPAPEPolarity			0x40000000
+#define		b2GPAPEPolarity			0x80000000
+#define		bRFSW_TxDefaultAnt		0x3
+#define		bRFSW_TxOptionAnt		0x30
+#define		bRFSW_RxDefaultAnt		0x300
+#define		bRFSW_RxOptionAnt		0x3000
+#define		bRFSI_3WireData			0x1
+#define		bRFSI_3WireClock			0x2
+#define		bRFSI_3WireLoad			0x4
+#define		bRFSI_3WireRW			0x8
+#define		bRFSI_3Wire			0xf
+
+#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+
+#define		bRFSI_TRSW                		0x20	/* Useless now */
+#define		bRFSI_TRSWB		0x40
+#define		bRFSI_ANTSW		0x100
+#define		bRFSI_ANTSWB		0x200
+#define		bRFSI_PAPE			0x400
+#define		bRFSI_PAPE5G		0x800
+#define		bBandSelect			0x1
+#define		bHTSIG2_GI			0x80
+#define		bHTSIG2_Smoothing		0x01
+#define		bHTSIG2_Sounding		0x02
+#define		bHTSIG2_Aggreaton		0x08
+#define		bHTSIG2_STBC		0x30
+#define		bHTSIG2_AdvCoding		0x40
+#define		bHTSIG2_NumOfHTLTF	0x300
+#define		bHTSIG2_CRC8		0x3fc
+#define		bHTSIG1_MCS		0x7f
+#define		bHTSIG1_BandWidth		0x80
+#define		bHTSIG1_HTLength		0xffff
+#define		bLSIG_Rate			0xf
+#define		bLSIG_Reserved		0x10
+#define		bLSIG_Length		0x1fffe
+#define		bLSIG_Parity			0x20
+#define		bCCKRxPhase		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */
+
+#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */
+
+#define		bLSSIReadBackData         		0xfffff		/* T65 RF */
+
+#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
+#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
+#define		bRegulator0Standby		0x1
+#define		bRegulatorPLLStandby	0x2
+#define		bRegulator1Standby		0x4
+#define		bPLLPowerUp		0x8
+#define		bDPLLPowerUp		0x10
+#define		bDA10PowerUp		0x20
+#define		bAD7PowerUp		0x200
+#define		bDA6PowerUp		0x2000
+#define		bXtalPowerUp		0x4000
+#define		b40MDClkPowerUP	0x8000
+#define		bDA6DebugMode		0x20000
+#define		bDA6Swing			0x380000
+
+#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+
+#define		b80MClkDelay              		0x18000000	/* Useless */
+#define		bAFEWatchDogEnable	0x20000000
+
+#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define		bXtalCap23			0x3
+#define		bXtalCap92x				0x0f000000
+#define		bXtalCap			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	/* Useless */
+#define		bExtSigClkEnable		0x800
+#define		bBandgapMbiasPowerUp	0x10000
+#define		bAD11SHGain		0xc0000
+#define		bAD11InputRange		0x700000
+#define		bAD11OPCurrent		0x3800000
+#define		bIPathLoopback		0x4000000
+#define		bQPathLoopback		0x8000000
+#define		bAFELoopback		0x10000000
+#define		bDA10Swing		0x7e0
+#define		bDA10Reverse		0x800
+#define		bDAClkSource		0x1000
+#define		bAD7InputRange		0x6000
+#define		bAD7Gain			0x38000
+#define		bAD7OutputCMMode	0x40000
+#define		bAD7InputCMMode	0x380000
+#define		bAD7Current		0xc00000
+#define		bRegulatorAdjust		0x7000000
+#define		bAD11PowerUpAtTx	0x1
+#define		bDA10PSAtTx		0x10
+#define		bAD11PowerUpAtRx	0x100
+#define		bDA10PSAtRx		0x1000
+#define		bCCKRxAGCFormat		0x200
+#define		bPSDFFTSamplepPoint	0xc000
+#define		bPSDAverageNum		0x3000
+#define		bIQPathControl		0xc00
+#define		bPSDFreq			0x3ff
+#define		bPSDAntennaPath		0x30
+#define		bPSDIQSwitch		0x40
+#define		bPSDRxTrigger		0x400000
+#define		bPSDTxTrigger		0x80000000
+#define		bPSDSineToneScale		0x7f000000
+#define		bPSDReport		0xffff
+
+/* 3. Page9(0x900) */
+#define		bOFDMTxSC                 		0x30000000	/* Useless */
+#define		bCCKTxOn			0x1
+#define		bOFDMTxOn		0x2
+#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem                		0xff   /* reset debug page and LWord */
+#define		bAntL				0x10
+#define		bAntNonHT			0x100
+#define		bAntHT1			0x1000
+#define		bAntHT2			0x10000
+#define		bAntHT1S1			0x100000
+#define		bAntNonHTS1		0x1000000
+
+/* 4. PageA(0xA00) */
+#define		bCCKBBMode                		0x3	/* Useless */
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */
+
+#define		bCCKScramble              		0x8	/* Useless */
+#define		bCCKAntDiversity			0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate			0x3000
+#define		bCCKDCCancel		0x0800
+#define		bCCKISICancel		0x0400
+#define		bCCKMatchFilter		0x0200
+#define		bCCKEqualizer		0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart		0x300000
+#define		bCCKCCACount		0x080000
+#define		bCCKcs_lim			0x070000
+#define		bCCKBistMode		0x80000000
+#define		bCCKCCAMask		0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset		0xf0
+#define		bCCKRxDCOffset		0xf
+#define		bCCKCCAMode		0xc000
+#define		bCCKFalseCS_lim		0x3f00
+#define		bCCKCS_ratio		0xc00000
+#define		bCCKCorgBit_sel		0x300000
+#define		bCCKPD_lim		0x0f0000
+#define		bCCKNewCCA		0x80000000
+#define		bCCKRxHPofIG		0x8000
+#define		bCCKRxIG			0x7f00
+#define		bCCKLNAPolarity		0x800000
+#define		bCCKRx1stGain		0x7f0000
+#define		bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
+#define		bCCKFixedRxAGC		0x8000
+/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType		0x0300
+#define		bCCKRxDAGCEn		0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0			0x3f0000
+#define		bCCKTxC1			0x3f000000
+#define		bCCKTxC2			0x3f
+#define		bCCKTxC3			0x3f00
+#define		bCCKTxC4			0x3f0000
+#define		bCCKTxC5			0x3f000000
+#define		bCCKTxC6			0x3f
+#define		bCCKTxC7			0x3f00
+#define		bCCKDebugPort		0xff0000
+#define		bCCKDACDebug		0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead	0x4000
+#define		bCCKTRSSI			0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff	0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel		0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+/* 5. PageC(0xC00) */
+#define		bNumOfSTF                			0x3	/* Useless */
+#define		bShift_L			0xc0
+#define		bGI_TH			0xc
+#define		bRxPathA			0x1
+#define		bRxPathB			0x2
+#define		bRxPathC			0x4
+#define		bRxPathD			0x8
+#define		bTxPathA			0x1
+#define		bTxPathB			0x2
+#define		bTxPathC			0x4
+#define		bTxPathD			0x8
+#define		bTRSSIFreq			0x200
+#define		bADCBackoff			0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset		0xff00
+#define		bRxDFIRMode		0x1800000
+#define		bRxDCNFType		0xe000000
+#define		bRXIQImb_A		0x3ff
+#define		bRXIQImb_B			0xfc00
+#define		bRXIQImb_C			0x3f0000
+#define		bRXIQImb_D		0xffc00000
+#define		bDC_dc_Notch		0x60000
+#define		bRxNBINotch		0x1f000000
+#define		bPD_TH			0xf
+#define		bPD_TH_Opt2		0xc000
+#define		bPWED_TH			0x700
+#define		bIfMF_Win_L		0x800
+#define		bPD_Option			0x1000
+#define		bMF_Win_L			0xe000
+#define		bBW_Search_L		0x30000
+#define		bwin_enh_L			0xc0000
+#define		bBW_TH			0x700000
+#define		bED_TH2			0x3800000
+#define		bBW_option			0x4000000
+#define		bRatio_TH			0x18000000
+#define		bWindow_L			0xe0000000
+#define		bSBD_Option		0x1
+#define		bFrame_TH			0x1c
+#define		bFS_Option			0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune			0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2		0x7
+#define		bFrame_GI2_TH		0x38
+#define		bGI2_Sync_en		0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum		0x1
+#define		bCFOAcc			0x2
+#define		bCFOStartOffset		0xc
+#define		bCFOLookBack		0x70
+#define		bCFOSumWeight		0x80
+#define		bDAGCEnable		0x10000
+#define		bTXIQImb_A			0x3ff
+#define		bTXIQImb_B			0xfc00
+#define		bTXIQImb_C			0x3f0000
+#define		bTXIQImb_D			0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset		0xff00
+#define		bTxDFIRMode		0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption		0x20000
+#define		bCCADropThres		0xfff00000
+#define		bEDCCA_H			0xf
+#define		bEDCCA_L			0xf0
+#define		bLambda_ED		0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn		0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En		0x10000000
+#define		bRxQuickAGCEn		0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift			0x7f
+#define		bTRSW_Tri_Only		0x80
+#define		bPowerThres		0x300
+#define		bRxAGCEn			0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin		0x4
+#define		bRxHP_Ini			0x7
+#define		bRxHP_TRLNA		0x70
+#define		bRxHP_RSSI			0x700
+#define		bRxHP_BBP1		0x7000
+#define		bRxHP_BBP2		0x70000
+#define		bRxHP_BBP3		0x700000
+#define		bRSSI_H                  			0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen                			0x7f000000   /* the threshold for ant diversity */
+#define		bRxSettle_TRSW		0x7
+#define		bRxSettle_LNA		0x38
+#define		bRxSettle_RSSI		0x1c0
+#define		bRxSettle_BBP		0xe00
+#define		bRxSettle_RxHP		0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI		0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final			0x7000000
+#define		bRxHTSettle_BBP		0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn		0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin		0x80000
+#define		bRxHTAGCEn		0x100000
+#define		bRxHTDAGCEn		0x200000
+#define		bRxHTRxHP_BBP		0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH		0x3
+#define		bRxPWRatioEn		0x4
+#define		bRxMFHold			0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+/* #define bRxMF_Hold               0x3800 */
+#define		bRxPD_Delay_TH		0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L		0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH			0xc0000000
+#define		bDFSCnt0			0xff
+#define		bDFSCnt1			0xff00
+#define		bDFSFlag			0xf0000
+#define		bMFWeightSum		0x300000
+#define		bMinIdxTH			0x7f000000
+#define		bDAFormat			0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain		0x7c00
+
+/* 6. PageE(0xE00) */
+#define		bSTBCEn                  			0x4	/* Useless */
+#define		bAntennaMapping		0x10
+#define		bNss			0x20
+#define		bCFOAntSumD		0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet		0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+/* #define bRxPath1                 0x01 */
+/* #define bRxPath2                 0x02 */
+/* #define bRxPath3                 0x04 */
+/* #define bRxPath4                 0x08 */
+/* #define bTxPath1                 0x10 */
+/* #define bTxPath2                 0x20 */
+#define		bHTDetect			0x100
+#define		bCFOEn			0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re			0x3f
+#define		bSigTone_Im			0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail		0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail		0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync		0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength         		12   /* total */
+#define		bShortCFOFLength         		11   /* fraction */
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength		11
+#define		bLongCFOFLength		11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW		0x1
+#define		bRxSC			0x6
+#define		bRx_HT			0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg		0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain			0x3f
+#define		bTableSel			0x40
+#define		bTRSW			0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st			0xff
+#define		bCSI2nd			0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd		0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB			0xff00
+#define		bSGIEN			0x10000
+
+#define		bSFactorQAM1             		0xf	/* Useless */
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet          		0x3	/* Useless */
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode		0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType             			0x1	/* Useless */
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO		0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC				0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF			0x20000
+#define		bComChCFO		0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz		0x100000
+#define		bUChCfg			0x7000000
+#define		bUpdEqz			0x8000000
+
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn         		0x20000000	/* Useless */
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C		0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+/* 7. RF Register
+ * Zebra1 */
+#define		bZebra1_HSSIEnable        		0x8		/* Useless */
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1      	0x100	/* Useless */
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW	0x18
+#define		bRTL8256_RxLPFBW	0x600
+
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW          	0xc	/* Useless */
+#define		bRTL8258_RxLPFBW	0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+/*
+ * Other Definition
+ *   */
+
+/* byte endable for sb_write */
+#define		bByte0                    			0x1	/* Useless */
+#define		bByte1			0x2
+#define		bByte2			0x4
+#define		bByte3			0x8
+#define		bWord0			0x3
+#define		bWord1			0xc
+#define		bDWord			0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0                		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define		bMaskByte1		0xff00
+#define		bMaskByte2		0xff0000
+#define		bMaskByte3		0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord		0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes				0xffffff00
+#define		bMask12Bits				0xfff
+#define		bMaskH4Bits				0xf0000000
+#define		bMaskOFDM_D			0xffc00000
+#define		bMaskCCK				0x3f3f3f3f
+
+
+
+#define		bEnable                   0x1	/* Useless */
+#define		bDisable                  0x0
+
+#define		LeftAntenna               			0x0	/* Useless */
+#define		RightAntenna		0x1
+
+#define		tCheckTxStatus            		500   /* 500ms */ /* Useless */
+#define		tUpdateRxCounter          		100   /* 100ms */
+
+#define		rateCCK     				0	/* Useless */
+#define		rateOFDM				1
+#define		rateHT					2
+
+/* define Register-End */
+#define		bPMAC_End                 		0x1ff	/* Useless */
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+/* define max debug item in each debug page
+ * #define bMaxItem_FPGA_PHY0        0x9
+ * #define bMaxItem_FPGA_PHY1        0x3
+ * #define bMaxItem_PHY_11B          0x16
+ * #define bMaxItem_OFDM_PHY0        0x29
+ * #define bMaxItem_OFDM_PHY1        0x0 */
+
+#define		bPMACControl              		0x0		/* Useless */
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA                     			0x0	/* Useless */
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/Hal8188EPwrSeq.h b/drivers/staging/rtl8188eu/include/Hal8188EPwrSeq.h
new file mode 100644
index 000000000000..af8eacef3383
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188EPwrSeq.h
@@ -0,0 +1,159 @@
+
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef __HAL8188EPWRSEQ_H__
+#define __HAL8188EPWRSEQ_H__
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20110607-Paul-RTL8188E_Power_Architecture-R02.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+
+    PWR SEQ Version: rtl8188E_PwrSeq_V09.h
+*/
+#define	RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS	10
+#define	RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS	10
+#define	RTL8188E_TRANS_SUS_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS	10
+#define	RTL8188E_TRANS_PDN_TO_CARDEMU_STEPS	10
+#define	RTL8188E_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8188E_TRANS_LPS_TO_ACT_STEPS	15
+#define	RTL8188E_TRANS_END_STEPS	1
+
+
+#define RTL8188E_TRANS_CARDEMU_TO_ACT														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0 | BIT1, 0}, /* 0x02[1:0] = 0	reset BB*/			\
+	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0}, /* 0x04[15] = 0 disable HWPDN (control by DRV)*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4 | BIT3, 0}, /*0x04[12:11] = 2b'00 disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*0x04[8] = 1 polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0}, /*wait till 0x04[8] = 0*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*LDO normal mode*/	\
+
+#define RTL8188E_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*LDO Sleep mode*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+
+#define RTL8188E_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3 | BIT4}, /*0x04[12:11] = 2b'11enable WL suspend for PCIe*/	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, BIT7}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
+	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8188E_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8188E_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /*0x24[23] = 2b'01 schmit trigger */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*  0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */	\
+	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*Clear SIC_EN register 0x40[12] = 1'b0 */	\
+	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4}, /*Set USB suspend enable local register  0xfe10[4]=1 */	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/
+
+#define RTL8188E_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8188E_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8188E_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+	/* This is used by driver for LPSRadioOff Procedure, not for FW LPS Step */
+#define RTL8188E_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8188E_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6 | BIT7, 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8188E_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},
+
+
+	extern WLAN_PWR_CFG rtl8188E_power_on_flow[RTL8188E_TRANS_CARDEMU_TO_ACT_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_radio_off_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_card_disable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_card_enable_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_suspend_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_resume_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_hwpdn_flow[RTL8188E_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188E_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_enter_lps_flow[RTL8188E_TRANS_ACT_TO_LPS_STEPS + RTL8188E_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188E_leave_lps_flow[RTL8188E_TRANS_LPS_TO_ACT_STEPS + RTL8188E_TRANS_END_STEPS];
+
+#endif /* __HAL8188EPWRSEQ_H__ */
diff --git a/drivers/staging/rtl8188eu/include/Hal8188FPhyCfg.h b/drivers/staging/rtl8188eu/include/Hal8188FPhyCfg.h
new file mode 100644
index 000000000000..e483d67f58fc
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188FPhyCfg.h
@@ -0,0 +1,123 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __INC_HAL8188FPHYCFG_H__
+#define __INC_HAL8188FPHYCFG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		/* us */
+#define AntennaDiversityValue	0x80	/* (Adapter->bSoftwareAntennaDiversity ? 0x00 : 0x80) */
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+#ifdef CONFIG_PCI_HCI
+	#define MAX_AGGR_NUM	0x0B
+#else
+	#define MAX_AGGR_NUM	0x07
+#endif /* CONFIG_PCI_HCI */
+
+
+/*--------------------------Define Parameters End-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+/*------------------------------Define structure End----------------------------*/
+
+/*--------------------------Exported Function prototype---------------------*/
+u32
+PHY_QueryBBReg_8188F(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask
+);
+
+void
+PHY_SetBBReg_8188F(
+	IN	PADAPTER	Adapter,
+	IN	u32		RegAddr,
+	IN	u32		BitMask,
+	IN	u32		Data
+);
+
+u32
+PHY_QueryRFReg_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask
+);
+
+void
+PHY_SetRFReg_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8				eRFPath,
+	IN	u32				RegAddr,
+	IN	u32				BitMask,
+	IN	u32				Data
+);
+
+/* MAC/BB/RF HAL config */
+int PHY_BBConfig8188F(PADAPTER	Adapter);
+
+int PHY_RFConfig8188F(PADAPTER	Adapter);
+
+s32 PHY_MACConfig8188F(PADAPTER padapter);
+
+int
+PHY_ConfigRFWithParaFile_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8				*pFileName,
+	RF_PATH				eRFPath
+);
+
+void
+PHY_SetTxPowerIndex_8188F(
+	IN	PADAPTER			Adapter,
+	IN	u32					PowerIndex,
+	IN	u8					RFPath,
+	IN	u8					Rate
+);
+
+u8
+PHY_GetTxPowerIndex_8188F(
+	IN	PADAPTER			pAdapter,
+	IN	u8					RFPath,
+	IN	u8					Rate,
+	IN	u8		BandWidth,
+	IN	u8					Channel,
+	struct txpwr_idx_comp *tic
+);
+
+void
+PHY_GetTxPowerLevel8188F(
+	IN	PADAPTER		Adapter,
+	OUT s32				*powerlevel
+);
+
+void
+PHY_SetTxPowerLevel8188F(
+	IN	PADAPTER		Adapter,
+	IN	u8			channel
+);
+
+void
+PHY_SetSwChnlBWMode8188F(
+	IN	PADAPTER			Adapter,
+	IN	u8					channel,
+	IN	CHANNEL_WIDTH		Bandwidth,
+	IN	u8					Offset40,
+	IN	u8					Offset80
+);
+
+void phy_set_rf_path_switch_8188f(
+	IN	PADAPTER	pAdapter,
+	IN	bool		bMain
+);
+
+void BBTurnOnBlock_8188F(_adapter *adapter);
+
+/*--------------------------Exported Function prototype End---------------------*/
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/Hal8188FPhyReg.h b/drivers/staging/rtl8188eu/include/Hal8188FPhyReg.h
new file mode 100644
index 000000000000..41274918a297
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188FPhyReg.h
@@ -0,0 +1,1154 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __INC_HAL8188FPHYREG_H__
+#define __INC_HAL8188FPHYREG_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/* ************************************************************
+ * Regsiter offset definition
+ * ************************************************************ */
+
+/*
+ * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+ * 3. RF register 0x00-2E
+ * 4. Bit Mask for BB/RF register
+ * 5. Other defintion for BB/RF R/W
+ *   */
+
+
+/*
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 1. Page1(0x100)
+ *   */
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+/*
+ * 2. Page2(0x200)
+ *
+ * The following two definition are only used for USB interface. */
+#define		RF_BB_CMD_ADDR				0x02c0	/* RF/BB read/write command address. */
+#define		RF_BB_CMD_DATA				0x02c4	/* RF/BB read/write command data. */
+
+/*
+ * 3. Page8(0x800)
+ *   */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA0_TxInfo				0x804	/* Status report?? */
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */
+
+#define		rFPGA0_RFTiming1			0x810	/* Useless now */
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rTxAGC_B_Rate18_06				0x830
+#define		rTxAGC_B_Rate54_24				0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
+#define		TransceiverA_HSPI_Readback	0x8b8	/* Transceiver A HSPI Readback */
+#define		TransceiverB_HSPI_Readback	0x8bc	/* Transceiver B HSPI Readback */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */
+
+/*
+ * 4. Page9(0x900)
+ *   */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/* Useless now */
+#define		rFPGA1_DebugSelect			0x908	/* Useless now */
+#define		rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
+#define	rS0S1_PathSwitch			0x948
+
+/*
+ * 5. PageA(0xA00)
+ *
+ * Set Control channel to upper or lower. These settings are required only for 40MHz */
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */
+
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
+#define		rCCK0_TRSSIReport		0xa50
+#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c
+ *
+ * PageB(0xB00)
+ *   */
+#define		rPdp_AntA				0xb00
+#define		rPdp_AntA_4				0xb04
+#define		rConfig_Pmpd_AntA			0xb28
+#define		rConfig_AntA				0xb68
+#define		rConfig_AntB				0xb6c
+#define		rPdp_AntB					0xb70
+#define		rPdp_AntB_4				0xb74
+#define		rConfig_Pmpd_AntB			0xb98
+#define		rAPK						0xbd8
+
+/*
+ * 6. PageC(0xC00)
+ *   */
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
+#define		rOFDM0_XBRxAFE		0xc18
+#define		rOFDM0_XBRxIQImbalance	0xc1c
+#define		rOFDM0_XCRxAFE		0xc20
+#define		rOFDM0_XCRxIQImbalance	0xc24
+#define		rOFDM0_XDRxAFE		0xc28
+#define		rOFDM0_XDRxIQImbalance	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */
+
+#define		rOFDM0_XAAGCCore1			0xc50	/* DIG */
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+
+/*
+ * 7. PageD(0xD00)
+ *   */
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	/* No setting now */
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
+
+#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1		0xdc4
+#define		rOFDM_PWMeasure2		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+/*
+ * 8. PageE(0xE00)
+ *   */
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rFPGA0_IQK					0xe28
+#define		rTx_IQK_Tone_A				0xe30
+#define		rRx_IQK_Tone_A				0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK						0xe40
+#define		rRx_IQK						0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B				0xe50
+#define		rRx_IQK_Tone_B				0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont				0xe60
+
+#define		rBlue_Tooth					0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON				0xe78
+#define		rTx_OFDM_RFON				0xe7c
+#define		rTx_OFDM_BBON				0xe80
+#define		rTx_To_Rx					0xe84
+#define		rTx_To_Tx					0xe88
+#define		rRx_CCK						0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM					0xed0
+#define		rRx_Wait_RIFS				0xed4
+#define		rRx_TO_Rx					0xed8
+#define		rStandby						0xedc
+#define		rSleep						0xee0
+#define		rPMPD_ANAEN				0xeec
+
+/*
+ * 7. RF Register 0x00-0x2E (RF 8256)
+ * RF-0222D 0x00-3F
+ *
+ * Zebra1 */
+#define		rZebra1_HSSIEnable				0x0	/* Useless now */
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	/* RF channel switch */
+
+/* #endif */
+#define		rZebra1_TxGain					0x8	/* Useless now */
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+/* Zebra4 */
+#define		rGlobalCtrl						0	/* Useless now */
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/* Useless now */
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+/*
+ * RL6052 Register definition
+ *   */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_IPA_G					0x09	/*  */
+#define		RF_TXBIAS_G				0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A					0x0C	/*  */
+#define		RF_TXBIAS_A				0x0D
+#define		RF_BS_PA_APSET_G9_G11	0x0E
+#define		RF_BS_IQGEN				0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_TXBIAS					0x16
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/* RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x24	/*  */
+
+#define		RF_SYN_G1					0x25	/* RF TX Power control */
+#define		RF_SYN_G2					0x26	/* RF TX Power control */
+#define		RF_SYN_G3					0x27	/* RF TX Power control */
+#define		RF_SYN_G4					0x28	/* RF TX Power control */
+#define		RF_SYN_G5					0x29	/* RF TX Power control */
+#define		RF_SYN_G6					0x2A	/* RF TX Power control */
+#define		RF_SYN_G7					0x2B	/* RF TX Power control */
+#define		RF_SYN_G8					0x2C	/* RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/* RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/* RF TX PA control */
+#define		RF_TXPA_G2					0x32	/* RF TX PA control */
+#define		RF_TXPA_G3					0x33	/* RF TX PA control */
+#define	RF_TX_BIAS_A				0x35
+#define	RF_TX_BIAS_D				0x36
+#define	RF_LOBF_9					0x38
+#define 	RF_RXRF_A3					0x3C	/*	 */
+#define	RF_TRSW					0x3F
+
+#define	RF_TXRF_A2					0x41
+#define	RF_TXPA_G4					0x46
+#define	RF_TXPA_A4					0x4B
+#define	RF_0x52					0x52
+#define		RF_RXG_MIX_SWBW				0x87
+#define		RF_DBG_LP_RX2				0xDF
+#define	RF_WE_LUT					0xEF
+#define	RF_S0S1					0xB0
+
+#define RF_TX_GAIN_OFFSET_8188F(_val) (abs((_val)) | (((_val) > 0) ? BIT5 : 0))
+
+/*
+ * Bit Mask
+ *
+ * 1. Page1(0x100) */
+#define		bBBResetB						0x100	/* Useless now? */
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+/* 2. Page8(0x800) */
+#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
+#define		bOFDMTxDACPhase		0x40000
+#define		bXATxAGC			0x3f
+
+#define		bAntennaSelect		0x0300
+
+#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
+#define		bXCTxAGC			0xf000
+#define		bXDTxAGC			0xf0000
+
+#define		bPAStart                  			0xf0000000	/* Useless now */
+#define		bTRStart			0x00f00000
+#define		bRFStart			0x0000f000
+#define		bBBStart			0x000000f0
+#define		bBBCCKStart		0x0000000f
+#define		bPAEnd                    			0xf          /* Reg0x814 */
+#define		bTREnd			0x0f000000
+#define		bRFEnd			0x000f0000
+#define		bCCAMask                  			0x000000f0   /* T2R */
+#define		bR2RCCAMask		0x00000f00
+#define		bHSSI_R2TDelay		0xf8000000
+#define		bHSSI_T2RDelay		0xf80000
+#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
+#define		bIGFromCCK		0x200
+#define		bAGCAddress		0x3f
+#define		bRxHPTx			0x7000
+#define		bRxHPT2R			0x38000
+#define		bRxHPCCKIni		0xc0000
+#define		bAGCTxCode		0xc00000
+#define		bAGCRxCode		0x300000
+
+#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
+#define		b3WireAddressLength		0x400
+
+#define		b3WireRFPowerDown         		0x1	/* Useless now
+ * #define bHWSISelect		0x8 */
+#define		b5GPAPEPolarity		0x40000000
+#define		b2GPAPEPolarity		0x80000000
+#define		bRFSW_TxDefaultAnt		0x3
+#define		bRFSW_TxOptionAnt		0x30
+#define		bRFSW_RxDefaultAnt		0x300
+#define		bRFSW_RxOptionAnt		0x3000
+#define		bRFSI_3WireData		0x1
+#define		bRFSI_3WireClock		0x2
+#define		bRFSI_3WireLoad		0x4
+#define		bRFSI_3WireRW		0x8
+#define		bRFSI_3Wire			0xf
+
+#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+
+#define		bRFSI_TRSW                		0x20	/* Useless now */
+#define		bRFSI_TRSWB		0x40
+#define		bRFSI_ANTSW		0x100
+#define		bRFSI_ANTSWB		0x200
+#define		bRFSI_PAPE			0x400
+#define		bRFSI_PAPE5G		0x800
+#define		bBandSelect			0x1
+#define		bHTSIG2_GI			0x80
+#define		bHTSIG2_Smoothing		0x01
+#define		bHTSIG2_Sounding		0x02
+#define		bHTSIG2_Aggreaton		0x08
+#define		bHTSIG2_STBC		0x30
+#define		bHTSIG2_AdvCoding		0x40
+#define		bHTSIG2_NumOfHTLTF	0x300
+#define		bHTSIG2_CRC8		0x3fc
+#define		bHTSIG1_MCS		0x7f
+#define		bHTSIG1_BandWidth		0x80
+#define		bHTSIG1_HTLength		0xffff
+#define		bLSIG_Rate			0xf
+#define		bLSIG_Reserved		0x10
+#define		bLSIG_Length		0x1fffe
+#define		bLSIG_Parity			0x20
+#define		bCCKRxPhase		0x4
+
+#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */
+
+#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */
+
+#define		bLSSIReadBackData         		0xfffff		/* T65 RF */
+
+#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
+#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
+#define		bRegulator0Standby		0x1
+#define		bRegulatorPLLStandby		0x2
+#define		bRegulator1Standby		0x4
+#define		bPLLPowerUp		0x8
+#define		bDPLLPowerUp		0x10
+#define		bDA10PowerUp		0x20
+#define		bAD7PowerUp		0x200
+#define		bDA6PowerUp		0x2000
+#define		bXtalPowerUp		0x4000
+#define		b40MDClkPowerUP		0x8000
+#define		bDA6DebugMode		0x20000
+#define		bDA6Swing			0x380000
+
+#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+
+#define		b80MClkDelay              		0x18000000	/* Useless */
+#define		bAFEWatchDogEnable		0x20000000
+
+#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define		bXtalCap23			0x3
+#define		bXtalCap92x					0x0f000000
+#define		bXtalCap			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	/* Useless */
+#define		bExtSigClkEnable		0x800
+#define		bBandgapMbiasPowerUp	0x10000
+#define		bAD11SHGain		0xc0000
+#define		bAD11InputRange		0x700000
+#define		bAD11OPCurrent		0x3800000
+#define		bIPathLoopback		0x4000000
+#define		bQPathLoopback		0x8000000
+#define		bAFELoopback		0x10000000
+#define		bDA10Swing		0x7e0
+#define		bDA10Reverse		0x800
+#define		bDAClkSource		0x1000
+#define		bAD7InputRange		0x6000
+#define		bAD7Gain			0x38000
+#define		bAD7OutputCMMode		0x40000
+#define		bAD7InputCMMode		0x380000
+#define		bAD7Current			0xc00000
+#define		bRegulatorAdjust		0x7000000
+#define		bAD11PowerUpAtTx		0x1
+#define		bDA10PSAtTx		0x10
+#define		bAD11PowerUpAtRx		0x100
+#define		bDA10PSAtRx		0x1000
+#define		bCCKRxAGCFormat		0x200
+#define		bPSDFFTSamplepPoint		0xc000
+#define		bPSDAverageNum		0x3000
+#define		bIQPathControl		0xc00
+#define		bPSDFreq			0x3ff
+#define		bPSDAntennaPath		0x30
+#define		bPSDIQSwitch		0x40
+#define		bPSDRxTrigger		0x400000
+#define		bPSDTxTrigger		0x80000000
+#define		bPSDSineToneScale		0x7f000000
+#define		bPSDReport			0xffff
+
+/* 3. Page9(0x900) */
+#define		bOFDMTxSC                 		0x30000000	/* Useless */
+#define		bCCKTxOn			0x1
+#define		bOFDMTxOn		0x2
+#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem                		0xff   /* reset debug page and LWord */
+#define		bAntL			0x10
+#define		bAntNonHT				0x100
+#define		bAntHT1			0x1000
+#define		bAntHT2			0x10000
+#define		bAntHT1S1			0x100000
+#define		bAntNonHTS1		0x1000000
+
+/* 4. PageA(0xA00) */
+#define		bCCKBBMode				0x3	/* Useless */
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand			0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */
+
+#define		bCCKScramble			0x8	/* Useless */
+#define		bCCKAntDiversity		0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel			0x0800
+#define		bCCKISICancel			0x0400
+#define		bCCKMatchFilter			0x0200
+#define		bCCKEqualizer			0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart			0x300000
+#define		bCCKCCACount			0x080000
+#define		bCCKcs_lim				0x070000
+#define		bCCKBistMode			0x80000000
+#define		bCCKCCAMask			0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset			0xf0
+#define		bCCKRxDCOffset			0xf
+#define		bCCKCCAMode			0xc000
+#define		bCCKFalseCS_lim			0x3f00
+#define		bCCKCS_ratio			0xc00000
+#define		bCCKCorgBit_sel			0x300000
+#define		bCCKPD_lim				0x0f0000
+#define		bCCKNewCCA			0x80000000
+#define		bCCKRxHPofIG			0x8000
+#define		bCCKRxIG				0x7f00
+#define		bCCKLNAPolarity			0x800000
+#define		bCCKRx1stGain			0x7f0000
+#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
+#define		bCCKFixedRxAGC			0x8000
+/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType	0x0300
+#define		bCCKRxDAGCEn			0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0				0x3f0000
+#define		bCCKTxC1				0x3f000000
+#define		bCCKTxC2				0x3f
+#define		bCCKTxC3				0x3f00
+#define		bCCKTxC4				0x3f0000
+#define		bCCKTxC5				0x3f000000
+#define		bCCKTxC6				0x3f
+#define		bCCKTxC7				0x3f00
+#define		bCCKDebugPort			0xff0000
+#define		bCCKDACDebug			0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI				0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel			0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+/* 5. PageC(0xC00) */
+#define		bNumOfSTF				0x3	/* Useless */
+#define		bShift_L					0xc0
+#define		bGI_TH					0xc
+#define		bRxPathA				0x1
+#define		bRxPathB				0x2
+#define		bRxPathC				0x4
+#define		bRxPathD				0x8
+#define		bTxPathA				0x1
+#define		bTxPathB				0x2
+#define		bTxPathC				0x4
+#define		bTxPathD				0x8
+#define		bTRSSIFreq				0x200
+#define		bADCBackoff				0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode			0x1800000
+#define		bRxDCNFType			0xe000000
+#define		bRXIQImb_A				0x3ff
+#define		bRXIQImb_B				0xfc00
+#define		bRXIQImb_C				0x3f0000
+#define		bRXIQImb_D				0xffc00000
+#define		bDC_dc_Notch			0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH					0xf
+#define		bPD_TH_Opt2			0xc000
+#define		bPWED_TH				0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option				0x1000
+#define		bMF_Win_L				0xe000
+#define		bBW_Search_L			0x30000
+#define		bwin_enh_L				0xc0000
+#define		bBW_TH					0x700000
+#define		bED_TH2				0x3800000
+#define		bBW_option				0x4000000
+#define		bRatio_TH				0x18000000
+#define		bWindow_L				0xe0000000
+#define		bSBD_Option				0x1
+#define		bFrame_TH				0x1c
+#define		bFS_Option				0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune				0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2			0x7
+#define		bFrame_GI2_TH			0x38
+#define		bGI2_Sync_en			0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc				0x2
+#define		bCFOStartOffset			0xc
+#define		bCFOLookBack			0x70
+#define		bCFOSumWeight			0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A				0x3ff
+#define		bTXIQImb_B				0xfc00
+#define		bTXIQImb_C				0x3f0000
+#define		bTXIQImb_D				0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode			0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption			0x20000
+#define		bCCADropThres			0xfff00000
+#define		bEDCCA_H				0xf
+#define		bEDCCA_L				0xf0
+#define		bLambda_ED			0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn				0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En			0x10000000
+#define		bRxQuickAGCEn			0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift				0x7f
+#define		bTRSW_Tri_Only			0x80
+#define		bPowerThres			0x300
+#define		bRxAGCEn				0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin				0x4
+#define		bRxHP_Ini				0x7
+#define		bRxHP_TRLNA			0x70
+#define		bRxHP_RSSI				0x700
+#define		bRxHP_BBP1				0x7000
+#define		bRxHP_BBP2				0x70000
+#define		bRxHP_BBP3				0x700000
+#define		bRSSI_H					0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
+#define		bRxSettle_TRSW			0x7
+#define		bRxSettle_LNA			0x38
+#define		bRxSettle_RSSI			0x1c0
+#define		bRxSettle_BBP			0xe00
+#define		bRxSettle_RxHP			0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI			0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final				0x7000000
+#define		bRxHTSettle_BBP			0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn			0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin			0x80000
+#define		bRxHTAGCEn				0x100000
+#define		bRxHTDAGCEn			0x200000
+#define		bRxHTRxHP_BBP			0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH			0x3
+#define		bRxPWRatioEn			0x4
+#define		bRxMFHold				0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+/* #define bRxMF_Hold               0x3800 */
+#define		bRxPD_Delay_TH			0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L			0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH				0xc0000000
+#define		bDFSCnt0				0xff
+#define		bDFSCnt1				0xff00
+#define		bDFSFlag				0xf0000
+#define		bMFWeightSum			0x300000
+#define		bMinIdxTH				0x7f000000
+#define		bDAFormat				0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain				0x7c00
+
+/* 6. PageE(0xE00) */
+#define		bSTBCEn				0x4	/* Useless */
+#define		bAntennaMapping		0x10
+#define		bNss					0x20
+#define		bCFOAntSumD			0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet			0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+/* #define bRxPath1                 0x01 */
+/* #define bRxPath2                 0x02 */
+/* #define bRxPath3                 0x04 */
+/* #define bRxPath4                 0x08 */
+/* #define bTxPath1                 0x10 */
+/* #define bTxPath2                 0x20 */
+#define		bHTDetect			0x100
+#define		bCFOEn				0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re		0x3f
+#define		bSigTone_Im		0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail	0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail	0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync	0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength	12   /* total */
+#define		bShortCFOFLength	11   /* fraction */
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength	11
+#define		bLongCFOFLength	11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW			0x1
+#define		bRxSC				0x6
+#define		bRx_HT				0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg	0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain				0x3f
+#define		bTableSel			0x40
+#define		bTRSW				0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st				0xff
+#define		bCSI2nd				0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd			0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB				0xff00
+#define		bSGIEN				0x10000
+
+#define		bSFactorQAM1		0xf	/* Useless */
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet		0x3	/* Useless */
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode			0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType		0x1	/* Useless */
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO			0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC					0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF		0x20000
+#define		bComChCFO			0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz			0x100000
+#define		bUChCfg				0x7000000
+#define		bUpdEqz			0x8000000
+
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn		0x20000000	/* Useless */
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C	0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+/* 7. RF Register
+ * Zebra1 */
+#define		bZebra1_HSSIEnable		0x8		/* Useless */
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1	0x100	/* Useless */
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW		0x18
+#define		bRTL8256_RxLPFBW		0x600
+
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW		0xc	/* Useless */
+#define		bRTL8258_RxLPFBW		0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+/*
+ * Other Definition
+ *   */
+
+/* byte endable for sb_write */
+#define		bByte0				0x1	/* Useless */
+#define		bByte1				0x2
+#define		bByte2				0x4
+#define		bByte3				0x8
+#define		bWord0				0x3
+#define		bWord1				0xc
+#define		bDWord				0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0			0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define		bMaskByte1			0xff00
+#define		bMaskByte2			0xff0000
+#define		bMaskByte3			0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord			0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH3Bytes		0xffffff00
+#define		bMask12Bits			0xfff
+#define		bMaskH4Bits			0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK			0x3f3f3f3f
+
+
+#define		bEnable			0x1	/* Useless */
+#define		bDisable		0x0
+
+#define		LeftAntenna		0x0	/* Useless */
+#define		RightAntenna	0x1
+
+#define		tCheckTxStatus		500   /* 500ms */ /* Useless */
+#define		tUpdateRxCounter	100   /* 100ms */
+
+#define		rateCCK		0	/* Useless */
+#define		rateOFDM	1
+#define		rateHT		2
+
+/* define Register-End */
+#define		bPMAC_End			0x1ff	/* Useless */
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+/* define max debug item in each debug page
+ * #define bMaxItem_FPGA_PHY0        0x9
+ * #define bMaxItem_FPGA_PHY1        0x3
+ * #define bMaxItem_PHY_11B          0x16
+ * #define bMaxItem_OFDM_PHY0        0x29
+ * #define bMaxItem_OFDM_PHY1        0x0 */
+
+#define		bPMACControl		0x0		/* Useless */
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA			0x0	/* Useless */
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/* BB Register Definition
+ *
+ * 4. Page9(0x900)
+ *   */
+#define rDPDT_control				0x92c
+#define rfe_ctrl_anta_src				0x930
+#define rS0S1_PathSwitch			0x948
+#define	BBrx_DFIR						0x954
+#define AGC_table_select				0xb2c
+
+/*
+ * PageB(0xB00)
+ *   */
+#define rPdp_AntA						0xb00
+#define rPdp_AntA_4						0xb04
+#define rPdp_AntA_8						0xb08
+#define rPdp_AntA_C						0xb0c
+#define rPdp_AntA_10					0xb10
+#define rPdp_AntA_14					0xb14
+#define rPdp_AntA_18					0xb18
+#define rPdp_AntA_1C					0xb1c
+#define rPdp_AntA_20					0xb20
+#define rPdp_AntA_24					0xb24
+
+#define rConfig_Pmpd_AntA				0xb28
+#define rConfig_ram64x16				0xb2c
+
+#define rBndA							0xb30
+#define rHssiPar						0xb34
+
+#define rConfig_AntA					0xb68
+#define rConfig_AntB					0xb6c
+
+#define rPdp_AntB						0xb70
+#define rPdp_AntB_4						0xb74
+#define rPdp_AntB_8						0xb78
+#define rPdp_AntB_C						0xb7c
+#define rPdp_AntB_10					0xb80
+#define rPdp_AntB_14					0xb84
+#define rPdp_AntB_18					0xb88
+#define rPdp_AntB_1C					0xb8c
+#define rPdp_AntB_20					0xb90
+#define rPdp_AntB_24					0xb94
+
+#define rConfig_Pmpd_AntB				0xb98
+
+#define rBndB							0xba0
+
+#define rAPK							0xbd8
+#define rPm_Rx0_AntA					0xbdc
+#define rPm_Rx1_AntA					0xbe0
+#define rPm_Rx2_AntA					0xbe4
+#define rPm_Rx3_AntA					0xbe8
+#define rPm_Rx0_AntB					0xbec
+#define rPm_Rx1_AntB					0xbf0
+#define rPm_Rx2_AntB					0xbf4
+#define rPm_Rx3_AntB					0xbf8
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/Hal8188FPwrSeq.h b/drivers/staging/rtl8188eu/include/Hal8188FPwrSeq.h
new file mode 100644
index 000000000000..81e613227bdb
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/Hal8188FPwrSeq.h
@@ -0,0 +1,198 @@
+#ifndef REALTEK_POWER_SEQUENCE_8188F
+#define REALTEK_POWER_SEQUENCE_8188F
+
+#include "HalPwrSeqCmd.h"
+
+/*
+	Check document WM-20130815-JackieLau-RTL8188F_Power_Architecture v08.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT
+
+	TRANS_END
+*/
+#define	RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS	13
+#define	RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS	14
+#define	RTL8188F_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8188F_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8188F_TRANS_ACT_TO_LPS_STEPS		11
+#define	RTL8188F_TRANS_LPS_TO_ACT_STEPS		13
+#define	RTL8188F_TRANS_ACT_TO_SWLPS_STEPS		21
+#define	RTL8188F_TRANS_SWLPS_TO_ACT_STEPS		14
+#define	RTL8188F_TRANS_END_STEPS		1
+
+
+#define RTL8188F_TRANS_CARDEMU_TO_ACT														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, (BIT3), 0},/*  0x4[11]=1'b0 disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/* 0x4[8]=1 polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},/**/	 \
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x35}, /*0x27<=35 to reduce RF noise*/
+
+#define RTL8188F_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34}, /*0x27 <= 34, xtal_qsel = 0 to xtal bring up*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+
+#define RTL8188F_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07 = 0x00 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x00}, /*0x07 = 0x00 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK | PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, BIT3}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0}, /*wait power state to suspend*/ \
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+#define RTL8188F_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1}, /*wait power state to suspend*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3 | BIT4, 0}, /*0x04[12:11] = 2b'01enable WL suspend*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},/* 0xC4[4] <= 1, turn off USB APHY LDO under suspend mode*/
+
+
+#define RTL8188F_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},/* 0x04[15] = 1*/
+
+#define RTL8188F_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/* 0x04[15] = 0*/
+
+#define RTL8188F_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/
+
+
+#define RTL8188F_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_SDIO, PWR_CMD_WRITE, 0xFF, 0x84},  /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x35},/*xtal_qsel = 1 for low noise*/	\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x002B, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x1c, 0x1c},   /*.	0x2b[4:2] = 3b'111	to enable BB, AFE clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1 | BIT0, BIT1 | BIT0},  /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+
+#define RTL8188F_TRANS_ACT_TO_SWLPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0139, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*set RPWM IMR*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*CCK and OFDM are disabled, and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},/*Respond TxOK to scheduler*/	\
+	{0x002b, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0x1C, 0x00},/*0x2b[4:2]<=0 to gated BB, AFE clock*/	\
+	{0x0027, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x34},/*xtal_qsel = 0 for bring up*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x00},/* sdio LPS option*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0x83},/* usb LPS option, open bandgap, xtal*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, 0}, /* 0xC4[5]<=0, digital LDO no standby mode*/	\
+	{0x00C4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7}, /* 0xC4[7]<=1, on domain voltage adjust*/	\
+	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe0}, /* low power LPS enable for sdio*/	\
+	{0x00a7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xff, 0xe4}, /* low power LPS enable for usb*/	\
+	{0x0090, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /* enable WL_LPS_EN*/
+
+
+#define RTL8188F_TRANS_SWLPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},/*polling TSF stable*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1}, /*.	0x101[1] = 1, enable security engine*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x06B7, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x09}, /*.	reset MAC rx state machine*/\
+	{0x06B4, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x86}, /*.	reset MAC rx state machine*/\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},/* set CPU RAM code ready*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},/*Reset CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, 0},/* Enable CPU*/	\
+	{0x001D, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},/*enable CPU IO Wrapper*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT2, BIT2},/* Enable CPU*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, BIT7},/*polling FW init ready */	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT6, BIT6},/*polling FW init ready */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+
+#define RTL8188F_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK, 0, PWR_CMD_END, 0, 0},
+
+
+	extern WLAN_PWR_CFG rtl8188F_power_on_flow[RTL8188F_TRANS_CARDEMU_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_radio_off_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_card_disable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_card_enable_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_suspend_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_resume_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_SUS_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_hwpdn_flow[RTL8188F_TRANS_ACT_TO_CARDEMU_STEPS + RTL8188F_TRANS_CARDEMU_TO_PDN_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_enter_lps_flow[RTL8188F_TRANS_ACT_TO_LPS_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_leave_lps_flow[RTL8188F_TRANS_LPS_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_enter_swlps_flow[RTL8188F_TRANS_ACT_TO_SWLPS_STEPS + RTL8188F_TRANS_END_STEPS];
+	extern WLAN_PWR_CFG rtl8188F_leave_swlps_flow[RTL8188F_TRANS_SWLPS_TO_ACT_STEPS + RTL8188F_TRANS_END_STEPS];
+#endif
diff --git a/drivers/staging/rtl8188eu/include/HalPwrSeqCmd.h b/drivers/staging/rtl8188eu/include/HalPwrSeqCmd.h
new file mode 100644
index 000000000000..9979545429e9
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/HalPwrSeqCmd.h
@@ -0,0 +1,119 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HALPWRSEQCMD_H__
+#define __HALPWRSEQCMD_H__
+
+#include <drv_types.h>
+
+/*---------------------------------------------*/
+/* 3 The value of cmd: 4 bits
+ *---------------------------------------------*/
+#define PWR_CMD_READ			0x00
+/* offset: the read register offset
+ * msk: the mask of the read value
+ * value: N/A, left by 0
+ * note: dirver shall implement this function by read & msk */
+
+#define PWR_CMD_WRITE			0x01
+/* offset: the read register offset
+ * msk: the mask of the write bits
+ * value: write value
+ * note: driver shall implement this cmd by read & msk after write */
+
+#define PWR_CMD_POLLING			0x02
+/* offset: the read register offset
+ * msk: the mask of the polled value
+ * value: the value to be polled, masked by the msd field.
+ * note: driver shall implement this cmd by
+ * do {
+ * if( (Read(offset) & msk) == (value & msk) )
+ * break;
+ * } while(not timeout); */
+
+#define PWR_CMD_DELAY			0x03
+/* offset: the value to delay
+ * msk: N/A
+ * value: the unit of delay, 0: us, 1: ms */
+
+#define PWR_CMD_END				0x04
+/* offset: N/A
+ * msk: N/A
+ * value: N/A */
+
+/*---------------------------------------------*/
+/* 3 The value of base: 4 bits
+ *---------------------------------------------
+    * define the base address of each block */
+#define PWR_BASEADDR_MAC		0x00
+#define PWR_BASEADDR_USB		0x01
+#define PWR_BASEADDR_PCIE		0x02
+#define PWR_BASEADDR_SDIO		0x03
+
+/*---------------------------------------------*/
+/* 3 The value of interface_msk: 4 bits
+ *---------------------------------------------*/
+#define	PWR_INTF_SDIO_MSK		BIT(0)
+#define	PWR_INTF_USB_MSK		BIT(1)
+#define	PWR_INTF_PCI_MSK		BIT(2)
+#define	PWR_INTF_ALL_MSK		(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+/*---------------------------------------------*/
+/* 3 The value of fab_msk: 4 bits
+ *---------------------------------------------*/
+#define	PWR_FAB_TSMC_MSK		BIT(0)
+#define	PWR_FAB_UMC_MSK			BIT(1)
+#define	PWR_FAB_ALL_MSK			(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+
+/*---------------------------------------------*/
+/* 3 The value of cut_msk: 8 bits
+ *---------------------------------------------*/
+#define	PWR_CUT_TESTCHIP_MSK	BIT(0)
+#define	PWR_CUT_A_MSK			BIT(1)
+#define	PWR_CUT_B_MSK			BIT(2)
+#define	PWR_CUT_C_MSK			BIT(3)
+#define	PWR_CUT_D_MSK			BIT(4)
+#define	PWR_CUT_E_MSK			BIT(5)
+#define	PWR_CUT_F_MSK			BIT(6)
+#define	PWR_CUT_G_MSK			BIT(7)
+#define	PWR_CUT_ALL_MSK			0xFF
+
+
+typedef enum _PWRSEQ_CMD_DELAY_UNIT_ {
+	PWRSEQ_DELAY_US,
+	PWRSEQ_DELAY_MS,
+} PWRSEQ_DELAY_UNIT;
+
+typedef struct _WL_PWR_CFG_ {
+	u16 offset;
+	u8 cut_msk;
+	u8 fab_msk:4;
+	u8 interface_msk:4;
+	u8 base:4;
+	u8 cmd:4;
+	u8 msk;
+	u8 value;
+} WLAN_PWR_CFG, *PWLAN_PWR_CFG;
+
+
+#define GET_PWR_CFG_OFFSET(__PWR_CMD)		((__PWR_CMD).offset)
+#define GET_PWR_CFG_CUT_MASK(__PWR_CMD)		((__PWR_CMD).cut_msk)
+#define GET_PWR_CFG_FAB_MASK(__PWR_CMD)		((__PWR_CMD).fab_msk)
+#define GET_PWR_CFG_INTF_MASK(__PWR_CMD)	((__PWR_CMD).interface_msk)
+#define GET_PWR_CFG_BASE(__PWR_CMD)			((__PWR_CMD).base)
+#define GET_PWR_CFG_CMD(__PWR_CMD)			((__PWR_CMD).cmd)
+#define GET_PWR_CFG_MASK(__PWR_CMD)			((__PWR_CMD).msk)
+#define GET_PWR_CFG_VALUE(__PWR_CMD)		((__PWR_CMD).value)
+
+
+/* ********************************************************************************
+ *	Prototype of protected function.
+ * ******************************************************************************** */
+u8 HalPwrSeqCmdParsing(
+	PADAPTER		padapter,
+	u8				CutVersion,
+	u8				FabVersion,
+	u8				InterfaceType,
+	WLAN_PWR_CFG	PwrCfgCmd[]);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/HalVerDef.h b/drivers/staging/rtl8188eu/include/HalVerDef.h
new file mode 100644
index 000000000000..5b7c1b54afea
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/HalVerDef.h
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_VERSION_DEF_H__
+#define __HAL_VERSION_DEF_H__
+
+/* HAL_IC_TYPE_E */
+typedef enum tag_HAL_IC_Type_Definition {
+	CHIP_8192S	=	0,
+	CHIP_8188C	=	1,
+	CHIP_8192C	=	2,
+	CHIP_8192D	=	3,
+	CHIP_8723A	=	4,
+	CHIP_8188E	=	5,
+	CHIP_8812	=	6,
+	CHIP_8821	=	7,
+	CHIP_8723B	=	8,
+	CHIP_8192E	=	9,
+	CHIP_8814A	=	10,
+	CHIP_8703B	=	11,
+	CHIP_8188F	=	12,
+	CHIP_8822B	=	13,
+	CHIP_8723D	=	14,
+	CHIP_8821C	=	15
+} HAL_IC_TYPE_E;
+
+/* HAL_CHIP_TYPE_E */
+typedef enum tag_HAL_CHIP_Type_Definition {
+	TEST_CHIP		=	0,
+	NORMAL_CHIP	=	1,
+	FPGA			=	2,
+} HAL_CHIP_TYPE_E;
+
+/* HAL_CUT_VERSION_E */
+typedef enum tag_HAL_Cut_Version_Definition {
+	A_CUT_VERSION		=	0,
+	B_CUT_VERSION		=	1,
+	C_CUT_VERSION		=	2,
+	D_CUT_VERSION		=	3,
+	E_CUT_VERSION		=	4,
+	F_CUT_VERSION		=	5,
+	G_CUT_VERSION		=	6,
+	H_CUT_VERSION		=	7,
+	I_CUT_VERSION		=	8,
+	J_CUT_VERSION		=	9,
+	K_CUT_VERSION		=	10,
+} HAL_CUT_VERSION_E;
+
+/* HAL_Manufacturer */
+typedef enum tag_HAL_Manufacturer_Version_Definition {
+	CHIP_VENDOR_TSMC	=	0,
+	CHIP_VENDOR_UMC	=	1,
+	CHIP_VENDOR_SMIC	=	2,
+} HAL_VENDOR_E;
+
+typedef enum tag_HAL_RF_Type_Definition {
+	RF_TYPE_1T1R	=	0,
+	RF_TYPE_1T2R	=	1,
+	RF_TYPE_2T2R	=	2,
+	RF_TYPE_2T3R	=	3,
+	RF_TYPE_2T4R	=	4,
+	RF_TYPE_3T3R	=	5,
+	RF_TYPE_3T4R	=	6,
+	RF_TYPE_4T4R	=	7,
+} HAL_RF_TYPE_E;
+
+typedef	struct tag_HAL_VERSION {
+	HAL_IC_TYPE_E		ICType;
+	HAL_CHIP_TYPE_E		ChipType;
+	HAL_CUT_VERSION_E	CUTVersion;
+	HAL_VENDOR_E		VendorType;
+	HAL_RF_TYPE_E		RFType;
+	u8					ROMVer;
+} HAL_VERSION, *PHAL_VERSION;
+
+/* VERSION_8192C			VersionID;
+ * HAL_VERSION			VersionID; */
+
+/* Get element */
+#define GET_CVID_IC_TYPE(version)		(((version).ICType))
+#define GET_CVID_CHIP_TYPE(version)		(((version).ChipType))
+#define GET_CVID_RF_TYPE(version)		(((version).RFType))
+#define GET_CVID_MANUFACTUER(version)		(((version).VendorType))
+#define GET_CVID_CUT_VERSION(version)		(((version).CUTVersion))
+#define GET_CVID_ROM_VERSION(version)		(((version).ROMVer) & ROM_VERSION_MASK)
+
+/* ----------------------------------------------------------------------------
+ * Common Macro. --
+ * ----------------------------------------------------------------------------
+ * HAL_VERSION VersionID */
+
+/* HAL_IC_TYPE_E */
+#define IS_8188E(version)			((GET_CVID_IC_TYPE(version) == CHIP_8188E) ? true : false)
+#define IS_8188F(version)			((GET_CVID_IC_TYPE(version) == CHIP_8188F) ? true : false)
+#define IS_8192E(version)			((GET_CVID_IC_TYPE(version) == CHIP_8192E) ? true : false)
+#define IS_8812_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8812) ? true : false)
+#define IS_8821_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821) ? true : false)
+#define IS_8814A_SERIES(version)		((GET_CVID_IC_TYPE(version) == CHIP_8814A) ? true : false)
+#define IS_8723B_SERIES(version)		((GET_CVID_IC_TYPE(version) == CHIP_8723B) ? true : false)
+#define IS_8703B_SERIES(version)		((GET_CVID_IC_TYPE(version) == CHIP_8703B) ? true : false)
+#define IS_8822B_SERIES(version)		((GET_CVID_IC_TYPE(version) == CHIP_8822B) ? true : false)
+#define IS_8821C_SERIES(version)		((GET_CVID_IC_TYPE(version) == CHIP_8821C) ? true : false)
+#define IS_8723D_SERIES(version)\
+	((GET_CVID_IC_TYPE(version) == CHIP_8723D) ? true : false)
+/* HAL_CHIP_TYPE_E */
+#define IS_TEST_CHIP(version)			((GET_CVID_CHIP_TYPE(version) == TEST_CHIP) ? true : false)
+#define IS_NORMAL_CHIP(version)			((GET_CVID_CHIP_TYPE(version) == NORMAL_CHIP) ? true : false)
+
+/* HAL_CUT_VERSION_E */
+#define IS_A_CUT(version)			((GET_CVID_CUT_VERSION(version) == A_CUT_VERSION) ? true : false)
+#define IS_B_CUT(version)			((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? true : false)
+#define IS_C_CUT(version)			((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? true : false)
+#define IS_D_CUT(version)			((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? true : false)
+#define IS_E_CUT(version)			((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? true : false)
+#define IS_F_CUT(version)			((GET_CVID_CUT_VERSION(version) == F_CUT_VERSION) ? true : false)
+#define IS_I_CUT(version)			((GET_CVID_CUT_VERSION(version) == I_CUT_VERSION) ? true : false)
+#define IS_J_CUT(version)			((GET_CVID_CUT_VERSION(version) == J_CUT_VERSION) ? true : false)
+#define IS_K_CUT(version)			((GET_CVID_CUT_VERSION(version) == K_CUT_VERSION) ? true : false)
+
+/* HAL_VENDOR_E */
+#define IS_CHIP_VENDOR_TSMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_TSMC) ? true : false)
+#define IS_CHIP_VENDOR_UMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_UMC) ? true : false)
+#define IS_CHIP_VENDOR_SMIC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_SMIC) ? true : false)
+
+/* HAL_RF_TYPE_E */
+#define IS_1T1R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T1R) ? true : false)
+#define IS_1T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R) ? true : false)
+#define IS_2T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R) ? true : false)
+#define IS_3T3R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T3R) ? true : false)
+#define IS_3T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T4R) ? true : false)
+#define IS_4T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_4T4R) ? true : false)
+
+
+
+/* ----------------------------------------------------------------------------
+ * Chip version Macro. --
+ * ---------------------------------------------------------------------------- */
+#define IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)		((IS_8188E(GET_HAL_DATA(_Adapter)->version_id)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) >= I_CUT_VERSION) ? true : false) : false)
+#define IS_VENDOR_8812A_TEST_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? false : true) : false)
+#define IS_VENDOR_8812A_MP_CHIP(_Adapter)		((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? true : false) : false)
+#define IS_VENDOR_8812A_C_CUT(_Adapter)			((IS_8812_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) == C_CUT_VERSION) ? true : false) : false)
+
+#define IS_VENDOR_8821A_TEST_CHIP(_Adapter)	((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? false : true) : false)
+#define IS_VENDOR_8821A_MP_CHIP(_Adapter)		((IS_8821_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? true : false) : false)
+
+#define IS_VENDOR_8192E_B_CUT(_Adapter)		((GET_CVID_CUT_VERSION(GET_HAL_DATA(_Adapter)->version_id) == B_CUT_VERSION) ? true : false)
+
+#define IS_VENDOR_8723B_TEST_CHIP(_Adapter)	((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? false : true) : false)
+#define IS_VENDOR_8723B_MP_CHIP(_Adapter)		((IS_8723B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? true : false) : false)
+
+#define IS_VENDOR_8703B_TEST_CHIP(_Adapter)	((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? false : true) : false)
+#define IS_VENDOR_8703B_MP_CHIP(_Adapter)		((IS_8703B_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? true : false) : false)
+#define IS_VENDOR_8814A_TEST_CHIP(_Adapter)	((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? false : true) : false)
+#define IS_VENDOR_8814A_MP_CHIP(_Adapter)		((IS_8814A_SERIES(GET_HAL_DATA(_Adapter)->version_id)) ? ((IS_NORMAL_CHIP(GET_HAL_DATA(_Adapter)->version_id)) ? true : false) : false)
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/autoconf.h b/drivers/staging/rtl8188eu/include/autoconf.h
new file mode 100644
index 000000000000..75f1071f8416
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/autoconf.h
@@ -0,0 +1,340 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+/* ***** temporarily flag ******* */
+#define CONFIG_SINGLE_IMG
+
+/* #define CONFIG_DISABLE_ODM */
+/* for FPGA VERIFICATION config */
+#define RTL8188E_FPGAtrue_PHY_VERIFICATION 0
+
+/* ***** temporarily flag ******* */
+/*
+ * Public  General Config
+ */
+#define AUTOCONF_INCLUDED
+#define RTL871X_MODULE_NAME "88EU"
+#define DRV_NAME "rtl8188eu"
+
+#define PLATFORM_LINUX
+
+#define CONFIG_IOCTL_CFG80211
+
+#if defined(CONFIG_PLATFORM_ACTIONS_ATM702X)
+	#ifndef CONFIG_IOCTL_CFG80211
+		#define CONFIG_IOCTL_CFG80211
+	#endif
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+	/* #define RTW_USE_CFG80211_STA_EVENT */ /* Indecate new sta asoc through cfg80211_new_sta */
+	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
+	/* #define CONFIG_DEBUG_CFG80211 */
+	/* #define CONFIG_DRV_ISSUE_PROV_REQ */ /* IOT FOR S2 */
+	#define CONFIG_SET_SCAN_DENY_TIMER
+	/*#define SUPPLICANT_RTK_VERSION_LOWER_THAN_JB42*/ /* wpa_supplicant realtek version <= jb42 will be defined this */
+#endif
+
+/*
+ * Internal  General Config
+ */
+
+/* #define CONFIG_H2CLBK */
+
+#define CONFIG_EMBEDDED_FWIMG
+
+
+#ifdef CONFIG_EMBEDDED_FWIMG
+	#define	LOAD_FW_HEADER_FROM_DRIVER
+#endif
+/* #define CONFIG_FILE_FWIMG */
+
+#define CONFIG_XMIT_ACK
+#ifdef CONFIG_XMIT_ACK
+	#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#endif
+
+#define CONFIG_RECV_REORDERING_CTRL
+
+/* #define CONFIG_TCP_CSUM_OFFLOAD_RX */
+
+/* #define CONFIG_DRVEXT_MODULE */
+
+ #define CONFIG_SUPPORT_USB_INT
+ #ifdef CONFIG_SUPPORT_USB_INT
+/* #define CONFIG_USB_INTERRUPT_IN_PIPE */
+#endif
+
+/* #ifndef CONFIG_MP_INCLUDED */
+	#define CONFIG_IPS
+	#ifdef CONFIG_IPS
+	/* #define CONFIG_IPS_LEVEL_2 */	 /* enable this to set default IPS mode to IPS_LEVEL_2 */
+	#endif
+	#define SUPPORT_HW_RFOFF_DETECTED
+
+	#define CONFIG_LPS
+	#if defined(CONFIG_LPS) && defined(CONFIG_SUPPORT_USB_INT)
+
+
+	/* #define CONFIG_LPS_LCLK */
+	#endif
+
+	#ifdef CONFIG_LPS_LCLK
+	#define CONFIG_XMIT_THREAD_MODE
+	#endif
+
+	/*#define CONFIG_ANTENNA_DIVERSITY*/
+
+
+
+	/* #define CONFIG_CONCURRENT_MODE */
+	#ifdef CONFIG_CONCURRENT_MODE
+		#define CONFIG_RUNTIME_PORT_SWITCH
+
+		#define CONFIG_SCAN_BACKOP
+		#define CONFIG_TSF_RESET_OFFLOAD			/* For 2 PORT TSF SYNC. */
+	#endif
+
+	#define CONFIG_IOL
+/* #else */	/* #ifndef CONFIG_MP_INCLUDED */
+
+/* #endif */	/* #ifndef CONFIG_MP_INCLUDED */
+
+#define CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE
+
+	/* #define CONFIG_INTERRUPT_BASED_TXBCN */ /* Tx Beacon when driver BCN_OK ,BCN_ERR interrupt occurs */
+	#if defined(CONFIG_CONCURRENT_MODE) && defined(CONFIG_INTERRUPT_BASED_TXBCN)
+		#undef CONFIG_INTERRUPT_BASED_TXBCN
+	#endif
+	#ifdef CONFIG_INTERRUPT_BASED_TXBCN
+		/* #define CONFIG_INTERRUPT_BASED_TXBCN_EARLY_INT */
+		#define CONFIG_INTERRUPT_BASED_TXBCN_BCN_OK_ERR
+	#endif
+
+	#define CONFIG_NATIVEAP_MLME
+	#ifndef CONFIG_NATIVEAP_MLME
+		#define CONFIG_HOSTAPD_MLME
+	#endif
+	#define CONFIG_FIND_BEST_CHANNEL
+#endif
+
+#define CONFIG_P2P
+#ifdef CONFIG_P2P
+	/* The CONFIG_WFD is for supporting the Wi-Fi display */
+	#define CONFIG_WFD
+
+	#define CONFIG_P2P_REMOVE_GROUP_INFO
+
+	/* #define CONFIG_DBG_P2P */
+
+	#define CONFIG_P2P_PS
+	#define CONFIG_P2P_OP_CHK_SOCIAL_CH
+	#define CONFIG_CFG80211_ONECHANNEL_UNDER_CONCURRENT  /* replace CONFIG_P2P_CHK_INVITE_CH_LIST flag */
+	#define CONFIG_P2P_INVITE_IOT
+#endif
+
+/* Added by Kurt 20110511 */
+#ifdef CONFIG_TDLS
+	#define CONFIG_TDLS_DRIVER_SETUP
+/*	#ifndef CONFIG_WFD */
+/*		#define CONFIG_WFD */
+/*	#endif */
+/*	#define CONFIG_TDLS_AUTOSETUP */
+	#define CONFIG_TDLS_AUTOCHECKALIVE
+	/* #define CONFIG_TDLS_CH_SW */	/* Enable this flag only when we confirm that TDLS CH SW is supported in FW */
+#endif
+
+
+#define CONFIG_SKB_COPY	/* for amsdu */
+
+/* #define CONFIG_LED */
+#ifdef CONFIG_LED
+	#define CONFIG_SW_LED
+	#ifdef CONFIG_SW_LED
+		/* #define CONFIG_LED_HANDLED_BY_CMD_THREAD */
+	#endif
+#endif /* CONFIG_LED */
+
+#ifdef CONFIG_IOL
+	#define CONFIG_IOL_NEW_GENERATION
+	#define CONFIG_IOL_READ_EFUSE_MAP
+	/* #define DBG_IOL_READ_EFUSE_MAP */
+	/* #define CONFIG_IOL_LLT */
+	#define CONFIG_IOL_EFUSE_PATCH
+	/* #define CONFIG_IOL_IOREG_CFG */
+	/* #define CONFIG_IOL_IOREG_CFG_DBG */
+#endif
+
+
+#define CONFIG_GLOBAL_UI_PID
+
+#define CONFIG_LAYER2_ROAMING
+#define CONFIG_LAYER2_ROAMING_RESUME
+/* #define CONFIG_ADAPTOR_INFO_CACHING_FILE */ /* now just applied on 8192cu only, should make it general... */
+/* #define CONFIG_RESUME_IN_WORKQUEUE */
+/* #define CONFIG_SET_SCAN_DENY_TIMER */
+#define CONFIG_LONG_DELAY_ISSUE
+#define CONFIG_NEW_SIGNAL_STAT_PROCESS
+/* #define CONFIG_SIGNAL_DISPLAY_DBM */ /* display RX signal with dbm */
+#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+/* #define CONFIG_BACKGROUND_NOISE_MONITOR */
+#endif
+#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable, */
+
+#define CONFIG_TX_MCAST2UNI		/* Support IP multicast->unicast */
+/* #define CONFIG_CHECK_AC_LIFETIME */	/* Check packet lifetime of 4 ACs. */
+
+/*
+ * Interface  Related Config
+ */
+
+#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+	#define CONFIG_USB_TX_AGGREGATION
+	#define CONFIG_USB_RX_AGGREGATION
+#endif
+
+/* #define CONFIG_REDUCE_USB_TX_INT */		/* Trade-off: Improve performance, but may cause TX URBs blocked by USB Host/Bus driver on few platforms. */
+/* #define CONFIG_EASY_REPLACEMENT */
+
+/*
+ * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
+ */
+/* #define CONFIG_USE_USB_BUFFER_ALLOC_TX */	/* Trade-off: For TX path, improve stability on some platforms, but may cause performance degrade on other platforms. */
+/* #define CONFIG_USE_USB_BUFFER_ALLOC_RX */	/* For RX path */
+#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
+
+#else
+	#define CONFIG_PREALLOC_RECV_SKB
+	#ifdef CONFIG_PREALLOC_RECV_SKB
+		#define CONFIG_FIX_NR_BULKIN_BUFFER /* only use PREALLOC_RECV_SKB buffer, don't alloc skb at runtime */
+	#endif
+#endif
+
+/*
+ * USB VENDOR REQ BUFFER ALLOCATION METHOD
+ * if not set we'll use function local variable (stack memory)
+ */
+/* #define CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE */
+#define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+
+#define CONFIG_USB_VENDOR_REQ_MUTEX
+#define CONFIG_VENDOR_REQ_RETRY
+
+/* #define CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+
+/*
+ * HAL  Related Config
+ */
+
+#define RTL8188E_RX_PACKET_INCLUDE_CRC	0
+
+#define SUPPORTED_BLOCK_IO
+
+
+/* #define CONFIG_ONLY_ONE_OUT_EP_TO_LOW	0 */
+
+#define CONFIG_OUT_EP_WIFI_MODE	0
+
+#define ENABLE_USB_DROP_INCORRECT_OUT
+
+
+#define DISABLE_BB_RF	0
+
+/* #define RTL8191C_FPGA_NETWORKTYPE_ADHOC 0 */
+
+#ifdef CONFIG_MP_INCLUDED
+	#define MP_DRIVER 1
+	#define CONFIG_MP_IWPRIV_SUPPORT
+	/* #undef CONFIG_USB_TX_AGGREGATION */
+	/* #undef CONFIG_USB_RX_AGGREGATION */
+#else
+	#define MP_DRIVER 0
+#endif
+
+
+/*
+ * Platform  Related Config
+ */
+#ifdef CONFIG_PLATFORM_MN10300
+	#define CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	#define CONFIG_USE_USB_BUFFER_ALLOC_RX
+
+	#if	defined(CONFIG_POWER_SAVING)
+		#undef CONFIG_POWER_SAVING
+	#endif
+
+#endif/* CONFIG_PLATFORM_MN10300 */
+
+
+#if defined(CONFIG_PLATFORM_ACTIONS_ATM702X)
+	#ifdef CONFIG_USB_TX_AGGREGATION
+		#undef CONFIG_USB_TX_AGGREGATION
+	#endif
+	#ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
+		#define CONFIG_USE_USB_BUFFER_ALLOC_TX
+	#endif
+	#ifndef CONFIG_USE_USB_BUFFER_ALLOC_RX
+		#define CONFIG_USE_USB_BUFFER_ALLOC_RX
+	#endif
+#endif
+
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+/* #define	CONFIG_TX_EARLY_MODE */
+#endif
+
+#ifdef CONFIG_TX_EARLY_MODE
+#define	RTL8188E_EARLY_MODE_PKT_NUM_10	0
+#endif
+
+/*#define CONFIG_RF_POWER_TRIM */
+#define CONFIG_80211D
+
+#ifdef CONFIG_GPIO_WAKEUP
+	#ifndef WAKEUP_GPIO_IDX
+		#define WAKEUP_GPIO_IDX 7
+	#endif
+#endif
+
+#define CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
+
+/*
+ * Debug Related Config
+ */
+#define DBG	1
+
+#define CONFIG_PROC_DEBUG
+
+#define DBG_CONFIG_ERROR_DETECT
+/* #define DBG_CONFIG_ERROR_DETECT_INT */
+#define DBG_CONFIG_ERROR_RESET
+
+/* #define DBG_IO */
+/* #define DBG_DELAY_OS */
+/* #define DBG_MEM_ALLOC */
+/* #define DBG_IOCTL */
+
+/* #define DBG_TX */
+/* #define DBG_XMIT_BUF */
+/* #define DBG_XMIT_BUF_EXT */
+/* #define DBG_TX_DROP_FRAME */
+
+/* #define DBG_RX_DROP_FRAME */
+/* #define DBG_RX_SEQ */
+/* #define DBG_RX_SIGNAL_DISPLAY_PROCESSING */
+/* #define DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED "jeff-ap" */
+
+
+
+/* #define DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE */
+/* #define DBG_ROAMING_TEST */
+
+/* #define DBG_HAL_INIT_PROFILING */
+
+/* TX use 1 urb */
+/* #define CONFIG_SINGLE_XMIT_BUF */
+/* RX use 1 urb */
+/* #define CONFIG_SINGLE_RECV_BUF */
+#define	DBG_RX_DFRAME_RAW_DATA
diff --git a/drivers/staging/rtl8188eu/include/basic_types.h b/drivers/staging/rtl8188eu/include/basic_types.h
new file mode 100644
index 000000000000..80260620f7b1
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/basic_types.h
@@ -0,0 +1,255 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+	#include <linux/version.h>
+	#include <linux/types.h>
+	#include <linux/module.h>
+	#include <linux/kernel.h>
+	#include <linux/init.h>
+	#include <linux/utsname.h>
+	#define NDIS_OID uint
+	#define NDIS_STATUS uint
+
+	typedef	signed int sint;
+
+	#define u8 u8
+	#define u16 u16
+	#define u32 u32
+	#define u32 u32
+
+	typedef void (*proc_t)(void *);
+
+	typedef	__kernel_size_t	SIZE_T;
+	typedef	__kernel_ssize_t	SSIZE_T;
+	#define FIELD_OFFSET(s, field)	((SSIZE_T)&((s *)(0))->field)
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#define SIZE_PTR SIZE_T
+#define SSIZE_PTR SSIZE_T
+
+/*
+* Continuous bits starting from least significant bit
+* Example:
+* BIT_LEN_MASK_32(0) => 0x00000000
+* BIT_LEN_MASK_32(1) => 0x00000001
+* BIT_LEN_MASK_32(2) => 0x00000003
+* BIT_LEN_MASK_32(32) => 0xFFFFFFFF
+*/
+#define BIT_LEN_MASK_32(__BitLen) ((u32)(0xFFFFFFFF >> (32 - (__BitLen))))
+#define BIT_LEN_MASK_16(__BitLen) ((u16)(0xFFFF >> (16 - (__BitLen))))
+#define BIT_LEN_MASK_8(__BitLen) ((u8)(0xFF >> (8 - (__BitLen))))
+
+/*
+* Continuous bits starting from least significant bit
+* Example:
+* BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
+* BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
+*/
+#define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) ((u32)(BIT_LEN_MASK_32(__BitLen) << (__BitOffset)))
+#define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) ((u16)(BIT_LEN_MASK_16(__BitLen) << (__BitOffset)))
+#define BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) ((u8)(BIT_LEN_MASK_8(__BitLen) << (__BitOffset)))
+
+/*
+* Convert LE data to host byte order
+*/
+#define EF1Byte (u8)
+#define EF2Byte le16_to_cpu
+#define EF4Byte le32_to_cpu
+
+/*
+* Read LE data from memory to host byte order
+*/
+#define ReadLE4Byte(_ptr)	le32_to_cpu(*((__le32 *)(_ptr)))
+#define ReadLE2Byte(_ptr)	le16_to_cpu(*((__le16 *)(_ptr)))
+#define ReadLE1Byte(_ptr)	(*((u8 *)(_ptr)))
+
+/*
+* Read BE data from memory to host byte order
+*/
+#define ReadBEE4Byte(_ptr)	be32_to_cpu(*((__be32 *)(_ptr)))
+#define ReadBE2Byte(_ptr)	be16_to_cpu(*((__be16 *)(_ptr)))
+#define ReadBE1Byte(_ptr)	(*((u8 *)(_ptr)))
+
+/*
+* Write host byte order data to memory in LE order
+*/
+#define WriteLE4Byte(_ptr, _val)	((*((__le32 *)(_ptr))) = cpu_to_le32(_val))
+#define WriteLE2Byte(_ptr, _val)	((*((__le16 *)(_ptr))) = cpu_to_le16(_val))
+#define WriteLE1Byte(_ptr, _val)	((*((u8 *)(_ptr))) = ((u8)(_val)))
+
+/*
+* Write host byte order data to memory in BE order
+*/
+#define WriteBE4Byte(_ptr, _val)	((*((__be32 *)(_ptr))) = cpu_to_be32(_val))
+#define WriteBE2Byte(_ptr, _val)	((*((__be16 *)(_ptr))) = cpu_to_be16(_val))
+#define WriteBE1Byte(_ptr, _val)	((*((u8 *)(_ptr))) = ((u8)(_val)))
+
+/*
+* Return 4-byte value in host byte ordering from 4-byte pointer in litten-endian system.
+*/
+#define LE_P4BYTE_TO_HOST_4BYTE(__pStart) (le32_to_cpu(*((__le32 *)(__pStart))))
+#define LE_P2BYTE_TO_HOST_2BYTE(__pStart) (le16_to_cpu(*((__le16 *)(__pStart))))
+#define LE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))
+
+/*
+* Return 4-byte value in host byte ordering from 4-byte pointer in big-endian system.
+*/
+#define BE_P4BYTE_TO_HOST_4BYTE(__pStart) (be32_to_cpu(*((__be32 *)(__pStart))))
+#define BE_P2BYTE_TO_HOST_2BYTE(__pStart) (be16_to_cpu(*((__be16 *)(__pStart))))
+#define BE_P1BYTE_TO_HOST_1BYTE(__pStart) ((*((u8 *)(__pStart))))
+
+/*
+* Translate subfield (continuous bits in little-endian) of 4-byte value in LE byte to
+* 4-byte value in host byte ordering.
+*/
+#define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))
+
+#define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))
+
+#define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	((LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))
+
+/*
+* Translate subfield (continuous bits in big-endian) of 4-byte value in BE byte to
+* 4-byte value in host byte ordering.
+*/
+#define BE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_32(__BitLen))
+
+#define BE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_16(__BitLen))
+
+#define BE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	((BE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) & BIT_LEN_MASK_8(__BitLen))
+
+/*
+* Mask subfield (continuous bits in little-endian) of 4-byte value in LE byte oredering
+* and return the result in 4-byte value in host byte ordering.
+*/
+#define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))
+
+#define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))
+
+#define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	(LE_P1BYTE_TO_HOST_1BYTE(__pStart) & ((u8)(~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen))))
+
+/*
+* Mask subfield (continuous bits in big-endian) of 4-byte value in BE byte oredering
+* and return the result in 4-byte value in host byte ordering.
+*/
+#define BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P4BYTE_TO_HOST_4BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)))
+
+#define BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P2BYTE_TO_HOST_2BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)))
+
+#define BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+	(BE_P1BYTE_TO_HOST_1BYTE(__pStart) & (~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)))
+
+/*
+* Set subfield of little-endian 4-byte value to specified value.
+*/
+#define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 32) \
+			WriteLE4Byte(__pStart, __Value); \
+		else { \
+			WriteLE4Byte(__pStart, \
+				LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 16) \
+			WriteLE2Byte(__pStart, __Value); \
+		else { \
+			WriteLE2Byte(__pStart, \
+				LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 8) \
+			WriteLE1Byte(__pStart, __Value); \
+		else { \
+			WriteLE1Byte(__pStart, \
+				LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+/*
+* Set subfield of big-endian 4-byte value to specified value.
+*/
+#define SET_BITS_TO_BE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 32) \
+			WriteBE4Byte(__pStart, __Value); \
+		else { \
+			WriteBE4Byte(__pStart, \
+				BE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_BE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 16) \
+			WriteBE2Byte(__pStart, __Value); \
+		else { \
+			WriteBE2Byte(__pStart, \
+				BE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+#define SET_BITS_TO_BE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
+	do { \
+		if (__BitOffset == 0 && __BitLen == 8) \
+			WriteBE1Byte(__pStart, __Value); \
+		else { \
+			WriteBE1Byte(__pStart, \
+				BE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
+				| \
+				((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
+			); \
+		} \
+	} while (0)
+
+/* Get the N-bytes aligment offset from the current length */
+#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
+
+#define TEST_FLAG(__Flag, __testFlag)		(((__Flag) & (__testFlag)) != 0)
+#define SET_FLAG(__Flag, __setFlag)			((__Flag) |= __setFlag)
+#define CLEAR_FLAG(__Flag, __clearFlag)		((__Flag) &= ~(__clearFlag))
+#define CLEAR_FLAGS(__Flag)					((__Flag) = 0)
+#define TEST_FLAGS(__Flag, __testFlags)		(((__Flag) & (__testFlags)) == (__testFlags))
+
+#endif /* __BASIC_TYPES_H__ */
diff --git a/drivers/staging/rtl8188eu/include/circ_buf.h b/drivers/staging/rtl8188eu/include/circ_buf.h
new file mode 100644
index 000000000000..7831cd1bfbc3
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/circ_buf.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __CIRC_BUF_H_
+#define __CIRC_BUF_H_ 1
+
+#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))
+
+#define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))
+
+#endif //_CIRC_BUF_H_
+
diff --git a/drivers/staging/rtl8188eu/include/cmd_osdep.h b/drivers/staging/rtl8188eu/include/cmd_osdep.h
new file mode 100644
index 000000000000..9d491acd60a2
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/cmd_osdep.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __CMD_OSDEP_H_
+#define __CMD_OSDEP_H_
+
+
+extern sint _rtw_init_cmd_priv(struct	cmd_priv *pcmdpriv);
+extern sint _rtw_init_evt_priv(struct evt_priv *pevtpriv);
+extern void _rtw_free_evt_priv(struct	evt_priv *pevtpriv);
+extern void _rtw_free_cmd_priv(struct	cmd_priv *pcmdpriv);
+extern sint _rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj, bool to_head);
+extern struct cmd_obj *_rtw_dequeue_cmd(_queue *queue);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/custom_gpio.h b/drivers/staging/rtl8188eu/include/custom_gpio.h
new file mode 100644
index 000000000000..bc8002f2af0e
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/custom_gpio.h
@@ -0,0 +1,22 @@
+#ifndef __CUSTOM_GPIO_H__
+#define __CUSTOM_GPIO_H___
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#include <drv_types_linux.h>
+
+typedef enum cust_gpio_modes {
+	WLAN_PWDN_ON,
+	WLAN_PWDN_OFF,
+	WLAN_POWER_ON,
+	WLAN_POWER_OFF,
+	WLAN_BT_PWDN_ON,
+	WLAN_BT_PWDN_OFF
+} cust_gpio_modes_t;
+
+extern int rtw_wifi_gpio_init(void);
+extern int rtw_wifi_gpio_deinit(void);
+extern void rtw_wifi_gpio_wlan_ctrl(int onoff);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/drv_conf.h b/drivers/staging/rtl8188eu/include/drv_conf.h
new file mode 100644
index 000000000000..e7f8364d2a1b
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/drv_conf.h
@@ -0,0 +1,270 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+#include "hal_ic_cfg.h"
+
+#if defined(CONFIG_MCC_MODE) && (!defined(CONFIG_CONCURRENT_MODE))
+
+	#error "Enable CONCURRENT_MODE before enable MCC MODE\n"
+
+#endif
+
+#if defined(CONFIG_MCC_MODE) && defined(CONFIG_BT_COEXIST)
+
+	#error "Disable BT COEXIST before enable MCC MODE\n"
+
+#endif
+
+#if defined(CONFIG_MCC_MODE) && defined(CONFIG_TDLS)
+
+	#error "Disable TDLS before enable MCC MODE\n"
+
+#endif
+
+#if defined(CONFIG_RTW_80211R) && !defined(CONFIG_LAYER2_ROAMING)
+
+	#error "Enable CONFIG_LAYER2_ROAMING before enable CONFIG_RTW_80211R\n"
+
+#endif
+
+/* Older Android kernel doesn't has CONFIG_ANDROID defined,
+ * add this to force CONFIG_ANDROID defined */
+#ifdef CONFIG_PLATFORM_ANDROID
+	#ifndef CONFIG_ANDROID
+		#define CONFIG_ANDROID
+	#endif
+#endif
+
+#ifdef CONFIG_ANDROID
+	/* Some Android build will restart the UI while non-printable ascii is passed
+	* between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID
+	* for Android here. If you are sure there is no risk on your system about this,
+	* mask this macro define to support non-printable ascii ssid.
+	* #define CONFIG_VALIDATE_SSID */
+
+	/* Android expect dbm as the rx signal strength unit */
+	#define CONFIG_SIGNAL_DISPLAY_DBM
+#endif
+
+/*
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+
+#if defined(CONFIG_ANDROID_POWER) && defined(CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_ANDROID_POWER enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+*/
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE /* this can be removed, because there is no case for this... */
+	#if !defined(CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
+		#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
+		#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
+	#endif
+#endif
+
+/* About USB VENDOR REQ */
+#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+
+#if !defined(CONFIG_AP_MODE) && defined(CONFIG_DFS_MASTER)
+	#warning "undef CONFIG_DFS_MASTER because CONFIG_AP_MODE is not defined"
+	#undef CONFIG_DFS_MASTER
+#endif
+
+#define RTW_SCAN_SPARSE_MIRACAST 1
+#define RTW_SCAN_SPARSE_BG 0
+#define RTW_SCAN_SPARSE_ROAMING_ACTIVE 1
+
+#ifndef CONFIG_RTW_HIQ_FILTER
+	#define CONFIG_RTW_HIQ_FILTER 1
+#endif
+
+#ifndef CONFIG_RTW_FORCE_IGI_LB
+	#define CONFIG_RTW_FORCE_IGI_LB 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_EN
+	#define CONFIG_RTW_ADAPTIVITY_EN 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_MODE
+	#define CONFIG_RTW_ADAPTIVITY_MODE 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DML
+	#define CONFIG_RTW_ADAPTIVITY_DML 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_DC_BACKOFF
+	#define CONFIG_RTW_ADAPTIVITY_DC_BACKOFF 2
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_TH_L2H_INI
+	#define CONFIG_RTW_ADAPTIVITY_TH_L2H_INI 0
+#endif
+
+#ifndef CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF
+	#define CONFIG_RTW_ADAPTIVITY_TH_EDCCA_HL_DIFF 0
+#endif
+
+#ifndef CONFIG_RTW_EXCL_CHS
+	#define CONFIG_RTW_EXCL_CHS {0}
+#endif
+
+#ifndef CONFIG_RTW_DFS_REGION_DOMAIN
+	#define CONFIG_RTW_DFS_REGION_DOMAIN 0
+#endif
+
+#ifndef CONFIG_TXPWR_BY_RATE_EN
+#define CONFIG_TXPWR_BY_RATE_EN 2 /* by efuse */
+#endif
+#ifndef CONFIG_TXPWR_LIMIT_EN
+#define CONFIG_TXPWR_LIMIT_EN 2 /* by efuse */
+#endif
+
+/* compatible with old fashion configuration */
+#if defined(CONFIG_CALIBRATE_TX_POWER_BY_REGULATORY)
+	#undef CONFIG_TXPWR_BY_RATE_EN
+	#undef CONFIG_TXPWR_LIMIT_EN
+	#define CONFIG_TXPWR_BY_RATE_EN 1
+	#define CONFIG_TXPWR_LIMIT_EN 1
+#elif defined(CONFIG_CALIBRATE_TX_POWER_TO_MAX)
+	#undef CONFIG_TXPWR_BY_RATE_EN
+	#undef CONFIG_TXPWR_LIMIT_EN
+	#define CONFIG_TXPWR_BY_RATE_EN 1
+	#define CONFIG_TXPWR_LIMIT_EN 0
+#endif
+
+#ifndef RTW_DEF_MODULE_REGULATORY_CERT
+	#define RTW_DEF_MODULE_REGULATORY_CERT 0
+#endif
+
+#if RTW_DEF_MODULE_REGULATORY_CERT
+	/* force enable TX power by rate and TX power limit */
+	#undef CONFIG_TXPWR_BY_RATE_EN
+	#undef CONFIG_TXPWR_LIMIT_EN
+	#define CONFIG_TXPWR_BY_RATE_EN 1
+	#define CONFIG_TXPWR_LIMIT_EN 1
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_A
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_B
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_C
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_2G_D
+	#define CONFIG_RTW_TARGET_TX_PWR_2G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_A
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_A {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_B
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_B {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_C
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_C {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_TARGET_TX_PWR_5G_D
+	#define CONFIG_RTW_TARGET_TX_PWR_5G_D {-1, -1, -1, -1, -1, -1, -1, -1, -1}
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_2G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_2G 0
+#endif
+
+#ifndef CONFIG_RTW_AMPLIFIER_TYPE_5G
+	#define CONFIG_RTW_AMPLIFIER_TYPE_5G 0
+#endif
+
+#ifndef CONFIG_RTW_RFE_TYPE
+	#define CONFIG_RTW_RFE_TYPE 64
+#endif
+
+#ifndef CONFIG_RTW_GLNA_TYPE
+	#define CONFIG_RTW_GLNA_TYPE 0
+#endif
+
+#ifndef CONFIG_RTW_PLL_REF_CLK_SEL
+	#define CONFIG_RTW_PLL_REF_CLK_SEL 0x0F
+#endif
+
+#ifndef CONFIG_IFACE_NUMBER
+	#ifdef CONFIG_CONCURRENT_MODE
+		#define CONFIG_IFACE_NUMBER	2
+	#else
+		#define CONFIG_IFACE_NUMBER	1
+	#endif
+#endif
+
+#ifndef CONFIG_CONCURRENT_MODE
+	#if (CONFIG_IFACE_NUMBER > 1)
+		#error "CONFIG_IFACE_NUMBER over 1,but CONFIG_CONCURRENT_MODE not defined"
+	#endif
+#endif
+
+#if (CONFIG_IFACE_NUMBER == 0)
+	#error "CONFIG_IFACE_NUMBER cound not equel to 0 !!"
+#endif
+
+#if (CONFIG_IFACE_NUMBER > 3)
+	#error "Not support over 3 interfaces yet !!"
+#endif
+
+#if (CONFIG_IFACE_NUMBER > 8)	/*IFACE_ID_MAX*/
+	#error "HW count not support over 8 interfaces !!"
+#endif
+
+#if (CONFIG_IFACE_NUMBER > 2)
+	#define CONFIG_MI_WITH_MBSSID_CAM
+
+	#ifdef CONFIG_MI_WITH_MBSSID_CAM
+		#define CONFIG_MBSSID_CAM
+		#if defined(CONFIG_RUNTIME_PORT_SWITCH)
+			#undef CONFIG_RUNTIME_PORT_SWITCH
+		#endif
+	#endif
+
+	#ifdef CONFIG_AP_MODE
+		#define CONFIG_SWTIMER_BASED_TXBCN
+		/*#define CONFIG_FW_BASED_BCN*/
+	#endif
+#endif
+
+#define MACID_NUM_SW_LIMIT 32
+#define SEC_CAM_ENT_NUM_SW_LIMIT 32
+
+/*Don't release SDIO irq in suspend/resume procedure*/
+#define CONFIG_RTW_SDIO_KEEP_IRQ	0
+
+/*
+ * Add by Lucas@2016/02/15
+ * For RX Aggregation
+ */
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_USB_RX_AGGREGATION)
+	#define RTW_RX_AGGREGATION
+#endif /* CONFIG_SDIO_HCI || CONFIG_USB_RX_AGGREGATION */
+
+#endif /* __DRV_CONF_H__ */
diff --git a/drivers/staging/rtl8188eu/include/drv_types.h b/drivers/staging/rtl8188eu/include/drv_types.h
new file mode 100644
index 000000000000..c06b344f15a4
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/drv_types.h
@@ -0,0 +1,1395 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+/*-------------------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+#include <ieee80211.h>
+#ifdef CONFIG_ARP_KEEP_ALIVE
+	#include <net/neighbour.h>
+	#include <net/arp.h>
+#endif
+
+#include <drv_types_linux.h>
+
+enum _NIC_VERSION {
+
+	RTL8711_NIC,
+	RTL8712_NIC,
+	RTL8713_NIC,
+	RTL8716_NIC
+
+};
+
+typedef struct _ADAPTER _adapter, ADAPTER, *PADAPTER;
+
+#include <rtw_debug.h>
+#include <rtw_rf.h>
+
+	#include <rtw_ht.h>
+
+#ifdef CONFIG_INTEL_WIDI
+	#include <rtw_intel_widi.h>
+#endif
+
+#include <rtw_cmd.h>
+#include <cmd_osdep.h>
+#include <rtw_security.h>
+#include <rtw_xmit.h>
+#include <xmit_osdep.h>
+#include <rtw_recv.h>
+
+#ifdef CONFIG_BEAMFORMING
+	#include <rtw_beamforming.h>
+#endif
+
+#include <recv_osdep.h>
+#include <rtw_efuse.h>
+#include <rtw_sreset.h>
+#include <hal_intf.h>
+#include <hal_com.h>
+#include<hal_com_h2c.h>
+#include <hal_com_led.h>
+#include "../hal/hal_dm.h"
+#include <rtw_qos.h>
+#include <rtw_pwrctrl.h>
+#include <rtw_mlme.h>
+#include <mlme_osdep.h>
+#include <rtw_io.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <rtw_ioctl_query.h>
+#include <rtw_ioctl_rtl.h>
+#include <osdep_intf.h>
+#include <rtw_eeprom.h>
+#include <sta_info.h>
+#include <rtw_event.h>
+#include <rtw_mlme_ext.h>
+#include <rtw_mi.h>
+#include <rtw_ap.h>
+#include <rtw_efuse.h>
+#include <rtw_version.h>
+#include <rtw_odm.h>
+
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+	#include <rtw_mem.h>
+#endif
+
+#include <rtw_p2p.h>
+
+#ifdef CONFIG_TDLS
+	#include <rtw_tdls.h>
+#endif /* CONFIG_TDLS */
+
+#ifdef CONFIG_WAPI_SUPPORT
+	#include <rtw_wapi.h>
+#endif /* CONFIG_WAPI_SUPPORT */
+
+#ifdef CONFIG_DRVEXT_MODULE
+	#include <drvext_api.h>
+#endif /* CONFIG_DRVEXT_MODULE */
+
+#ifdef CONFIG_MP_INCLUDED
+	#include <rtw_mp.h>
+#endif /* CONFIG_MP_INCLUDED */
+
+#ifdef CONFIG_BR_EXT
+	#include <rtw_br_ext.h>
+#endif /* CONFIG_BR_EXT */
+
+#ifdef CONFIG_IOL
+	#include <rtw_iol.h>
+#endif /* CONFIG_IOL */
+
+#include <ip.h>
+#include <if_ether.h>
+#include <ethernet.h>
+#include <circ_buf.h>
+
+#include <rtw_android.h>
+
+#include <rtw_btcoex_wifionly.h>
+#ifdef CONFIG_BT_COEXIST
+	#include <rtw_btcoex.h>
+#endif /* CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_MCC_MODE
+	#include <rtw_mcc.h>
+#endif /*CONFIG_MCC_MODE */
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+#define SPEC_DEV_ID_ASSIGN_IFNAME BIT(5)
+
+struct specific_device_id {
+
+	u32		flags;
+
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv {
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	NDIS_802_11_SSID	ssid;
+	u8	network_mode;	/* infra, ad-hoc, auto */
+	u8	channel;/* ad-hoc support requirement */
+	u8	wireless_mode;/* A, B, G, auto */
+	u8	scan_mode;/* active, passive */
+	u8	radio_enable;
+	u8	preamble;/* long, short, auto */
+	u8	vrtl_carrier_sense;/* Enable, Disable, Auto */
+	u8	vcs_type;/* RTS/CTS, CTS-to-self */
+	u16	rts_thresh;
+	u16  frag_thresh;
+	u8	adhoc_tx_pwr;
+	u8	soft_ap;
+	u8	power_mgnt;
+	u8	ips_mode;
+	u8	smart_ps;
+	u8   usb_rxagg_mode;
+	u8	long_retry_lmt;
+	u8	short_retry_lmt;
+	u16	busy_thresh;
+	u8	ack_policy;
+	u8	mp_mode;
+#if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_RTW_CUSTOMER_STR)
+	u8 mp_customer_str;
+#endif
+	u8  mp_dm;
+	u8	software_encrypt;
+	u8	software_decrypt;
+#ifdef CONFIG_TX_EARLY_MODE
+	u8   early_mode;
+#endif
+	u8	acm_method;
+	/* UAPSD */
+	u8	wmm_enable;
+	u8	uapsd_enable;
+	u8	uapsd_max_sp;
+	u8	uapsd_acbk_en;
+	u8	uapsd_acbe_en;
+	u8	uapsd_acvi_en;
+	u8	uapsd_acvo_en;
+	WLAN_BSSID_EX    dev_network;
+	u8	tx_bw_mode;
+	u8	led_enable;
+	u8	ht_enable;
+	/* 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz */
+	/* 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7 */
+	/* 0x21 means enable 2.4G 40MHz & 5G 80MHz */
+	u8	bw_mode;
+	u8	ampdu_enable;/* for tx */
+	u8	rx_stbc;
+	u8	ampdu_amsdu;/* A-MPDU Supports A-MSDU is permitted */
+	/* Short GI support Bit Map */
+	/* BIT0 - 20MHz, 1: support, 0: non-support */
+	/* BIT1 - 40MHz, 1: support, 0: non-support */
+	/* BIT2 - 80MHz, 1: support, 0: non-support */
+	/* BIT3 - 160MHz, 1: support, 0: non-support */
+	u8	short_gi;
+	/* BIT0: Enable VHT LDPC Rx, BIT1: Enable VHT LDPC Tx, BIT4: Enable HT LDPC Rx, BIT5: Enable HT LDPC Tx */
+	u8	ldpc_cap;
+	/* BIT0: Enable VHT STBC Rx, BIT1: Enable VHT STBC Tx, BIT4: Enable HT STBC Rx, BIT5: Enable HT STBC Tx */
+	u8	stbc_cap;
+	/*
+	 * BIT0: Enable VHT SU Beamformer
+	 * BIT1: Enable VHT SU Beamformee
+	 * BIT2: Enable VHT MU Beamformer, depend on VHT SU Beamformer
+	 * BIT3: Enable VHT MU Beamformee, depend on VHT SU Beamformee
+	 * BIT4: Enable HT Beamformer
+	 * BIT5: Enable HT Beamformee
+	 */
+	u8	beamform_cap;
+	u8	beamformer_rf_num;
+	u8	beamformee_rf_num;
+
+	u8	lowrate_two_xmit;
+
+	u8	rf_config ;
+	u8	low_power ;
+
+	u8	wifi_spec;/* !turbo_mode */
+	u8	special_rf_path; /* 0: 2T2R ,1: only turn on path A 1T1R */
+	char alpha2[2];
+	u8	channel_plan;
+	u8	excl_chs[MAX_CHANNEL_NUM];
+	u8	full_ch_in_p2p_handshake; /* 0: reply only softap channel, 1: reply full channel list*/
+
+#ifdef CONFIG_BT_COEXIST
+	u8	btcoex;
+	u8	bt_iso;
+	u8	bt_sco;
+	u8	bt_ampdu;
+	u8	ant_num;
+#endif
+	bool	bAcceptAddbaReq;
+
+	u8	antdiv_cfg;
+	u8	antdiv_type;
+	u8	drv_ant_band_switch;
+
+	u8	switch_usb_mode;
+
+	u8	usbss_enable;/* 0:disable,1:enable */
+	u8	hwpdn_mode;/* 0:disable,1:enable,2:decide by EFUSE config */
+	u8	hwpwrp_detect;/* 0:disable,1:enable */
+
+	u8	hw_wps_pbc;/* 0:disable,1:enable */
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+	char	adaptor_info_caching_file_path[PATH_LENGTH_MAX];
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+	u8	max_roaming_times; /* the max number driver will try to roaming */
+#endif
+
+#ifdef CONFIG_IOL
+	u8 fw_iol; /* enable iol without other concern */
+#endif
+
+#ifdef CONFIG_80211D
+	u8 enable80211d;
+#endif
+
+	u8 ifname[16];
+	u8 if2name[16];
+
+	u8 notch_filter;
+
+#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
+	u8 force_ant;/* 0 normal,1 main,2 aux */
+	u8 force_igi;/* 0 normal */
+#endif
+
+	u8 force_igi_lb;
+
+	/* for pll reference clock selction */
+	u8 pll_ref_clk_sel;
+
+	/* define for tx power adjust */
+	u8	RegEnableTxPowerLimit;
+	u8	RegEnableTxPowerByRate;
+	u8	RegPowerBase;
+	u8	RegPwrTblSel;
+
+	u8 target_tx_pwr_valid;
+	s8 target_tx_pwr_2g[RF_PATH_MAX][RATE_SECTION_NUM];
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	s8 target_tx_pwr_5g[RF_PATH_MAX][RATE_SECTION_NUM - 1];
+#endif
+
+	s8	TxBBSwing_2G;
+	s8	TxBBSwing_5G;
+	u8	AmplifierType_2G;
+	u8	AmplifierType_5G;
+	u8	bEn_RFE;
+	u8	RFE_Type;
+	u8	PowerTracking_Type;
+	u8	GLNA_Type;
+	u8  check_fw_ps;
+	u8	RegPwrTrimEnable;
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	u8	load_phy_file;
+	u8	RegDecryptCustomFile;
+#endif
+#ifdef CONFIG_CONCURRENT_MODE
+	u8 virtual_iface_num;
+#endif
+	u8 qos_opt_enable;
+
+	u8 hiq_filter;
+	u8 adaptivity_en;
+	u8 adaptivity_mode;
+	u8 adaptivity_dml;
+	u8 adaptivity_dc_backoff;
+	s8 adaptivity_th_l2h_ini;
+	s8 adaptivity_th_edcca_hl_diff;
+
+	u8 boffefusemask;
+	bool bFileMaskEfuse;
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	u8 acs_mode;
+	u8 acs_auto_scan;
+#endif
+	u32	reg_rxgain_offset_2g;
+	u32	reg_rxgain_offset_5gl;
+	u32	reg_rxgain_offset_5gm;
+	u32	reg_rxgain_offset_5gh;
+
+#ifdef CONFIG_DFS_MASTER
+	u8 dfs_region_domain;
+#endif
+
+#ifdef CONFIG_MCC_MODE
+	u8 en_mcc;
+	u32 rtw_mcc_single_tx_cri;
+	u32 rtw_mcc_ap_bw20_target_tx_tp;
+	u32 rtw_mcc_ap_bw40_target_tx_tp;
+	u32 rtw_mcc_ap_bw80_target_tx_tp;
+	u32 rtw_mcc_sta_bw20_target_tx_tp;
+	u32 rtw_mcc_sta_bw40_target_tx_tp;
+	u32 rtw_mcc_sta_bw80_target_tx_tp;
+	s8 rtw_mcc_policy_table_idx;
+	u8 rtw_mcc_duration;
+	u8 rtw_mcc_tsf_sync_offset;
+	u8 rtw_mcc_start_time_offset;
+	u8 rtw_mcc_interval;
+	s8 rtw_mcc_guard_offset0;
+	s8 rtw_mcc_guard_offset1;
+#endif /* CONFIG_MCC_MODE */
+
+#ifdef CONFIG_RTW_NAPI
+	u8 en_napi;
+#ifdef CONFIG_RTW_GRO
+	u8 en_gro;
+#endif /* CONFIG_RTW_GRO */
+#endif /* CONFIG_RTW_NAPI */
+
+	bool	default_patterns_en;
+#ifdef CONFIG_SUPPORT_TRX_SHARED
+	u8 trx_share_mode;
+#endif
+	u8 check_hw_status;
+};
+
+/* For registry parameters */
+#define RGTRY_OFT(field) ((u32)FIELD_OFFSET(struct registry_priv, field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv *) 0)->field)
+
+#define GetRegAmplifierType2G(_Adapter)	(_Adapter->registrypriv.AmplifierType_2G)
+#define GetRegAmplifierType5G(_Adapter)	(_Adapter->registrypriv.AmplifierType_5G)
+
+#define GetRegTxBBSwing_2G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_2G)
+#define GetRegTxBBSwing_5G(_Adapter)	(_Adapter->registrypriv.TxBBSwing_5G)
+
+#define GetRegbENRFEType(_Adapter)	(_Adapter->registrypriv.bEn_RFE)
+#define GetRegRFEType(_Adapter)	(_Adapter->registrypriv.RFE_Type)
+#define GetRegGLNAType(_Adapter)	(_Adapter->registrypriv.GLNA_Type)
+#define GetRegPowerTrackingType(_Adapter)	(_Adapter->registrypriv.PowerTracking_Type)
+
+#define BSSID_OFT(field) ((u32)FIELD_OFFSET(WLAN_BSSID_EX, field))
+#define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)
+
+#define BW_MODE_2G(bw_mode) ((bw_mode) & 0x0F)
+#define BW_MODE_5G(bw_mode) ((bw_mode) >> 4)
+#define REGSTY_BW_2G(regsty) BW_MODE_2G((regsty)->bw_mode)
+#define REGSTY_BW_5G(regsty) BW_MODE_5G((regsty)->bw_mode)
+#define REGSTY_IS_BW_2G_SUPPORT(regsty, bw) (REGSTY_BW_2G((regsty)) >= (bw))
+#define REGSTY_IS_BW_5G_SUPPORT(regsty, bw) (REGSTY_BW_5G((regsty)) >= (bw))
+
+#define REGSTY_IS_11AC_ENABLE(regsty) ((regsty)->vht_enable != 0)
+#define REGSTY_IS_11AC_AUTO(regsty) ((regsty)->vht_enable == 2)
+
+typedef struct rtw_if_operations {
+	int __must_check(*read)(struct dvobj_priv *d, int addr, void *buf,
+				size_t len, bool fixed);
+	int __must_check(*write)(struct dvobj_priv *d, int addr, void *buf,
+				 size_t len, bool fixed);
+} RTW_IF_OPS, *PRTW_IF_OPS;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	#define is_primary_adapter(adapter) (adapter->adapter_type == PRIMARY_ADAPTER)
+	#define is_vir_adapter(adapter) (adapter->adapter_type == VIRTUAL_ADAPTER)
+	#define get_hw_port(adapter) (adapter->hw_port)
+#else
+	#define is_primary_adapter(adapter) (1)
+	#define is_vir_adapter(adapter) (0)
+	#define get_hw_port(adapter) (HW_PORT0)
+#endif
+#define GET_PRIMARY_ADAPTER(padapter) (((_adapter *)padapter)->dvobj->padapters[IFACE_ID0])
+#define GET_IFACE_NUMS(padapter) (((_adapter *)padapter)->dvobj->iface_nums)
+#define GET_ADAPTER(padapter, iface_id) (((_adapter *)padapter)->dvobj->padapters[iface_id])
+
+#define GetDefaultAdapter(padapter)	padapter
+
+enum _IFACE_ID {
+	IFACE_ID0, /*PRIMARY_ADAPTER*/
+	IFACE_ID1,
+	IFACE_ID2,
+	IFACE_ID3,
+	IFACE_ID4,
+	IFACE_ID5,
+	IFACE_ID6,
+	IFACE_ID7,
+	IFACE_ID_MAX,
+};
+
+#define VIF_START_ID	1
+
+#ifdef CONFIG_DBG_COUNTER
+
+struct rx_logs {
+	u32 intf_rx;
+	u32 intf_rx_err_recvframe;
+	u32 intf_rx_err_skb;
+	u32 intf_rx_report;
+	u32 core_rx;
+	u32 core_rx_pre;
+	u32 core_rx_pre_ver_err;
+	u32 core_rx_pre_mgmt;
+	u32 core_rx_pre_mgmt_err_80211w;
+	u32 core_rx_pre_mgmt_err;
+	u32 core_rx_pre_ctrl;
+	u32 core_rx_pre_ctrl_err;
+	u32 core_rx_pre_data;
+	u32 core_rx_pre_data_wapi_seq_err;
+	u32 core_rx_pre_data_wapi_key_err;
+	u32 core_rx_pre_data_handled;
+	u32 core_rx_pre_data_err;
+	u32 core_rx_pre_data_unknown;
+	u32 core_rx_pre_unknown;
+	u32 core_rx_enqueue;
+	u32 core_rx_dequeue;
+	u32 core_rx_post;
+	u32 core_rx_post_decrypt;
+	u32 core_rx_post_decrypt_wep;
+	u32 core_rx_post_decrypt_tkip;
+	u32 core_rx_post_decrypt_aes;
+	u32 core_rx_post_decrypt_wapi;
+	u32 core_rx_post_decrypt_hw;
+	u32 core_rx_post_decrypt_unknown;
+	u32 core_rx_post_decrypt_err;
+	u32 core_rx_post_defrag_err;
+	u32 core_rx_post_portctrl_err;
+	u32 core_rx_post_indicate;
+	u32 core_rx_post_indicate_in_oder;
+	u32 core_rx_post_indicate_reoder;
+	u32 core_rx_post_indicate_err;
+	u32 os_indicate;
+	u32 os_indicate_ap_mcast;
+	u32 os_indicate_ap_forward;
+	u32 os_indicate_ap_self;
+	u32 os_indicate_err;
+	u32 os_netif_ok;
+	u32 os_netif_err;
+};
+
+struct tx_logs {
+	u32 os_tx;
+	u32 os_tx_err_up;
+	u32 os_tx_err_xmit;
+	u32 os_tx_m2u;
+	u32 os_tx_m2u_ignore_fw_linked;
+	u32 os_tx_m2u_ignore_self;
+	u32 os_tx_m2u_entry;
+	u32 os_tx_m2u_entry_err_xmit;
+	u32 os_tx_m2u_entry_err_skb;
+	u32 os_tx_m2u_stop;
+	u32 core_tx;
+	u32 core_tx_err_pxmitframe;
+	u32 core_tx_err_brtx;
+	u32 core_tx_upd_attrib;
+	u32 core_tx_upd_attrib_adhoc;
+	u32 core_tx_upd_attrib_sta;
+	u32 core_tx_upd_attrib_ap;
+	u32 core_tx_upd_attrib_unknown;
+	u32 core_tx_upd_attrib_dhcp;
+	u32 core_tx_upd_attrib_icmp;
+	u32 core_tx_upd_attrib_active;
+	u32 core_tx_upd_attrib_err_ucast_sta;
+	u32 core_tx_upd_attrib_err_ucast_ap_link;
+	u32 core_tx_upd_attrib_err_sta;
+	u32 core_tx_upd_attrib_err_link;
+	u32 core_tx_upd_attrib_err_sec;
+	u32 core_tx_ap_enqueue_warn_fwstate;
+	u32 core_tx_ap_enqueue_warn_sta;
+	u32 core_tx_ap_enqueue_warn_nosta;
+	u32 core_tx_ap_enqueue_warn_link;
+	u32 core_tx_ap_enqueue_warn_trigger;
+	u32 core_tx_ap_enqueue_mcast;
+	u32 core_tx_ap_enqueue_ucast;
+	u32 core_tx_ap_enqueue;
+	u32 intf_tx;
+	u32 intf_tx_pending_ac;
+	u32 intf_tx_pending_fw_under_survey;
+	u32 intf_tx_pending_fw_under_linking;
+	u32 intf_tx_pending_xmitbuf;
+	u32 intf_tx_enqueue;
+	u32 core_tx_enqueue;
+	u32 core_tx_enqueue_class;
+	u32 core_tx_enqueue_class_err_sta;
+	u32 core_tx_enqueue_class_err_nosta;
+	u32 core_tx_enqueue_class_err_fwlink;
+	u32 intf_tx_direct;
+	u32 intf_tx_direct_err_coalesce;
+	u32 intf_tx_dequeue;
+	u32 intf_tx_dequeue_err_coalesce;
+	u32 intf_tx_dump_xframe;
+	u32 intf_tx_dump_xframe_err_txdesc;
+	u32 intf_tx_dump_xframe_err_port;
+};
+
+struct int_logs {
+	u32 all;
+	u32 err;
+	u32 tbdok;
+	u32 tbder;
+	u32 bcnderr;
+	u32 bcndma;
+	u32 bcndma_e;
+	u32 rx;
+	u32 rx_rdu;
+	u32 rx_fovw;
+	u32 txfovw;
+	u32 mgntok;
+	u32 highdok;
+	u32 bkdok;
+	u32 bedok;
+	u32 vidok;
+	u32 vodok;
+};
+
+#endif /* CONFIG_DBG_COUNTER */
+
+struct debug_priv {
+	u32 dbg_sdio_free_irq_error_cnt;
+	u32 dbg_sdio_alloc_irq_error_cnt;
+	u32 dbg_sdio_free_irq_cnt;
+	u32 dbg_sdio_alloc_irq_cnt;
+	u32 dbg_sdio_deinit_error_cnt;
+	u32 dbg_sdio_init_error_cnt;
+	u32 dbg_suspend_error_cnt;
+	u32 dbg_suspend_cnt;
+	u32 dbg_resume_cnt;
+	u32 dbg_resume_error_cnt;
+	u32 dbg_deinit_fail_cnt;
+	u32 dbg_carddisable_cnt;
+	u32 dbg_carddisable_error_cnt;
+	u32 dbg_ps_insuspend_cnt;
+	u32	dbg_dev_unload_inIPS_cnt;
+	u32 dbg_wow_leave_ps_fail_cnt;
+	u32 dbg_scan_pwr_state_cnt;
+	u32 dbg_downloadfw_pwr_state_cnt;
+	u32 dbg_fw_read_ps_state_fail_cnt;
+	u32 dbg_leave_ips_fail_cnt;
+	u32 dbg_leave_lps_fail_cnt;
+	u32 dbg_h2c_leave32k_fail_cnt;
+	u32 dbg_diswow_dload_fw_fail_cnt;
+	u32 dbg_enwow_dload_fw_fail_cnt;
+	u32 dbg_ips_drvopen_fail_cnt;
+	u32 dbg_poll_fail_cnt;
+	u32 dbg_rpwm_toogle_cnt;
+	u32 dbg_rpwm_timeout_fail_cnt;
+	u32 dbg_sreset_cnt;
+	u64 dbg_rx_fifo_last_overflow;
+	u64 dbg_rx_fifo_curr_overflow;
+	u64 dbg_rx_fifo_diff_overflow;
+	u64 dbg_rx_ampdu_drop_count;
+	u64 dbg_rx_ampdu_forced_indicate_count;
+	u64 dbg_rx_ampdu_loss_count;
+	u64 dbg_rx_dup_mgt_frame_drop_count;
+	u64 dbg_rx_ampdu_window_shift_cnt;
+	u64 dbg_rx_conflic_mac_addr_cnt;
+};
+
+struct rtw_traffic_statistics {
+	/* tx statistics */
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	cur_tx_bytes;
+	u64	last_tx_bytes;
+	u32	cur_tx_tp; /* Tx throughput in MBps. */
+
+	/* rx statistics */
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+	u64	cur_rx_bytes;
+	u64	last_rx_bytes;
+	u32	cur_rx_tp; /* Rx throughput in MBps. */
+};
+
+#define SEC_CAP_CHK_BMC	BIT0
+
+#define SEC_STATUS_STA_PK_GK_CONFLICT_DIS_BMC_SEARCH	BIT0
+
+struct sec_cam_bmp {
+	u32 m0;
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 32)
+	u32 m1;
+#endif
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 64)
+	u32 m2;
+#endif
+#if (SEC_CAM_ENT_NUM_SW_LIMIT > 96)
+	u32 m3;
+#endif
+};
+
+struct cam_ctl_t {
+	_lock lock;
+
+	u8 sec_cap;
+	u32 flags;
+
+	u8 num;
+	struct sec_cam_bmp used;
+
+	_mutex sec_cam_access_mutex;
+};
+
+struct sec_cam_ent {
+	u16 ctrl;
+	u8 mac[ETH_ALEN];
+	u8 key[16];
+};
+
+#define KEY_FMT "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
+#define KEY_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
+	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9], ((u8 *)(x))[10], ((u8 *)(x))[11], \
+	((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15]
+
+struct macid_bmp {
+	u32 m0;
+#if (MACID_NUM_SW_LIMIT > 32)
+	u32 m1;
+#endif
+#if (MACID_NUM_SW_LIMIT > 64)
+	u32 m2;
+#endif
+#if (MACID_NUM_SW_LIMIT > 96)
+	u32 m3;
+#endif
+};
+
+struct macid_ctl_t {
+	_lock lock;
+	u8 num;
+	struct macid_bmp used;
+	struct macid_bmp bmc;
+	struct macid_bmp if_g[CONFIG_IFACE_NUMBER];
+	u8 iface_bmc[CONFIG_IFACE_NUMBER];/*for bc-sta of AP or Adhoc mode*/
+	struct macid_bmp ch_g[2]; /* 2 ch concurrency */
+	u8 h2c_msr[MACID_NUM_SW_LIMIT];
+	u8 bw[MACID_NUM_SW_LIMIT];
+	u8 vht_en[MACID_NUM_SW_LIMIT];
+	u32 rate_bmp0[MACID_NUM_SW_LIMIT];
+	u32 rate_bmp1[MACID_NUM_SW_LIMIT];
+	struct sta_info *sta[MACID_NUM_SW_LIMIT];
+};
+
+/* used for rf_ctl_t.rate_bmp_cck_ofdm */
+#define RATE_BMP_CCK		0x000F
+#define RATE_BMP_OFDM		0xFFF0
+#define RATE_BMP_HAS_CCK(_bmp_cck_ofdm)		(_bmp_cck_ofdm & RATE_BMP_CCK)
+#define RATE_BMP_HAS_OFDM(_bmp_cck_ofdm)	(_bmp_cck_ofdm & RATE_BMP_OFDM)
+#define RATE_BMP_GET_CCK(_bmp_cck_ofdm)		(_bmp_cck_ofdm & RATE_BMP_CCK)
+#define RATE_BMP_GET_OFDM(_bmp_cck_ofdm)	((_bmp_cck_ofdm & RATE_BMP_OFDM) >> 4)
+
+/* used for rf_ctl_t.rate_bmp_ht_by_bw */
+#define RATE_BMP_HT_1SS		0x000000FF
+#define RATE_BMP_HT_2SS		0x0000FF00
+#define RATE_BMP_HT_3SS		0x00FF0000
+#define RATE_BMP_HT_4SS		0xFF000000
+#define RATE_BMP_HAS_HT_1SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_1SS)
+#define RATE_BMP_HAS_HT_2SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_2SS)
+#define RATE_BMP_HAS_HT_3SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_3SS)
+#define RATE_BMP_HAS_HT_4SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_4SS)
+#define RATE_BMP_GET_HT_1SS(_bmp_ht)		(_bmp_ht & RATE_BMP_HT_1SS)
+#define RATE_BMP_GET_HT_2SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_2SS) >> 8)
+#define RATE_BMP_GET_HT_3SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_3SS) >> 16)
+#define RATE_BMP_GET_HT_4SS(_bmp_ht)		((_bmp_ht & RATE_BMP_HT_4SS) >> 24)
+
+/* used for rf_ctl_t.rate_bmp_vht_by_bw */
+#define RATE_BMP_VHT_1SS	0x000003FF
+#define RATE_BMP_VHT_2SS	0x000FFC00
+#define RATE_BMP_VHT_3SS	0x3FF00000
+#define RATE_BMP_HAS_VHT_1SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_1SS)
+#define RATE_BMP_HAS_VHT_2SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_2SS)
+#define RATE_BMP_HAS_VHT_3SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_3SS)
+#define RATE_BMP_GET_VHT_1SS(_bmp_vht)		(_bmp_vht & RATE_BMP_VHT_1SS)
+#define RATE_BMP_GET_VHT_2SS(_bmp_vht)		((_bmp_vht & RATE_BMP_VHT_2SS) >> 10)
+#define RATE_BMP_GET_VHT_3SS(_bmp_vht)		((_bmp_vht & RATE_BMP_VHT_3SS) >> 20)
+
+struct rf_ctl_t {
+	/* used for debug or by tx power limit */
+	u16 rate_bmp_cck_ofdm;		/* 20MHz */
+	u32 rate_bmp_ht_by_bw[2];	/* 20MHz, 40MHz. 4SS supported */
+	u32 rate_bmp_vht_by_bw[4];	/* 20MHz, 40MHz, 80MHz, 160MHz. up to 3SS supported */
+
+	/* used by tx power limit */
+	u8 highest_ht_rate_bw_bmp;
+	u8 highest_vht_rate_bw_bmp;
+
+#ifdef CONFIG_DFS_MASTER
+	bool radar_detect_by_others;
+	u8 dfs_master_enabled;
+	bool radar_detected;
+
+	u8 radar_detect_ch;
+	u8 radar_detect_bw;
+	u8 radar_detect_offset;
+
+	u32 cac_start_time;
+	u32 cac_end_time;
+
+	u8 dfs_ch_sel_d_flags;
+
+	u8 dbg_dfs_master_fake_radar_detect_cnt;
+	u8 dbg_dfs_master_radar_detect_trigger_non;
+	u8 dbg_dfs_master_choose_dfs_ch_first;
+#endif
+};
+
+#define RTW_CAC_STOPPED 0
+#define IS_CAC_STOPPED(rfctl) ((rfctl)->cac_end_time == RTW_CAC_STOPPED)
+#define IS_CH_WAITING(rfctl) (!IS_CAC_STOPPED(rfctl) && time_after((unsigned long)(rfctl)->cac_end_time, (unsigned long)jiffies))
+#define IS_UNDER_CAC(rfctl) (IS_CH_WAITING(rfctl) && time_after((unsigned long)jiffies, (unsigned long)(rfctl)->cac_start_time))
+
+#ifdef CONFIG_MBSSID_CAM
+#define TOTAL_MBID_CAM_NUM	8
+#define INVALID_CAM_ID			0xFF
+struct mbid_cam_ctl_t {
+	_lock lock;
+	u8 bitmap;
+	ATOMIC_T mbid_entry_num;
+};
+struct mbid_cam_cache {
+	u8 iface_id;
+	/*u8 role;*/ /*WIFI_STATION_STATE or WIFI_AP_STATE*/
+	u8 mac_addr[ETH_ALEN];
+};
+#endif /*CONFIG_MBSSID_CAM*/
+
+#ifdef RTW_HALMAC
+struct halmac_indicator {
+	struct submit_ctx *sctx;
+	u8 *buffer;
+	u32 buf_size;
+	u32 ret_size;
+	u32 status;
+};
+
+struct halmacpriv {
+	/* flags */
+
+	/* For asynchronous functions */
+	struct halmac_indicator *indicator;
+};
+#endif /* RTW_HALMAC */
+
+struct dvobj_priv {
+	/*-------- below is common data --------*/
+	u8	chip_type;
+	u8	HardwareType;
+	u8	interface_type;/*USB,SDIO,SPI,PCI*/
+
+	ATOMIC_T	bSurpriseRemoved;
+	ATOMIC_T	bDriverStopped;
+
+	s32	processing_dev_remove;
+
+	struct debug_priv drv_dbg;
+
+	_mutex hw_init_mutex;
+	_mutex h2c_fwcmd_mutex;
+
+#ifdef CONFIG_RTW_CUSTOMER_STR
+	_mutex customer_str_mutex;
+	struct submit_ctx *customer_str_sctx;
+	u8 customer_str[RTW_CUSTOMER_STR_LEN];
+#endif
+
+	_mutex setch_mutex;
+	_mutex setbw_mutex;
+	_mutex rf_read_reg_mutex;
+#ifdef CONFIG_SDIO_INDIRECT_ACCESS
+	_mutex sd_indirect_access_mutex;
+#endif
+
+	unsigned char	oper_channel; /* saved channel info when call set_channel_bw */
+	unsigned char	oper_bwmode;
+	unsigned char	oper_ch_offset;/* PRIME_CHNL_OFFSET */
+	u32 on_oper_ch_time;
+
+	_adapter *padapters[CONFIG_IFACE_NUMBER];/*IFACE_ID_MAX*/
+	u8 iface_nums; /* total number of ifaces used runtime */
+	struct mi_state iface_state;
+
+#ifdef CONFIG_AP_MODE
+	u8 nr_ap_if; /* total interface s number of ap/go mode. */
+	u32 inter_bcn_space; /* unit:ms */
+	_queue	ap_if_q;
+#endif
+
+	struct macid_ctl_t macid_ctl;
+
+	struct cam_ctl_t cam_ctl;
+	struct sec_cam_ent cam_cache[SEC_CAM_ENT_NUM_SW_LIMIT];
+
+#ifdef CONFIG_MBSSID_CAM
+	struct mbid_cam_ctl_t mbid_cam_ctl;
+	struct mbid_cam_cache mbid_cam_cache[TOTAL_MBID_CAM_NUM];
+#endif
+
+	struct rf_ctl_t rf_ctl;
+
+	/* For 92D, DMDP have 2 interface. */
+	u8	InterfaceNumber;
+	u8	NumInterfaces;
+
+	/* In /Out Pipe information */
+	int	RtInPipe[2];
+	int	RtOutPipe[4];
+	u8	Queue2Pipe[HW_QUEUE_ENTRY];/* for out pipe mapping */
+
+	u8	irq_alloc;
+	ATOMIC_T continual_io_error;
+
+	ATOMIC_T disable_func;
+
+	struct pwrctrl_priv pwrctl_priv;
+
+	struct rtw_traffic_statistics	traffic_stat;
+
+	_thread_hdl_ rtnl_lock_holder;
+
+	#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+	#endif
+
+#ifdef CONFIG_SWTIMER_BASED_TXBCN
+	struct timer_list txbcn_timer;
+#endif
+	struct timer_list dynamic_chk_timer; /* dynamic/periodic check timer */
+
+#ifdef RTW_HALMAC
+	void *halmac;
+	struct halmacpriv hmpriv;
+#endif /* RTW_HALMAC */
+
+#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+	u8 default_port_id;
+#endif
+	/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef INTF_DATA
+	INTF_DATA intf_data;
+#endif
+#ifdef INTF_OPS
+	INTF_OPS intf_ops;
+#endif
+
+	/*-------- below is for USB INTERFACE --------*/
+
+	u8	usb_speed; /* 1.1, 2.0 or 3.0 */
+	u8	nr_endpoint;
+	u8	RtNumInPipes;
+	u8	RtNumOutPipes;
+	int	ep_num[6]; /* endpoint number */
+
+	int	RegUsbSS;
+
+	_sema	usb_suspend_sema;
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	_mutex  usb_vendor_req_mutex;
+#endif
+
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	u8 *usb_alloc_vendor_req_buf;
+	u8 *usb_vendor_req_buf;
+#endif
+
+	struct usb_interface *pusbintf;
+	struct usb_device *pusbdev;
+
+	/*-------- below is for PCIE INTERFACE --------*/
+
+#ifdef CONFIG_MCC_MODE
+	struct mcc_obj_priv mcc_objpriv;
+#endif /*CONFIG_MCC_MODE */
+};
+
+#define DEV_STA_NUM(_dvobj)			MSTATE_STA_NUM(&((_dvobj)->iface_state))
+#define DEV_STA_LD_NUM(_dvobj)		MSTATE_STA_LD_NUM(&((_dvobj)->iface_state))
+#define DEV_STA_LG_NUM(_dvobj)		MSTATE_STA_LG_NUM(&((_dvobj)->iface_state))
+#define DEV_AP_NUM(_dvobj)			MSTATE_AP_NUM(&((_dvobj)->iface_state))
+#define DEV_AP_LD_NUM(_dvobj)		MSTATE_AP_LD_NUM(&((_dvobj)->iface_state))
+#define DEV_ADHOC_NUM(_dvobj)		MSTATE_ADHOC_NUM(&((_dvobj)->iface_state))
+#define DEV_ADHOC_LD_NUM(_dvobj)	MSTATE_ADHOC_LD_NUM(&((_dvobj)->iface_state))
+#define DEV_WPS_NUM(_dvobj)			MSTATE_WPS_NUM(&((_dvobj)->iface_state))
+#define DEV_ROCH_NUM(_dvobj)		MSTATE_ROCH_NUM(&((_dvobj)->iface_state))
+#define DEV_MGMT_TX_NUM(_dvobj)		MSTATE_MGMT_TX_NUM(&((_dvobj)->iface_state))
+#define DEV_U_CH(_dvobj)			MSTATE_U_CH(&((_dvobj)->iface_state))
+#define DEV_U_BW(_dvobj)			MSTATE_U_BW(&((_dvobj)->iface_state))
+#define DEV_U_OFFSET(_dvobj)		MSTATE_U_OFFSET(&((_dvobj)->iface_state))
+
+#define dvobj_to_pwrctl(dvobj) (&(dvobj->pwrctl_priv))
+#define pwrctl_to_dvobj(pwrctl) container_of(pwrctl, struct dvobj_priv, pwrctl_priv)
+#define dvobj_to_macidctl(dvobj) (&(dvobj->macid_ctl))
+#define dvobj_to_sec_camctl(dvobj) (&(dvobj->cam_ctl))
+#define dvobj_to_regsty(dvobj) (&(dvobj->padapters[IFACE_ID0]->registrypriv))
+#if defined(CONFIG_IOCTL_CFG80211) && defined(RTW_SINGLE_WIPHY)
+#define dvobj_to_wiphy(dvobj) ((dvobj)->wiphy)
+#endif
+#define dvobj_to_rfctl(dvobj) (&(dvobj->rf_ctl))
+#define rfctl_to_dvobj(rfctl) container_of((rfctl), struct dvobj_priv, rf_ctl)
+
+static inline void dev_set_surprise_removed(struct dvobj_priv *dvobj)
+{
+	ATOMIC_SET(&dvobj->bSurpriseRemoved, true);
+}
+static inline void dev_clr_surprise_removed(struct dvobj_priv *dvobj)
+{
+	ATOMIC_SET(&dvobj->bSurpriseRemoved, false);
+}
+static inline void dev_set_drv_stopped(struct dvobj_priv *dvobj)
+{
+	ATOMIC_SET(&dvobj->bDriverStopped, true);
+}
+static inline void dev_clr_drv_stopped(struct dvobj_priv *dvobj)
+{
+	ATOMIC_SET(&dvobj->bDriverStopped, false);
+}
+#define dev_is_surprise_removed(dvobj)	(ATOMIC_READ(&dvobj->bSurpriseRemoved) == true)
+#define dev_is_drv_stopped(dvobj)		(ATOMIC_READ(&dvobj->bDriverStopped) == true)
+
+static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
+{
+	/* todo: get interface type from dvobj and the return the dev accordingly */
+	return &dvobj->pusbintf->dev;
+}
+
+_adapter *dvobj_get_port0_adapter(struct dvobj_priv *dvobj);
+_adapter *dvobj_get_unregisterd_adapter(struct dvobj_priv *dvobj);
+_adapter *dvobj_get_adapter_by_addr(struct dvobj_priv *dvobj, u8 *addr);
+#define dvobj_get_primary_adapter(dvobj)	((dvobj)->padapters[IFACE_ID0])
+
+enum _hw_port {
+	HW_PORT0,
+	HW_PORT1,
+	HW_PORT2,
+	HW_PORT3,
+	HW_PORT4,
+	MAX_HW_PORT,
+};
+
+enum _ADAPTER_TYPE {
+	PRIMARY_ADAPTER,
+	VIRTUAL_ADAPTER,
+	MAX_ADAPTER = 0xFF,
+};
+
+typedef enum _DRIVER_STATE {
+	DRIVER_NORMAL = 0,
+	DRIVER_DISAPPEAR = 1,
+	DRIVER_REPLACE_DONGLE = 2,
+} DRIVER_STATE;
+
+#ifdef CONFIG_RTW_NAPI
+enum _NAPI_STATE {
+	NAPI_DISABLE = 0,
+	NAPI_ENABLE = 1,
+};
+#endif
+
+#ifdef CONFIG_INTEL_PROXIM
+struct proxim {
+	bool proxim_support;
+	bool proxim_on;
+
+	void *proximity_priv;
+	int (*proxim_rx)(_adapter *padapter,
+			 union recv_frame *precv_frame);
+	u8(*proxim_get_var)(_adapter *padapter, u8 type);
+};
+#endif /* CONFIG_INTEL_PROXIM */
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+typedef struct loopbackdata {
+	_sema	sema;
+	_thread_hdl_ lbkthread;
+	u8 bstop;
+	u32 cnt;
+	u16 size;
+	u16 txsize;
+	u8 txbuf[0x8000];
+	u16 rxsize;
+	u8 rxbuf[0x8000];
+	u8 msg[100];
+
+} LOOPBACKDATA, *PLOOPBACKDATA;
+#endif
+
+struct tsf_info {
+	u8 sync_port;/*tsf sync from portx*/
+	u8 offset; /*tsf timer offset*/
+};
+
+#define ADAPTER_TX_BW_2G(adapter) BW_MODE_2G((adapter)->driver_tx_bw_mode)
+#define ADAPTER_TX_BW_5G(adapter) BW_MODE_5G((adapter)->driver_tx_bw_mode)
+
+struct _ADAPTER {
+	int	DriverState;/* for disable driver using module, use dongle to replace module. */
+	int	pid[3];/* process id from UI, 0:wps, 1:hostapd, 2:dhcpcd */
+	int	bDongle;/* build-in module or external dongle */
+
+	_list	list;
+
+	struct dvobj_priv *dvobj;
+	struct	mlme_priv mlmepriv;
+	struct	mlme_ext_priv mlmeextpriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	/* struct	io_queue	*pio_queue; */
+	struct	io_priv	iopriv;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	spinlock_t security_key_mutex; /* add for CONFIG_IEEE80211W, non 11w also can use */
+	struct	registry_priv	registrypriv;
+
+	struct	led_priv	ledpriv;
+
+#ifdef CONFIG_RTW_NAPI
+	struct	napi_struct napi;
+	u8	napi_state;
+#endif
+
+#ifdef CONFIG_MP_INCLUDED
+	struct	mp_priv	mppriv;
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE
+	struct	drvext_priv	drvextpriv;
+#endif
+
+#ifdef CONFIG_AP_MODE
+	struct	hostapd_priv	*phostapdpriv;
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+#ifdef CONFIG_P2P
+	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
+#endif /* CONFIG_P2P */
+#endif /* CONFIG_IOCTL_CFG80211 */
+	u32	setband;
+	ATOMIC_T bandskip;
+
+#ifdef CONFIG_P2P
+	struct wifidirect_info	wdinfo;
+#endif /* CONFIG_P2P */
+
+#ifdef CONFIG_TDLS
+	struct tdls_info	tdlsinfo;
+#endif /* CONFIG_TDLS */
+
+#ifdef CONFIG_WAPI_SUPPORT
+	u8	WapiSupport;
+	RT_WAPI_T	wapiInfo;
+#endif
+
+
+#ifdef CONFIG_WFD
+	struct wifi_display_info wfd_info;
+#endif /* CONFIG_WFD */
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	struct bt_coex_info coex_info;
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+
+	ERROR_CODE		LastError; /* <20130613, Kordan> Only the functions associated with MP records the error code by now. */
+
+	void *			HalData;
+	u32 hal_data_sz;
+	struct hal_ops	hal_func;
+
+	u32	IsrContent;
+	u32	ImrContent;
+
+	u8	EepromAddressSize;
+	u8	bDriverIsGoingToUnload;
+	u8	init_adpt_in_progress;
+	u8	bHaltInProgress;
+#ifdef CONFIG_GPIO_API
+	u8	pre_gpio_pin;
+	struct gpio_int_priv {
+		u8 interrupt_mode;
+		u8 interrupt_enable_mask;
+		void (*callback[8])(u8 level);
+	} gpiointpriv;
+#endif
+	_thread_hdl_ cmdThread;
+	_thread_hdl_ evtThread;
+	_thread_hdl_ xmitThread;
+	_thread_hdl_ recvThread;
+
+	u8 registered;
+
+	u32(*intf_init)(struct dvobj_priv *dvobj);
+	void (*intf_deinit)(struct dvobj_priv *dvobj);
+	int (*intf_alloc_irq)(struct dvobj_priv *dvobj);
+	void (*intf_free_irq)(struct dvobj_priv *dvobj);
+
+
+	void (*intf_start)(_adapter *adapter);
+	void (*intf_stop)(_adapter *adapter);
+
+	_nic_hdl pnetdev;
+	char old_ifname[IFNAMSIZ];
+
+	/* used by rtw_rereg_nd_name related function */
+	struct rereg_nd_name_data {
+		_nic_hdl old_pnetdev;
+		char old_ifname[IFNAMSIZ];
+		u8 old_ips_mode;
+		u8 old_bRegUseLed;
+	} rereg_nd_name_priv;
+
+	u8 ndev_unregistering;
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	struct proc_dir_entry *dir_dev;/* for proc directory */
+	struct proc_dir_entry *dir_odm;
+
+#ifdef CONFIG_MCC_MODE
+	struct proc_dir_entry *dir_mcc;
+#endif /* CONFIG_MCC_MODE */
+
+#ifdef CONFIG_IOCTL_CFG80211
+	struct wireless_dev *rtw_wdev;
+	struct rtw_wdev_priv wdev_data;
+
+#if !defined(RTW_SINGLE_WIPHY)
+	struct wiphy *wiphy;
+#endif
+
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+	u8 mac_addr[ETH_ALEN];
+	int net_closed;
+
+	u8 netif_up;
+
+	u8 bFWReady;
+	u8 bBTFWReady;
+	u8 bLinkInfoDump;
+	u8 bRxRSSIDisplay;
+	/*	Added by Albert 2012/10/26 */
+	/*	The driver will show up the desired channel number when this flag is 1. */
+	u8 bNotifyChannelChange;
+#ifdef CONFIG_P2P
+	/*	Added by Albert 2012/12/06 */
+	/*	The driver will show the current P2P status when the upper application reads it. */
+	u8 bShowGetP2PState;
+#endif
+#ifdef CONFIG_AUTOSUSPEND
+	u8	bDisableAutosuspend;
+#endif
+
+	u8 isprimary; /* is primary adapter or not */
+	/* notes:
+	**	if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER
+	**	if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for VIRTUAL_ADAPTER
+	**	refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff.*/
+	u8 adapter_type;/*be used in  Multi-interface to recognize whether is PRIMARY_ADAPTER  or not(PRIMARY_ADAPTER/VIRTUAL_ADAPTER) .*/
+	u8 hw_port; /*interface port type, it depends on HW port */
+	struct tsf_info tsf;
+
+
+	/*extend to support multi interface*/
+	/*IFACE_ID0 is equals to PRIMARY_ADAPTER
+	IFACE_ID1 is equals to VIRTUAL_ADAPTER*/
+	u8 iface_id;
+
+#ifdef CONFIG_BR_EXT
+	_lock					br_ext_lock;
+	/* unsigned int			macclone_completed; */
+	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
+	int				pppoe_connection_in_progress;
+	unsigned char			pppoe_addr[MACADDRLEN];
+	unsigned char			scdb_mac[MACADDRLEN];
+	unsigned char			scdb_ip[4];
+	struct nat25_network_db_entry	*scdb_entry;
+	unsigned char			br_mac[MACADDRLEN];
+	unsigned char			br_ip[4];
+
+	struct br_ext_info		ethBrExtInfo;
+#endif /* CONFIG_BR_EXT */
+
+#ifdef CONFIG_INTEL_PROXIM
+	/* intel Proximity, should be alloc mem
+	 * in intel Proximity module and can only
+	 * be used in intel Proximity mode */
+	struct proxim proximity;
+#endif /* CONFIG_INTEL_PROXIM */
+
+#ifdef CONFIG_MAC_LOOPBACK_DRIVER
+	PLOOPBACKDATA ploopback;
+#endif
+
+	/* for debug purpose */
+	u8 fix_rate;
+	u8 fix_bw;
+	u8 data_fb; /* data rate fallback, valid only when fix_rate is not 0xff */
+	u8 power_offset;
+	u8 driver_tx_bw_mode;
+	u8 rsvd_page_offset;
+	u8 rsvd_page_num;
+
+	u8 driver_vcs_en; /* Enable=1, Disable=0 driver control vrtl_carrier_sense for tx */
+	u8 driver_vcs_type;/* force 0:disable VCS, 1:RTS-CTS, 2:CTS-to-self when vcs_en=1. */
+	u8 driver_ampdu_spacing;/* driver control AMPDU Density for peer sta's rx */
+	u8 driver_rx_ampdu_factor;/* 0xff: disable drv ctrl, 0:8k, 1:16k, 2:32k, 3:64k; */
+	u8 driver_rx_ampdu_spacing;  /* driver control Rx AMPDU Density */
+	u8 fix_rx_ampdu_accept;
+	u8 fix_rx_ampdu_size; /* 0~127, TODO:consider each sta and each TID */
+#ifdef CONFIG_TX_AMSDU
+	u8 tx_amsdu;
+	u16 tx_amsdu_rate;
+#endif
+	unsigned char     in_cta_test;
+#ifdef DBG_RX_COUNTER_DUMP
+	u8 dump_rx_cnt_mode;/*BIT0:drv,BIT1:mac,BIT2:phy*/
+	u32 drv_rx_cnt_ok;
+	u32 drv_rx_cnt_crcerror;
+	u32 drv_rx_cnt_drop;
+#endif
+
+#ifdef CONFIG_DBG_COUNTER
+	struct rx_logs rx_logs;
+	struct tx_logs tx_logs;
+	struct int_logs int_logs;
+#endif
+
+#ifdef CONFIG_MCC_MODE
+	struct mcc_adapter_priv mcc_adapterpriv;
+#endif /* CONFIG_MCC_MODE */
+};
+
+#define adapter_to_dvobj(adapter) ((adapter)->dvobj)
+#define adapter_to_regsty(adapter) dvobj_to_regsty(adapter_to_dvobj((adapter)))
+#define adapter_to_pwrctl(adapter) dvobj_to_pwrctl(adapter_to_dvobj((adapter)))
+#define adapter_wdev_data(adapter) (&((adapter)->wdev_data))
+#if defined(RTW_SINGLE_WIPHY)
+#define adapter_to_wiphy(adapter) dvobj_to_wiphy(adapter_to_dvobj(adapter))
+#else
+#define adapter_to_wiphy(adapter) ((adapter)->wiphy)
+#endif
+
+#define adapter_to_rfctl(adapter) dvobj_to_rfctl(adapter_to_dvobj((adapter)))
+
+#define adapter_mac_addr(adapter) (adapter->mac_addr)
+
+#define mlme_to_adapter(mlme) container_of((mlme), struct _ADAPTER, mlmepriv)
+#define tdls_info_to_adapter(tdls) container_of((tdls), struct _ADAPTER, tdlsinfo)
+
+#define rtw_get_chip_type(adapter) (((PADAPTER)adapter)->dvobj->chip_type)
+#define rtw_get_hw_type(adapter) (((PADAPTER)adapter)->dvobj->HardwareType)
+#define rtw_get_intf_type(adapter) (((PADAPTER)adapter)->dvobj->interface_type)
+
+#define rtw_get_mi_nums(adapter) (((PADAPTER)adapter)->dvobj->iface_nums)
+
+static inline void rtw_set_surprise_removed(_adapter *padapter)
+{
+	dev_set_surprise_removed(adapter_to_dvobj(padapter));
+}
+static inline void rtw_clr_surprise_removed(_adapter *padapter)
+{
+	dev_clr_surprise_removed(adapter_to_dvobj(padapter));
+}
+static inline void rtw_set_drv_stopped(_adapter *padapter)
+{
+	dev_set_drv_stopped(adapter_to_dvobj(padapter));
+}
+static inline void rtw_clr_drv_stopped(_adapter *padapter)
+{
+	dev_clr_drv_stopped(adapter_to_dvobj(padapter));
+}
+#define rtw_is_surprise_removed(padapter)	(dev_is_surprise_removed(adapter_to_dvobj(padapter)))
+#define rtw_is_drv_stopped(padapter)		(dev_is_drv_stopped(adapter_to_dvobj(padapter)))
+
+/*
+ * Function disabled.
+ *   */
+#define DF_TX_BIT		BIT0			/*write_port_cancel*/
+#define DF_RX_BIT		BIT1			/*read_port_cancel*/
+#define DF_IO_BIT		BIT2
+
+/* #define RTW_DISABLE_FUNC(padapter, func) (ATOMIC_ADD(&adapter_to_dvobj(padapter)->disable_func, (func))) */
+/* #define RTW_ENABLE_FUNC(padapter, func) (ATOMIC_SUB(&adapter_to_dvobj(padapter)->disable_func, (func))) */
+__inline static void RTW_DISABLE_FUNC(_adapter *padapter, int func_bit)
+{
+	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
+	df |= func_bit;
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
+}
+
+__inline static void RTW_ENABLE_FUNC(_adapter *padapter, int func_bit)
+{
+	int	df = ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func);
+	df &= ~(func_bit);
+	ATOMIC_SET(&adapter_to_dvobj(padapter)->disable_func, df);
+}
+
+#define RTW_CANNOT_RUN(padapter) \
+	(rtw_is_surprise_removed(padapter) || \
+	 rtw_is_drv_stopped(padapter))
+
+#define RTW_IS_FUNC_DISABLED(padapter, func_bit) (ATOMIC_READ(&adapter_to_dvobj(padapter)->disable_func) & (func_bit))
+
+#define RTW_CANNOT_IO(padapter) \
+	(rtw_is_surprise_removed(padapter) || \
+	 RTW_IS_FUNC_DISABLED((padapter), DF_IO_BIT))
+
+#define RTW_CANNOT_RX(padapter) \
+	(RTW_CANNOT_RUN(padapter) || \
+	 RTW_IS_FUNC_DISABLED((padapter), DF_RX_BIT))
+
+#define RTW_CANNOT_TX(padapter) \
+	(RTW_CANNOT_RUN(padapter) || \
+	 RTW_IS_FUNC_DISABLED((padapter), DF_TX_BIT))
+
+#ifdef CONFIG_PNO_SUPPORT
+int rtw_parse_ssid_list_tlv(char **list_str, pno_ssid_t *ssid, int max, int *bytes_left);
+int rtw_dev_pno_set(struct net_device *net, pno_ssid_t *ssid, int num,
+		    int pno_time, int pno_repeat, int pno_freq_expo_max);
+#ifdef CONFIG_PNO_SET_DEBUG
+	void rtw_dev_pno_debug(struct net_device *net);
+#endif /* CONFIG_PNO_SET_DEBUG */
+#endif /* CONFIG_PNO_SUPPORT */
+
+void *scdb_findEntry(_adapter *priv, unsigned char *macAddr,
+		     unsigned char *ipAddr);
+void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb);
+int rtw_suspend_free_assoc_resource(_adapter *padapter);
+int recvbuf2recvframe(PADAPTER padapter, void *ptr);
+int rtw_change_ifname(_adapter *padapter, const char *ifname);
+
+#ifdef CONFIG_WOWLAN
+	int rtw_suspend_wow(_adapter *padapter);
+	int rtw_resume_process_wow(_adapter *padapter);
+#endif
+
+/* HCI Related header file */
+	#include <usb_osintf.h>
+	#include <usb_ops.h>
+	#include <usb_hal.h>
+
+#endif /* __DRV_TYPES_H__ */
diff --git a/drivers/staging/rtl8188eu/include/drv_types_linux.h b/drivers/staging/rtl8188eu/include/drv_types_linux.h
new file mode 100644
index 000000000000..8747696e9c0b
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/drv_types_linux.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __DRV_TYPES_LINUX_H__
+#define __DRV_TYPES_LINUX_H__
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/ethernet.h b/drivers/staging/rtl8188eu/include/ethernet.h
new file mode 100644
index 000000000000..fcb82740e411
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/ethernet.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+/*! \file */
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH				6		/* !< Ethernet Address Length */
+#define ETHERNET_HEADER_SIZE				14		/* !< Ethernet Header Length */
+#define LLC_HEADER_SIZE						6		/* !< LLC Header Length */
+#define TYPE_LENGTH_FIELD_SIZE				2		/* !< Type/Length Size */
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		/* !< Minimum Ethernet Packet Size */
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	/* !< Maximum Ethernet Packet Size */
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01) != 0)		/* !< Is Multicast Address? */
+#define RT_ETH_IS_BROADCAST(_pAddr)	(\
+		((u8 *)(_pAddr))[0] == 0xff	&&		\
+		((u8 *)(_pAddr))[1] == 0xff	&&		\
+		((u8 *)(_pAddr))[2] == 0xff	&&		\
+		((u8 *)(_pAddr))[3] == 0xff	&&		\
+		((u8 *)(_pAddr))[4] == 0xff	&&		\
+		((u8 *)(_pAddr))[5] == 0xff)	/* !< Is Broadcast Address? */
+
+
+#endif /*  #ifndef __INC_ETHERNET_H */
diff --git a/drivers/staging/rtl8188eu/include/h2clbk.h b/drivers/staging/rtl8188eu/include/h2clbk.h
new file mode 100644
index 000000000000..b9ff407be249
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/h2clbk.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+
+#define _H2CLBK_H_
+
+
+void _lbk_cmd(PADAPTER Adapter);
+
+void _lbk_rsp(PADAPTER Adapter);
+
+void _lbk_evt(IN PADAPTER Adapter);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
diff --git a/drivers/staging/rtl8188eu/include/hal_btcoex.h b/drivers/staging/rtl8188eu/include/hal_btcoex.h
new file mode 100644
index 000000000000..a8013f4aec64
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_btcoex.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_BTCOEX_H__
+#define __HAL_BTCOEX_H__
+
+#include <drv_types.h>
+
+/* Some variables can't get from outsrc BT-Coex,
+ * so we need to save here */
+typedef struct _BT_COEXIST {
+	u8 bBtExist;
+	u8 btTotalAntNum;
+	u8 btChipType;
+	u8 bInitlized;
+	u8 btAntisolation;
+} BT_COEXIST, *PBT_COEXIST;
+
+void DBG_BT_INFO(u8 *dbgmsg);
+
+void hal_btcoex_SetBTCoexist(PADAPTER padapter, u8 bBtExist);
+u8 hal_btcoex_IsBtExist(PADAPTER padapter);
+u8 hal_btcoex_IsBtDisabled(PADAPTER);
+void hal_btcoex_SetChipType(PADAPTER padapter, u8 chipType);
+void hal_btcoex_SetPgAntNum(PADAPTER padapter, u8 antNum);
+
+u8 hal_btcoex_Initialize(PADAPTER padapter);
+void hal_btcoex_PowerOnSetting(PADAPTER padapter);
+void hal_btcoex_PreLoadFirmware(PADAPTER padapter);
+void hal_btcoex_InitHwConfig(PADAPTER padapter, u8 bWifiOnly);
+
+void hal_btcoex_IpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_LpsNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ScanNotify(PADAPTER padapter, u8 type);
+void hal_btcoex_ConnectNotify(PADAPTER padapter, u8 action);
+void hal_btcoex_MediaStatusNotify(PADAPTER padapter, u8 mediaStatus);
+void hal_btcoex_SpecialPacketNotify(PADAPTER padapter, u8 pktType);
+void hal_btcoex_IQKNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_BtInfoNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_BtMpRptNotify(PADAPTER padapter, u8 length, u8 *tmpBuf);
+void hal_btcoex_SuspendNotify(PADAPTER padapter, u8 state);
+void hal_btcoex_HaltNotify(PADAPTER padapter, u8 do_halt);
+void hal_btcoex_SwitchBtTRxMask(PADAPTER padapter);
+
+void hal_btcoex_Hanlder(PADAPTER padapter);
+
+s32 hal_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
+s32 hal_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER padapter);
+u32 hal_btcoex_GetAMPDUSize(PADAPTER padapter);
+void hal_btcoex_SetManualControl(PADAPTER padapter, u8 bmanual);
+u8 hal_btcoex_1Ant(PADAPTER padapter);
+u8 hal_btcoex_IsBtControlLps(PADAPTER);
+u8 hal_btcoex_IsLpsOn(PADAPTER);
+u8 hal_btcoex_RpwmVal(PADAPTER);
+u8 hal_btcoex_LpsVal(PADAPTER);
+u32 hal_btcoex_GetRaMask(PADAPTER);
+void hal_btcoex_RecordPwrMode(PADAPTER padapter, u8 *pCmdBuf, u8 cmdLen);
+void hal_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
+void hal_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
+u32 hal_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
+u8 hal_btcoex_IncreaseScanDeviceNum(PADAPTER);
+u8 hal_btcoex_IsBtLinkExist(PADAPTER);
+void hal_btcoex_SetBtPatchVersion(PADAPTER, u16 btHciVer, u16 btPatchVer);
+void hal_btcoex_SetHciVersion(PADAPTER, u16 hciVersion);
+void hal_btcoex_SendScanNotify(PADAPTER, u8 type);
+void hal_btcoex_StackUpdateProfileInfo(void);
+void hal_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON);
+void hal_btcoex_SetAntIsolationType(PADAPTER padapter, u8 anttype);
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	int hal_btcoex_AntIsolationConfig_ParaFile(IN PADAPTER	Adapter, IN char *pFileName);
+	int hal_btcoex_ParseAntIsolationConfigFile(PADAPTER Adapter, char	*buffer);
+#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
+u16 hal_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
+u16 hal_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
+void hal_btcoex_set_rfe_type(u8 type);
+void hal_btcoex_switchband_notify(u8 under_scan, u8 band_type);
+#endif /* !__HAL_BTCOEX_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_btcoex_wifionly.h b/drivers/staging/rtl8188eu/include/hal_btcoex_wifionly.h
new file mode 100644
index 000000000000..d70841186b81
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_btcoex_wifionly.h
@@ -0,0 +1,47 @@
+#ifndef __HALBTC_WIFIONLY_H__
+#define __HALBTC_WIFIONLY_H__
+
+#include <drv_types.h>
+#include <hal_data.h>
+
+typedef enum _WIFIONLY_CHIP_INTERFACE {
+	WIFIONLY_INTF_UNKNOWN	= 0,
+	WIFIONLY_INTF_PCI		= 1,
+	WIFIONLY_INTF_USB		= 2,
+	WIFIONLY_INTF_SDIO		= 3,
+	WIFIONLY_INTF_MAX
+} WIFIONLY_CHIP_INTERFACE, *PWIFIONLY_CHIP_INTERFACE;
+
+typedef enum _WIFIONLY_CUSTOMER_ID {
+	CUSTOMER_NORMAL			= 0,
+	CUSTOMER_HP_1			= 1
+} WIFIONLY_CUSTOMER_ID, *PWIFIONLY_CUSTOMER_ID;
+
+struct wifi_only_haldata {
+	u16		customer_id;
+	u8		efuse_pg_antnum;
+	u8		efuse_pg_antpath;
+	u8		rfe_type;
+	u8		ant_div_cfg;
+};
+
+struct wifi_only_cfg {
+	void *						Adapter;
+	struct	wifi_only_haldata		haldata_info;
+	WIFIONLY_CHIP_INTERFACE	chip_interface;
+};
+
+void halwifionly_write1byte(void * pwifionlyContext, u32 RegAddr, u8 Data);
+void halwifionly_write2byte(void * pwifionlyContext, u32 RegAddr, u16 Data);
+void halwifionly_write4byte(void * pwifionlyContext, u32 RegAddr, u32 Data);
+u8 halwifionly_read1byte(void * pwifionlyContext, u32 RegAddr);
+u16 halwifionly_read2byte(void * pwifionlyContext, u32 RegAddr);
+u32 halwifionly_read4byte(void * pwifionlyContext, u32 RegAddr);
+void halwifionly_bitmaskwrite1byte(void * pwifionlyContext, u32 regAddr, u8 bitMask, u8 data);
+void halwifionly_phy_set_rf_reg(void * pwifionlyContext, u8 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+void halwifionly_phy_set_bb_reg(void * pwifionlyContext, u32 RegAddr, u32 BitMask, u32 Data);
+void hal_btcoex_wifionly_switchband_notify(PADAPTER padapter);
+void hal_btcoex_wifionly_scan_notify(PADAPTER padapter);
+void hal_btcoex_wifionly_hw_config(PADAPTER padapter);
+void hal_btcoex_wifionly_initlizevariables(PADAPTER padapter);
+#endif
diff --git a/drivers/staging/rtl8188eu/include/hal_com.h b/drivers/staging/rtl8188eu/include/hal_com.h
new file mode 100644
index 000000000000..7c4f2c50a9c8
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_com.h
@@ -0,0 +1,669 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_COMMON_H__
+#define __HAL_COMMON_H__
+
+#include "HalVerDef.h"
+#include "hal_pg.h"
+#include "hal_phy.h"
+#include "hal_phy_reg.h"
+#include "hal_com_reg.h"
+#include "hal_com_phycfg.h"
+#include "../hal/hal_com_c2h.h"
+
+/*------------------------------ Tx Desc definition Macro ------------------------*/
+/* #pragma mark -- Tx Desc related definition. -- */
+/* ----------------------------------------------------------------------------
+ * -----------------------------------------------------------
+ *	Rate
+ * -----------------------------------------------------------
+ * CCK Rates, TxHT = 0 */
+#define DESC_RATE1M					0x00
+#define DESC_RATE2M					0x01
+#define DESC_RATE5_5M				0x02
+#define DESC_RATE11M				0x03
+
+/* OFDM Rates, TxHT = 0 */
+#define DESC_RATE6M					0x04
+#define DESC_RATE9M					0x05
+#define DESC_RATE12M				0x06
+#define DESC_RATE18M				0x07
+#define DESC_RATE24M				0x08
+#define DESC_RATE36M				0x09
+#define DESC_RATE48M				0x0a
+#define DESC_RATE54M				0x0b
+
+/* MCS Rates, TxHT = 1 */
+#define DESC_RATEMCS0				0x0c
+#define DESC_RATEMCS1				0x0d
+#define DESC_RATEMCS2				0x0e
+#define DESC_RATEMCS3				0x0f
+#define DESC_RATEMCS4				0x10
+#define DESC_RATEMCS5				0x11
+#define DESC_RATEMCS6				0x12
+#define DESC_RATEMCS7				0x13
+#define DESC_RATEMCS8				0x14
+#define DESC_RATEMCS9				0x15
+#define DESC_RATEMCS10				0x16
+#define DESC_RATEMCS11				0x17
+#define DESC_RATEMCS12				0x18
+#define DESC_RATEMCS13				0x19
+#define DESC_RATEMCS14				0x1a
+#define DESC_RATEMCS15				0x1b
+#define DESC_RATEMCS16				0x1C
+#define DESC_RATEMCS17				0x1D
+#define DESC_RATEMCS18				0x1E
+#define DESC_RATEMCS19				0x1F
+#define DESC_RATEMCS20				0x20
+#define DESC_RATEMCS21				0x21
+#define DESC_RATEMCS22				0x22
+#define DESC_RATEMCS23				0x23
+#define DESC_RATEMCS24				0x24
+#define DESC_RATEMCS25				0x25
+#define DESC_RATEMCS26				0x26
+#define DESC_RATEMCS27				0x27
+#define DESC_RATEMCS28				0x28
+#define DESC_RATEMCS29				0x29
+#define DESC_RATEMCS30				0x2A
+#define DESC_RATEMCS31				0x2B
+#define DESC_RATEVHTSS1MCS0		0x2C
+#define DESC_RATEVHTSS1MCS1		0x2D
+#define DESC_RATEVHTSS1MCS2		0x2E
+#define DESC_RATEVHTSS1MCS3		0x2F
+#define DESC_RATEVHTSS1MCS4		0x30
+#define DESC_RATEVHTSS1MCS5		0x31
+#define DESC_RATEVHTSS1MCS6		0x32
+#define DESC_RATEVHTSS1MCS7		0x33
+#define DESC_RATEVHTSS1MCS8		0x34
+#define DESC_RATEVHTSS1MCS9		0x35
+#define DESC_RATEVHTSS2MCS0		0x36
+#define DESC_RATEVHTSS2MCS1		0x37
+#define DESC_RATEVHTSS2MCS2		0x38
+#define DESC_RATEVHTSS2MCS3		0x39
+#define DESC_RATEVHTSS2MCS4		0x3A
+#define DESC_RATEVHTSS2MCS5		0x3B
+#define DESC_RATEVHTSS2MCS6		0x3C
+#define DESC_RATEVHTSS2MCS7		0x3D
+#define DESC_RATEVHTSS2MCS8		0x3E
+#define DESC_RATEVHTSS2MCS9		0x3F
+#define DESC_RATEVHTSS3MCS0		0x40
+#define DESC_RATEVHTSS3MCS1		0x41
+#define DESC_RATEVHTSS3MCS2		0x42
+#define DESC_RATEVHTSS3MCS3		0x43
+#define DESC_RATEVHTSS3MCS4		0x44
+#define DESC_RATEVHTSS3MCS5		0x45
+#define DESC_RATEVHTSS3MCS6		0x46
+#define DESC_RATEVHTSS3MCS7		0x47
+#define DESC_RATEVHTSS3MCS8		0x48
+#define DESC_RATEVHTSS3MCS9		0x49
+#define DESC_RATEVHTSS4MCS0		0x4A
+#define DESC_RATEVHTSS4MCS1		0x4B
+#define DESC_RATEVHTSS4MCS2		0x4C
+#define DESC_RATEVHTSS4MCS3		0x4D
+#define DESC_RATEVHTSS4MCS4		0x4E
+#define DESC_RATEVHTSS4MCS5		0x4F
+#define DESC_RATEVHTSS4MCS6		0x50
+#define DESC_RATEVHTSS4MCS7		0x51
+#define DESC_RATEVHTSS4MCS8		0x52
+#define DESC_RATEVHTSS4MCS9		0x53
+
+#define HDATA_RATE(rate)\
+	(rate == DESC_RATE1M) ? "CCK_1M" :\
+	(rate == DESC_RATE2M) ? "CCK_2M" :\
+	(rate == DESC_RATE5_5M) ? "CCK5_5M" :\
+	(rate == DESC_RATE11M) ? "CCK_11M" :\
+	(rate == DESC_RATE6M) ? "OFDM_6M" :\
+	(rate == DESC_RATE9M) ? "OFDM_9M" :\
+	(rate == DESC_RATE12M) ? "OFDM_12M" :\
+	(rate == DESC_RATE18M) ? "OFDM_18M" :\
+	(rate == DESC_RATE24M) ? "OFDM_24M" :\
+	(rate == DESC_RATE36M) ? "OFDM_36M" :\
+	(rate == DESC_RATE48M) ? "OFDM_48M" :\
+	(rate == DESC_RATE54M) ? "OFDM_54M" :\
+	(rate == DESC_RATEMCS0) ? "MCS0" :\
+	(rate == DESC_RATEMCS1) ? "MCS1" :\
+	(rate == DESC_RATEMCS2) ? "MCS2" :\
+	(rate == DESC_RATEMCS3) ? "MCS3" :\
+	(rate == DESC_RATEMCS4) ? "MCS4" :\
+	(rate == DESC_RATEMCS5) ? "MCS5" :\
+	(rate == DESC_RATEMCS6) ? "MCS6" :\
+	(rate == DESC_RATEMCS7) ? "MCS7" :\
+	(rate == DESC_RATEMCS8) ? "MCS8" :\
+	(rate == DESC_RATEMCS9) ? "MCS9" :\
+	(rate == DESC_RATEMCS10) ? "MCS10" :\
+	(rate == DESC_RATEMCS11) ? "MCS11" :\
+	(rate == DESC_RATEMCS12) ? "MCS12" :\
+	(rate == DESC_RATEMCS13) ? "MCS13" :\
+	(rate == DESC_RATEMCS14) ? "MCS14" :\
+	(rate == DESC_RATEMCS15) ? "MCS15" :\
+	(rate == DESC_RATEMCS16) ? "MCS16" :\
+	(rate == DESC_RATEMCS17) ? "MCS17" :\
+	(rate == DESC_RATEMCS18) ? "MCS18" :\
+	(rate == DESC_RATEMCS19) ? "MCS19" :\
+	(rate == DESC_RATEMCS20) ? "MCS20" :\
+	(rate == DESC_RATEMCS21) ? "MCS21" :\
+	(rate == DESC_RATEMCS22) ? "MCS22" :\
+	(rate == DESC_RATEMCS23) ? "MCS23" :\
+	(rate == DESC_RATEVHTSS1MCS0) ? "VHTSS1MCS0" :\
+	(rate == DESC_RATEVHTSS1MCS1) ? "VHTSS1MCS1" :\
+	(rate == DESC_RATEVHTSS1MCS2) ? "VHTSS1MCS2" :\
+	(rate == DESC_RATEVHTSS1MCS3) ? "VHTSS1MCS3" :\
+	(rate == DESC_RATEVHTSS1MCS4) ? "VHTSS1MCS4" :\
+	(rate == DESC_RATEVHTSS1MCS5) ? "VHTSS1MCS5" :\
+	(rate == DESC_RATEVHTSS1MCS6) ? "VHTSS1MCS6" :\
+	(rate == DESC_RATEVHTSS1MCS7) ? "VHTSS1MCS7" :\
+	(rate == DESC_RATEVHTSS1MCS8) ? "VHTSS1MCS8" :\
+	(rate == DESC_RATEVHTSS1MCS9) ? "VHTSS1MCS9" :\
+	(rate == DESC_RATEVHTSS2MCS0) ? "VHTSS2MCS0" :\
+	(rate == DESC_RATEVHTSS2MCS1) ? "VHTSS2MCS1" :\
+	(rate == DESC_RATEVHTSS2MCS2) ? "VHTSS2MCS2" :\
+	(rate == DESC_RATEVHTSS2MCS3) ? "VHTSS2MCS3" :\
+	(rate == DESC_RATEVHTSS2MCS4) ? "VHTSS2MCS4" :\
+	(rate == DESC_RATEVHTSS2MCS5) ? "VHTSS2MCS5" :\
+	(rate == DESC_RATEVHTSS2MCS6) ? "VHTSS2MCS6" :\
+	(rate == DESC_RATEVHTSS2MCS7) ? "VHTSS2MCS7" :\
+	(rate == DESC_RATEVHTSS2MCS8) ? "VHTSS2MCS8" :\
+	(rate == DESC_RATEVHTSS2MCS9) ? "VHTSS2MCS9" :\
+	(rate == DESC_RATEVHTSS3MCS0) ? "VHTSS3MCS0" :\
+	(rate == DESC_RATEVHTSS3MCS1) ? "VHTSS3MCS1" :\
+	(rate == DESC_RATEVHTSS3MCS2) ? "VHTSS3MCS2" :\
+	(rate == DESC_RATEVHTSS3MCS3) ? "VHTSS3MCS3" :\
+	(rate == DESC_RATEVHTSS3MCS4) ? "VHTSS3MCS4" :\
+	(rate == DESC_RATEVHTSS3MCS5) ? "VHTSS3MCS5" :\
+	(rate == DESC_RATEVHTSS3MCS6) ? "VHTSS3MCS6" :\
+	(rate == DESC_RATEVHTSS3MCS7) ? "VHTSS3MCS7" :\
+	(rate == DESC_RATEVHTSS3MCS8) ? "VHTSS3MCS8" :\
+	(rate == DESC_RATEVHTSS3MCS9) ? "VHTSS3MCS9" : "UNKNOWN"
+
+enum {
+	UP_LINK,
+	DOWN_LINK,
+};
+typedef enum _RT_MEDIA_STATUS {
+	RT_MEDIA_DISCONNECT = 0,
+	RT_MEDIA_CONNECT       = 1
+} RT_MEDIA_STATUS;
+
+#define MAX_DLFW_PAGE_SIZE			4096	/* @ page : 4k bytes */
+typedef enum _FIRMWARE_SOURCE {
+	FW_SOURCE_IMG_FILE = 0,
+	FW_SOURCE_HEADER_FILE = 1,		/* from header file */
+} FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;
+
+typedef enum _CH_SW_USE_CASE {
+	CH_SW_USE_CASE_TDLS		= 0,
+	CH_SW_USE_CASE_MCC		= 1
+} CH_SW_USE_CASE;
+
+typedef enum _WAKEUP_REASON{
+	RX_PAIRWISEKEY					= 0x01,
+	RX_GTK							= 0x02,
+	RX_FOURWAY_HANDSHAKE			= 0x03,
+	RX_DISASSOC						= 0x04,
+	RX_DEAUTH						= 0x08,
+	RX_ARP_REQUEST					= 0x09,
+	FW_DECISION_DISCONNECT			= 0x10,
+	RX_MAGIC_PKT					= 0x21,
+	RX_UNICAST_PKT					= 0x22,
+	RX_PATTERN_PKT					= 0x23,
+	RTD3_SSID_MATCH					= 0x24,
+	RX_REALWOW_V2_WAKEUP_PKT		= 0x30,
+	RX_REALWOW_V2_ACK_LOST			= 0x31,
+	ENABLE_FAIL_DMA_IDLE			= 0x40,
+	ENABLE_FAIL_DMA_PAUSE			= 0x41,
+	RTIME_FAIL_DMA_IDLE				= 0x42,
+	RTIME_FAIL_DMA_PAUSE			= 0x43,
+	RX_PNO							= 0x55,
+	AP_OFFLOAD_WAKEUP				= 0x66,
+	CLK_32K_UNLOCK					= 0xFD,
+	CLK_32K_LOCK					= 0xFE
+}WAKEUP_REASON;
+
+/*
+ * Queue Select Value in TxDesc
+ *   */
+#define QSLT_BK							0x2/* 0x01 */
+#define QSLT_BE							0x0
+#define QSLT_VI							0x5/* 0x4 */
+#define QSLT_VO							0x7/* 0x6 */
+#define QSLT_BEACON						0x10
+#define QSLT_HIGH						0x11
+#define QSLT_MGNT						0x12
+#define QSLT_CMD						0x13
+
+/* BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
+ * #define MAX_TX_QUEUE		9 */
+
+#define TX_SELE_HQ			BIT(0)		/* High Queue */
+#define TX_SELE_LQ			BIT(1)		/* Low Queue */
+#define TX_SELE_NQ			BIT(2)		/* Normal Queue */
+#define TX_SELE_EQ			BIT(3)		/* Extern Queue */
+
+#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len) & 0x7F ? 1 : 0))
+#define PageNum_256(_Len)		(u32)(((_Len)>>8) + ((_Len) & 0xFF ? 1 : 0))
+#define PageNum_512(_Len)		(u32)(((_Len)>>9) + ((_Len) & 0x1FF ? 1 : 0))
+#define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1 : 0))
+
+struct dbg_rx_counter {
+	u32	rx_pkt_ok;
+	u32	rx_pkt_crc_error;
+	u32	rx_pkt_drop;
+	u32	rx_ofdm_fa;
+	u32	rx_cck_fa;
+	u32	rx_ht_fa;
+};
+
+#ifdef CONFIG_MBSSID_CAM
+	#define DBG_MBID_CAM_DUMP
+
+	void rtw_mbid_cam_init(struct dvobj_priv *dvobj);
+	void rtw_mbid_cam_deinit(struct dvobj_priv *dvobj);
+	void rtw_mbid_cam_reset(_adapter *adapter);
+	u8 rtw_get_max_mbid_cam_id(_adapter *adapter);
+	u8 rtw_get_mbid_cam_entry_num(_adapter *adapter);
+	int rtw_mbid_cam_cache_dump(void *sel, const char *fun_name , _adapter *adapter);
+	int rtw_mbid_cam_dump(void *sel, const char *fun_name, _adapter *adapter);
+	void rtw_mbid_cam_restore(_adapter *adapter);
+#endif
+
+#ifdef CONFIG_MI_WITH_MBSSID_CAM
+	void rtw_hal_set_macaddr_mbid(_adapter *adapter, u8 *mac_addr);
+	void rtw_hal_change_macaddr_mbid(_adapter *adapter, u8 *mac_addr);
+#endif
+
+void rtw_dump_mac_rx_counters(_adapter *padapter, struct dbg_rx_counter *rx_counter);
+void rtw_dump_phy_rx_counters(_adapter *padapter, struct dbg_rx_counter *rx_counter);
+void rtw_reset_mac_rx_counters(_adapter *padapter);
+void rtw_reset_phy_rx_counters(_adapter *padapter);
+void rtw_reset_phy_trx_ok_counters(_adapter *padapter);
+
+#ifdef DBG_RX_COUNTER_DUMP
+	#define DUMP_DRV_RX_COUNTER	BIT0
+	#define DUMP_MAC_RX_COUNTER	BIT1
+	#define DUMP_PHY_RX_COUNTER	BIT2
+	#define DUMP_DRV_TRX_COUNTER_DATA	BIT3
+
+	void rtw_dump_phy_rxcnts_preprocess(_adapter *padapter, u8 rx_cnt_mode);
+	void rtw_dump_rx_counters(_adapter *padapter);
+#endif
+
+void dump_chip_info(HAL_VERSION	ChipVersion);
+void rtw_hal_config_rftype(PADAPTER  padapter);
+
+#define BAND_CAP_2G			BIT0
+#define BAND_CAP_5G			BIT1
+#define BAND_CAP_BIT_NUM	2
+
+#define BW_CAP_5M		BIT0
+#define BW_CAP_10M		BIT1
+#define BW_CAP_20M		BIT2
+#define BW_CAP_40M		BIT3
+#define BW_CAP_80M		BIT4
+#define BW_CAP_160M		BIT5
+#define BW_CAP_80_80M	BIT6
+#define BW_CAP_BIT_NUM	7
+
+#define PROTO_CAP_11B		BIT0
+#define PROTO_CAP_11G		BIT1
+#define PROTO_CAP_11N		BIT2
+#define PROTO_CAP_11AC		BIT3
+#define PROTO_CAP_BIT_NUM	4
+
+#define WL_FUNC_P2P			BIT0
+#define WL_FUNC_MIRACAST	BIT1
+#define WL_FUNC_TDLS		BIT2
+#define WL_FUNC_FTM			BIT3
+#define WL_FUNC_BIT_NUM		4
+
+#define TBTT_PROBIHIT_HOLD_TIME 0x80
+
+int hal_spec_init(_adapter *adapter);
+void dump_hal_spec(void *sel, _adapter *adapter);
+
+bool hal_chk_band_cap(_adapter *adapter, u8 cap);
+bool hal_chk_bw_cap(_adapter *adapter, u8 cap);
+bool hal_chk_proto_cap(_adapter *adapter, u8 cap);
+bool hal_is_band_support(_adapter *adapter, u8 band);
+bool hal_is_bw_support(_adapter *adapter, u8 bw);
+bool hal_is_wireless_mode_support(_adapter *adapter, u8 mode);
+u8 hal_largest_bw(_adapter *adapter, u8 in_bw);
+
+bool hal_chk_wl_func(_adapter *adapter, u8 func);
+
+u8 hal_com_config_channel_plan(
+	PADAPTER padapter,
+	char *hw_alpha2,
+	u8 hw_chplan,
+	char *sw_alpha2,
+	u8 sw_chplan,
+	u8 def_chplan,
+	bool AutoLoadFail
+);
+
+int hal_config_macaddr(_adapter *adapter, bool autoload_fail);
+
+bool
+HAL_IsLegalChannel(
+	PADAPTER	Adapter,
+	u32			Channel
+);
+
+u8	MRateToHwRate(u8 rate);
+
+u8	hw_rate_to_m_rate(u8 rate);
+
+void	HalSetBrateCfg(
+	PADAPTER		Adapter,
+	u8			*mBratesOS,
+	u16			*pBrateCfg);
+
+bool
+Hal_MappingOutPipe(
+	PADAPTER	pAdapter,
+	u8		NumOutPipe
+);
+
+void rtw_dump_fw_info(void *sel, _adapter *adapter);
+void rtw_restore_mac_addr(_adapter *adapter);/*set mac addr when hal_init for all iface*/
+void rtw_hal_dump_macaddr(void *sel, _adapter *adapter);
+
+void rtw_init_hal_com_default_value(PADAPTER Adapter);
+
+#ifdef CONFIG_FW_C2H_REG
+void c2h_evt_clear(_adapter *adapter);
+s32 c2h_evt_read_88xx(_adapter *adapter, u8 *buf);
+#endif
+
+#ifdef CONFIG_FW_C2H_PKT
+void rtw_hal_c2h_pkt_pre_hdl(_adapter *adapter, u8 *buf, u16 len);
+void rtw_hal_c2h_pkt_hdl(_adapter *adapter, u8 *buf, u16 len);
+#endif
+
+u8  rtw_hal_networktype_to_raid(_adapter *adapter, struct sta_info *psta);
+u8 rtw_get_mgntframe_raid(_adapter *adapter, unsigned char network_type);
+void rtw_hal_update_sta_rate_mask(PADAPTER padapter, struct sta_info *psta);
+
+/* access HW only */
+u32 rtw_sec_read_cam(_adapter *adapter, u8 addr);
+void rtw_sec_write_cam(_adapter *adapter, u8 addr, u32 wdata);
+void rtw_sec_read_cam_ent(_adapter *adapter, u8 id, u8 *ctrl, u8 *mac, u8 *key);
+void rtw_sec_write_cam_ent(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void rtw_sec_clr_cam_ent(_adapter *adapter, u8 id);
+bool rtw_sec_read_cam_is_gk(_adapter *adapter, u8 id);
+
+void rtw_hal_set_msr(_adapter *adapter, u8 net_type);
+void rtw_hal_set_macaddr_port(_adapter *adapter, u8 *val);
+void rtw_hal_get_macaddr_port(_adapter *adapter, u8 *mac_addr);
+
+void rtw_hal_set_bssid(_adapter *adapter, u8 *val);
+
+void hw_var_port_switch(_adapter *adapter);
+
+void SetHwReg(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg(PADAPTER padapter, u8 variable, u8 *val);
+void rtw_hal_check_rxfifo_full(_adapter *adapter);
+void rtw_hal_reqtxrpt(_adapter *padapter, u8 macid);
+
+u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
+u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
+
+bool
+eqNByte(
+	u8	*str1,
+	u8	*str2,
+	u32	num
+);
+
+u32
+MapCharToHexDigit(
+	char	chTmp
+);
+
+bool
+GetHexValueFromString(
+		char			*szStr,
+	u32			*pu4bVal,
+	u32			*pu4bMove
+);
+
+bool
+GetFractionValueFromString(
+		char		*szStr,
+	u8			*pInteger,
+	u8			*pFraction,
+	u32		*pu4bMove
+);
+
+bool
+IsCommentString(
+		char		*szStr
+);
+
+bool
+ParseQualifiedString(
+	char *In,
+	u32 *Start,
+	char *Out,
+	char  LeftQualifier,
+	char  RightQualifier
+);
+
+bool
+GetU1ByteIntegerFromStringInDecimal(
+		char *Str,
+	u8 *pInt
+);
+
+bool
+isAllSpaceOrTab(
+	u8	*data,
+	u8	size
+);
+
+void linked_info_dump(_adapter *padapter, u8 benable);
+#ifdef DBG_RX_SIGNAL_DISPLAY_RAW_DATA
+	void rtw_get_raw_rssi_info(void *sel, _adapter *padapter);
+	void rtw_dump_raw_rssi_info(_adapter *padapter, void *sel);
+#endif
+
+#ifdef DBG_RX_DFRAME_RAW_DATA
+	void rtw_dump_rx_dframe_info(_adapter *padapter, void *sel);
+#endif
+void rtw_store_phy_info(_adapter *padapter, union recv_frame *prframe);
+#define		HWSET_MAX_SIZE			1024
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	#define		EFUSE_FILE_COLUMN_NUM		16
+	u32 Hal_readPGDataFromConfigFile(PADAPTER padapter);
+	u32 Hal_ReadMACAddrFromFile(PADAPTER padapter, u8 *mac_addr);
+#endif /* CONFIG_EFUSE_CONFIG_FILE */
+
+int check_phy_efuse_tx_power_info_valid(PADAPTER padapter);
+int hal_efuse_macaddr_offset(_adapter *adapter);
+int Hal_GetPhyEfuseMACAddr(PADAPTER padapter, u8 *mac_addr);
+void rtw_dump_cur_efuse(PADAPTER padapter);
+
+#ifdef CONFIG_RF_POWER_TRIM
+	void rtw_bb_rf_gain_offset(_adapter *padapter);
+#endif /*CONFIG_RF_POWER_TRIM*/
+
+void dm_DynamicUsbTxAgg(_adapter *padapter, u8 from_timer);
+u8 rtw_hal_busagg_qsel_check(_adapter *padapter, u8 pre_qsel, u8 next_qsel);
+void GetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	void *					pValue1,
+	void *					pValue2);
+void SetHalODMVar(
+	PADAPTER				Adapter,
+	HAL_ODM_VARIABLE		eVariable,
+	void *					pValue1,
+	bool					bSet);
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+struct noise_info {
+	u8		bPauseDIG;
+	u8		IGIValue;
+	u32 	max_time;/* ms	 */
+	u8		chan;
+};
+#endif
+
+void rtw_get_noise(_adapter *padapter);
+u8 rtw_get_current_tx_rate(_adapter *padapter, u8 macid);
+u8 rtw_get_current_tx_sgi(_adapter *padapter, u8 macid);
+void rtw_hal_construct_NullFunctionData(PADAPTER, u8 *pframe, u32 *pLength, u8 *StaAddr, u8 bQoS, u8 AC, u8 bEosp, u8 bForcePowerSave);
+
+void rtw_hal_set_fw_rsvd_page(_adapter *adapter, bool finished);
+
+#ifdef CONFIG_TDLS
+	#ifdef CONFIG_TDLS_CH_SW
+		s32 rtw_hal_ch_sw_oper_offload(_adapter *padapter, u8 channel, u8 channel_offset, u16 bwmode);
+	#endif
+#endif
+#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
+s32 rtw_hal_set_wifi_port_id_cmd(_adapter *adapter);
+#endif
+
+#ifdef CONFIG_GPIO_API
+	u8 rtw_hal_get_gpio(_adapter *adapter, u8 gpio_num);
+	int rtw_hal_set_gpio_output_value(_adapter *adapter, u8 gpio_num, bool isHigh);
+	int rtw_hal_config_gpio(_adapter *adapter, u8 gpio_num, bool isOutput);
+	int rtw_hal_register_gpio_interrupt(_adapter *adapter, int gpio_num, void(*callback)(u8 level));
+	int rtw_hal_disable_gpio_interrupt(_adapter *adapter, int gpio_num);
+#endif
+
+s8 rtw_hal_ch_sw_iqk_info_search(_adapter *padapter, u8 central_chnl, u8 bw_mode);
+void rtw_hal_ch_sw_iqk_info_backup(_adapter *adapter);
+void rtw_hal_ch_sw_iqk_info_restore(_adapter *padapter, u8 ch_sw_use_case);
+
+#ifdef CONFIG_GPIO_WAKEUP
+	void rtw_hal_switch_gpio_wl_ctrl(_adapter *padapter, u8 index, u8 enable);
+	void rtw_hal_set_output_gpio(_adapter *padapter, u8 index, u8 outputval);
+#endif
+
+typedef enum _HAL_PHYDM_OPS {
+	HAL_PHYDM_DIS_ALL_FUNC,
+	HAL_PHYDM_FUNC_SET,
+	HAL_PHYDM_FUNC_CLR,
+	HAL_PHYDM_ABILITY_BK,
+	HAL_PHYDM_ABILITY_RESTORE,
+	HAL_PHYDM_ABILITY_SET,
+	HAL_PHYDM_ABILITY_GET,
+} HAL_PHYDM_OPS;
+
+
+#define DYNAMIC_FUNC_DISABLE		(0x0)
+u32 rtw_phydm_ability_ops(_adapter *adapter, HAL_PHYDM_OPS ops, u32 ability);
+
+#define rtw_phydm_func_disable_all(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0)
+
+#define rtw_phydm_func_for_offchannel(adapter) \
+	do { \
+		rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0); \
+		if (rtw_odm_adaptivity_needed(adapter)) \
+			rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ADAPTIVITY); \
+	} while (0)
+
+#define rtw_phydm_func_set(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ability)
+
+#define rtw_phydm_func_clr(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_CLR, ability)
+
+#define rtw_phydm_ability_backup(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_BK, 0)
+
+#define rtw_phydm_ability_restore(adapter)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_RESTORE, 0)
+
+#define rtw_phydm_ability_set(adapter, ability)	\
+	rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_SET, ability)
+
+static inline u32 rtw_phydm_ability_get(_adapter *adapter)
+{
+	return rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_GET, 0);
+}
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	extern char *rtw_phy_file_path;
+	extern char rtw_phy_para_file_path[PATH_LENGTH_MAX];
+	#define GetLineFromBuffer(buffer)   strsep(&buffer, "\r\n")
+#endif
+
+void update_IOT_info(_adapter *padapter);
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	void rtw_acs_start(_adapter *padapter, bool bStart);
+#endif
+
+void hal_set_crystal_cap(_adapter *adapter, u8 crystal_cap);
+void rtw_hal_correct_tsf(_adapter *padapter, u8 hw_port, u64 tsf);
+
+void ResumeTxBeacon(_adapter *padapter);
+void StopTxBeacon(_adapter *padapter);
+#ifdef CONFIG_MI_WITH_MBSSID_CAM /*HW port0 - MBSS*/
+	void hw_var_set_opmode_mbid(_adapter *Adapter, u8 mode);
+	u8 rtw_mbid_camid_alloc(_adapter *adapter, u8 *mac_addr);
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	u8	rtw_hal_antdiv_before_linked(_adapter *padapter);
+	void	rtw_hal_antdiv_rssi_compared(_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src);
+#endif
+
+#ifdef DBG_SEC_CAM_MOVE
+	void rtw_hal_move_sta_gk_to_dk(_adapter *adapter);
+	void rtw_hal_read_sta_dk_key(_adapter *adapter, u8 key_id);
+#endif
+
+#ifdef CONFIG_LPS_PG
+#define LPSPG_RSVD_PAGE_SET_MACID(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 0, 8, _value)/*used macid*/
+#define LPSPG_RSVD_PAGE_SET_MBSSCAMID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 8, 8, _value)/*used BSSID CAM entry*/
+#define LPSPG_RSVD_PAGE_SET_PMC_NUM(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 16, 8, _value)/*Max used Pattern Match CAM entry*/
+#define LPSPG_RSVD_PAGE_SET_MU_RAID_GID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 24, 8, _value)/*Max MU rate table Group ID*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 0, 8, _value)/*used Security CAM entry number*/
+#define LPSPG_RSVD_PAGE_SET_DRV_RSVDPAGE_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 8, 8, _value)/*Txbuf used page number for fw offload*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID1(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 0, 8, _value)/*used Security CAM entry -1*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID2(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 8, 8, _value)/*used Security CAM entry -2*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID3(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 16, 8, _value)/*used Security CAM entry -3*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID4(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 24, 8, _value)/*used Security CAM entry -4*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID5(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 0, 8, _value)/*used Security CAM entry -5*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID6(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 8, 8, _value)/*used Security CAM entry -6*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID7(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 16, 8, _value)/*used Security CAM entry -7*/
+#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID8(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 24, 8, _value)/*used Security CAM entry -8*/
+enum lps_pg_hdl_id {
+	LPS_PG_INFO_CFG = 0,
+	LPS_PG_REDLEMEM,
+	LPS_PG_RESEND_H2C,
+};
+
+	u8 rtw_hal_set_lps_pg_info(_adapter *adapter);
+#endif
+
+int rtw_hal_get_rsvd_page(_adapter *adapter, u32 page_offset, u32 page_num, u8 *buffer, u32 buffer_size);
+
+#ifdef CONFIG_WOWLAN
+struct rtl_wow_pattern {
+	u16	crc;
+	u8	type;
+	u32	mask[4];
+};
+void rtw_wow_pattern_cam_dump(_adapter *adapter);
+
+#ifdef CONFIG_WOW_PATTERN_HW_CAM
+void rtw_wow_pattern_read_cam_ent(_adapter *adapter, u8 id, struct  rtl_wow_pattern *context);
+void rtw_dump_wow_pattern(void *sel, struct rtl_wow_pattern *pwow_pattern, u8 idx);
+#endif
+#endif
+void rtw_dump_phy_cap(void *sel, _adapter *adapter);
+void rtw_dump_rsvd_page(void *sel, _adapter *adapter, u8 page_offset, u8 page_num);
+
+#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+s32 rtw_hal_set_default_port_id_cmd(_adapter *adapter, u8 mac_id);
+s32 rtw_set_default_port_id(_adapter *adapter);
+s32 rtw_set_ps_rsvd_page(_adapter *adapter);
+#endif
+
+#endif /* __HAL_COMMON_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_com_h2c.h b/drivers/staging/rtl8188eu/include/hal_com_h2c.h
new file mode 100644
index 000000000000..156812274ca8
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_com_h2c.h
@@ -0,0 +1,535 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __COMMON_H2C_H__
+#define __COMMON_H2C_H__
+
+/* ---------------------------------------------------------------------------------------------------------
+ * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
+ * ---------------------------------------------------------------------------------------------------------
+ * 88e, 8723b, 8812, 8821, 92e use the same FW code base */
+enum h2c_cmd {
+	/* Common Class: 000 */
+	H2C_RSVD_PAGE = 0x00,
+	H2C_MEDIA_STATUS_RPT = 0x01,
+	H2C_SCAN_ENABLE = 0x02,
+	H2C_KEEP_ALIVE = 0x03,
+	H2C_DISCON_DECISION = 0x04,
+	H2C_PSD_OFFLOAD = 0x05,
+	H2C_CUSTOMER_STR_REQ = 0x06,
+	H2C_AP_OFFLOAD = 0x08,
+	H2C_BCN_RSVDPAGE = 0x09,
+	H2C_PROBERSP_RSVDPAGE = 0x0A,
+	H2C_FCS_RSVDPAGE = 0x10,
+	H2C_FCS_INFO = 0x11,
+	H2C_AP_WOW_GPIO_CTRL = 0x13,
+#ifdef CONFIG_MCC_MODE
+	H2C_MCC_UPDATE_PARAM = 0x15,
+	H2C_MCC_MACID_BITMAP = 0x16,
+	H2C_MCC_LOCATION = 0x10,
+	H2C_MCC_CTRL = 0x18,
+	H2C_MCC_NOA_PARAM = 0x19,
+	H2C_MCC_IQK_PARAM = 0x1A,
+#endif /* CONFIG_MCC_MODE */
+	H2C_CHNL_SWITCH_OPER_OFFLOAD = 0x1C,
+
+	/* PoweSave Class: 001 */
+	H2C_SET_PWR_MODE = 0x20,
+	H2C_PS_TUNING_PARA = 0x21,
+	H2C_PS_TUNING_PARA2 = 0x22,
+	H2C_P2P_LPS_PARAM = 0x23,
+	H2C_P2P_PS_OFFLOAD = 0x24,
+	H2C_PS_SCAN_ENABLE = 0x25,
+	H2C_SAP_PS_ = 0x26,
+	H2C_INACTIVE_PS_ = 0x27, /* Inactive_PS */
+	H2C_FWLPS_IN_IPS_ = 0x28,
+#ifdef CONFIG_LPS_POFF
+	H2C_LPS_POFF_CTRL = 0x29,
+	H2C_LPS_POFF_PARAM = 0x2A,
+#endif
+#ifdef CONFIG_LPS_PG
+	H2C_LPS_PG_INFO = 0x2B,
+#endif
+
+#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+	H2C_DEFAULT_PORT_ID = 0x2C,
+#endif
+	/* Dynamic Mechanism Class: 010 */
+	H2C_MACID_CFG = 0x40,
+	H2C_TXBF = 0x41,
+	H2C_RSSI_SETTING = 0x42,
+	H2C_AP_REQ_TXRPT = 0x43,
+	H2C_INIT_RATE_COLLECT = 0x44,
+	H2C_IQ_CALIBRATION	= 0x45,
+
+	H2C_RA_MASK_3SS = 0x46,/* for 8814A */
+	H2C_RA_PARA_ADJUST = 0x47,/* CONFIG_RA_DBG_CMD */
+	H2C_DYNAMIC_TX_PATH = 0x48,/* for 8814A */
+
+	H2C_FW_TRACE_EN = 0x49,
+
+	/* BT Class: 011 */
+	H2C_B_TYPE_TDMA = 0x60,
+	H2C_BT_INFO = 0x61,
+	H2C_FORCE_BT_TXPWR = 0x62,
+	H2C_BT_IGNORE_WLANACT = 0x63,
+	H2C_DAC_SWING_VALUE = 0x64,
+	H2C_ANT_SEL_RSV = 0x65,
+	H2C_WL_OPMODE = 0x66,
+	H2C_BT_MP_OPER = 0x67,
+	H2C_BT_CONTROL = 0x68,
+	H2C_BT_WIFI_CTRL = 0x69,
+	H2C_BT_FW_PATCH = 0x6A,
+#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
+	H2C_BTC_WL_PORT_ID = 0x71,
+#endif
+	/* WOWLAN Class: 100 */
+	H2C_WOWLAN = 0x80,
+	H2C_REMOTE_WAKE_CTRL = 0x81,
+	H2C_AOAC_GLOBAL_INFO = 0x82,
+	H2C_AOAC_RSVD_PAGE = 0x83,
+	H2C_AOAC_RSVD_PAGE2 = 0x84,
+	H2C_D0_SCAN_OFFLOAD_CTRL = 0x85,
+	H2C_D0_SCAN_OFFLOAD_INFO = 0x86,
+	H2C_CHNL_SWITCH_OFFLOAD = 0x87,
+	H2C_AOAC_RSVDPAGE3 = 0x88,
+	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
+	H2C_P2P_OFFLOAD = 0x8B,
+
+	H2C_RESET_TSF = 0xC0,
+	H2C_BCNHWSEQ = 0xC5,
+	H2C_CUSTOMER_STR_W1 = 0xC6,
+	H2C_CUSTOMER_STR_W2 = 0xC7,
+	H2C_CUSTOMER_STR_W3 = 0xC8,
+	H2C_MAXID,
+};
+
+#define H2C_INACTIVE_PS_LEN		3
+#define H2C_RSVDPAGE_LOC_LEN		5
+#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+#define H2C_DEFAULT_PORT_ID_LEN		2
+#define H2C_MEDIA_STATUS_RPT_LEN		4
+#else
+#define H2C_MEDIA_STATUS_RPT_LEN		3
+#endif
+#define H2C_KEEP_ALIVE_CTRL_LEN	2
+#define H2C_DISCON_DECISION_LEN		3
+#define H2C_AP_OFFLOAD_LEN		3
+#define H2C_AP_WOW_GPIO_CTRL_LEN	4
+#define H2C_AP_PS_LEN			2
+#define H2C_PWRMODE_LEN			7
+#define H2C_PSTUNEPARAM_LEN			4
+#define H2C_MACID_CFG_LEN		7
+#define H2C_BTMP_OPER_LEN			5
+#define H2C_WOWLAN_LEN			5
+#define H2C_REMOTE_WAKE_CTRL_LEN	3
+#define H2C_AOAC_GLOBAL_INFO_LEN	2
+#define H2C_AOAC_RSVDPAGE_LOC_LEN	7
+#define H2C_SCAN_OFFLOAD_CTRL_LEN	4
+#define H2C_BT_FW_PATCH_LEN			6
+#define H2C_RSSI_SETTING_LEN		4
+#define H2C_AP_REQ_TXRPT_LEN		3
+#define H2C_FORCE_BT_TXPWR_LEN		3
+#define H2C_BCN_RSVDPAGE_LEN		5
+#define H2C_PROBERSP_RSVDPAGE_LEN	5
+#define H2C_P2PRSVDPAGE_LOC_LEN	5
+#define H2C_P2P_OFFLOAD_LEN	3
+#ifdef CONFIG_MCC_MODE
+	#define H2C_MCC_CTRL_LEN			7
+	#define H2C_MCC_LOCATION_LEN		3
+	#define H2C_MCC_MACID_BITMAP_LEN	6
+	#define H2C_MCC_UPDATE_INFO_LEN		4
+	#define H2C_MCC_NOA_PARAM_LEN		4
+	#define H2C_MCC_IQK_PARAM_LEN		7
+#endif /* CONFIG_MCC_MODE */
+#ifdef CONFIG_LPS_PG
+	#define H2C_LPS_PG_INFO_LEN		2
+	#define H2C_LPSPG_LEN			16
+#endif
+#ifdef CONFIG_LPS_POFF
+	#define H2C_LPS_POFF_CTRL_LEN		1
+	#define H2C_LPS_POFF_PARAM_LEN		5
+#endif
+
+#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
+#define H2C_BTC_WL_PORT_ID_LEN	1
+#endif
+#define eq_mac_addr(a, b)						(((a)[0] == (b)[0] && (a)[1] == (b)[1] && (a)[2] == (b)[2] && (a)[3] == (b)[3] && (a)[4] == (b)[4] && (a)[5] == (b)[5]) ? 1 : 0)
+#define cp_mac_addr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3], (des)[4] = (src)[4], (des)[5] = (src)[5])
+#define cpIpAddr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3])
+
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+/*
+* ARP packet
+*
+* LLC Header */
+#define GET_ARP_PKT_LLC_TYPE(__pHeader)					ReadLE2Byte(((u8 *)(__pHeader)) + 6)
+
+/* ARP element */
+#define GET_ARP_PKT_OPERATION(__pHeader)				ReadLE2Byte(((u8 *)(__pHeader)) + 6)
+#define GET_ARP_PKT_SENDER_MAC_ADDR(__pHeader, _val)	cp_mac_addr((u8 *)(_val), ((u8 *)(__pHeader))+8)
+#define GET_ARP_PKT_SENDER_IP_ADDR(__pHeader, _val)		cpIpAddr((u8 *)(_val), ((u8 *)(__pHeader))+14)
+#define GET_ARP_PKT_TARGET_MAC_ADDR(__pHeader, _val)	cp_mac_addr((u8 *)(_val), ((u8 *)(__pHeader))+18)
+#define GET_ARP_PKT_TARGET_IP_ADDR(__pHeader, _val)	cpIpAddr((u8 *)(_val), ((u8 *)(__pHeader))+24)
+
+#define SET_ARP_PKT_HW(__pHeader, __Value)					WriteLE2Byte(((u8 *)(__pHeader)) + 0, __Value)
+#define SET_ARP_PKT_PROTOCOL(__pHeader, __Value)			WriteLE2Byte(((u8 *)(__pHeader)) + 2, __Value)
+#define SET_ARP_PKT_HW_ADDR_LEN(__pHeader, __Value)			WriteLE1Byte(((u8 *)(__pHeader)) + 4, __Value)
+#define SET_ARP_PKT_PROTOCOL_ADDR_LEN(__pHeader, __Value)	WriteLE1Byte(((u8 *)(__pHeader)) + 5, __Value)
+#define SET_ARP_PKT_OPERATION(__pHeader, __Value)			WriteLE2Byte(((u8 *)(__pHeader)) + 6, __Value)
+#define SET_ARP_PKT_SENDER_MAC_ADDR(__pHeader, _val)	cp_mac_addr(((u8 *)(__pHeader))+8, (u8 *)(_val))
+#define SET_ARP_PKT_SENDER_IP_ADDR(__pHeader, _val)		cpIpAddr(((u8 *)(__pHeader))+14, (u8 *)(_val))
+#define SET_ARP_PKT_TARGET_MAC_ADDR(__pHeader, _val)	cp_mac_addr(((u8 *)(__pHeader))+18, (u8 *)(_val))
+#define SET_ARP_PKT_TARGET_IP_ADDR(__pHeader, _val)		cpIpAddr(((u8 *)(__pHeader))+24, (u8 *)(_val))
+
+#define FW_WOWLAN_FUN_EN				BIT(0)
+#define FW_WOWLAN_PATTERN_MATCH			BIT(1)
+#define FW_WOWLAN_MAGIC_PKT				BIT(2)
+#define FW_WOWLAN_UNICAST				BIT(3)
+#define FW_WOWLAN_ALL_PKT_DROP			BIT(4)
+#define FW_WOWLAN_GPIO_ACTIVE			BIT(5)
+#define FW_WOWLAN_REKEY_WAKEUP			BIT(6)
+#define FW_WOWLAN_DEAUTH_WAKEUP			BIT(7)
+
+#define FW_WOWLAN_GPIO_WAKEUP_EN		BIT(0)
+#define FW_FW_PARSE_MAGIC_PKT			BIT(1)
+
+#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
+#define FW_REALWOWLAN_EN				BIT(5)
+
+#define FW_WOWLAN_KEEP_ALIVE_EN			BIT(0)
+#define FW_ADOPT_USER					BIT(1)
+#define FW_WOWLAN_KEEP_ALIVE_PKT_TYPE	BIT(2)
+
+#define FW_REMOTE_WAKE_CTRL_EN			BIT(0)
+#define FW_ARP_EN						BIT(1)
+#define FW_REALWOWLAN_EN				BIT(5)
+#define FW_WOW_FW_UNICAST_EN			BIT(7)
+
+#endif /* CONFIG_WOWLAN */
+
+/* _RSVDPAGE_LOC_CMD_0x00 */
+#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+/* _MEDIA_STATUS_RPT_PARM_CMD_0x01 */
+#define SET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 1, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 2, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 3, 1, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 4, 4, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 2, 0, 8, (__Value))
+#define SET_H2CCMD_MSRRPT_PARM_PORT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 3, 0, 3, (__Value))
+
+#define GET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 0, 1)
+#define GET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 2, 1)
+#define GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd)	LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 3, 1)
+#define GET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd)			LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 4, 4)
+
+#define H2C_MSR_ROLE_RSVD	0
+#define H2C_MSR_ROLE_STA	1
+#define H2C_MSR_ROLE_AP		2
+#define H2C_MSR_ROLE_GC		3
+#define H2C_MSR_ROLE_GO		4
+#define H2C_MSR_ROLE_TDLS	5
+#define H2C_MSR_ROLE_ADHOC	6
+#define H2C_MSR_ROLE_MAX	7
+
+extern const char *const _h2c_msr_role_str[];
+#define h2c_msr_role_str(role) (((role) >= H2C_MSR_ROLE_MAX) ? _h2c_msr_role_str[H2C_MSR_ROLE_MAX] : _h2c_msr_role_str[(role)])
+
+#define H2C_MSR_FMT "%s %s%s"
+#define H2C_MSR_ARG(h2c_msr) \
+	GET_H2CCMD_MSRRPT_PARM_OPMODE((h2c_msr)) ? " C" : "", \
+	h2c_msr_role_str(GET_H2CCMD_MSRRPT_PARM_ROLE((h2c_msr))), \
+	GET_H2CCMD_MSRRPT_PARM_MIRACAST((h2c_msr)) ? (GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK((h2c_msr)) ? " MSINK" : " MSRC") : ""
+
+s32 rtw_hal_set_FwMediaStatusRpt_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, bool macid_ind, u8 macid_end);
+s32 rtw_hal_set_FwMediaStatusRpt_single_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid);
+s32 rtw_hal_set_FwMediaStatusRpt_range_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, u8 macid_end);
+
+/* _KEEP_ALIVE_CMD_0x03 */
+#define SET_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_PORT_NUM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 3, __Value)
+#define SET_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+
+/* _DISCONNECT_DECISION_CMD_0x04 */
+#define SET_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_DISCONDECISION_PORT_NUM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 3, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+
+#ifdef CONFIG_RTW_CUSTOMER_STR
+#define RTW_CUSTOMER_STR_LEN 16
+#define RTW_CUSTOMER_STR_FMT "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x"
+#define RTW_CUSTOMER_STR_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
+	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9], ((u8 *)(x))[10], ((u8 *)(x))[11], \
+	((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15]
+
+/* H2C_CUSTOMER_STR_REQ  0x06 */
+#define H2C_CUSTOMER_STR_REQ_LEN 1
+#define SET_H2CCMD_CUSTOMER_STR_REQ_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+s32 rtw_hal_h2c_customer_str_req(_adapter *adapter);
+s32 rtw_hal_customer_str_read(_adapter *adapter, u8 *cs);
+
+/* H2C_CUSTOMER_STR_W1 0xC6 */
+#define H2C_CUSTOMER_STR_W1_LEN 7
+#define SET_H2CCMD_CUSTOMER_STR_W1_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+#define H2CCMD_CUSTOMER_STR_W1_BYTE0(__pH2CCmd)				(((u8 *)(__pH2CCmd)) + 1)
+
+/* H2C_CUSTOMER_STR_W2 0xC7 */
+#define H2C_CUSTOMER_STR_W2_LEN 7
+#define SET_H2CCMD_CUSTOMER_STR_W2_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+#define H2CCMD_CUSTOMER_STR_W2_BYTE6(__pH2CCmd)				(((u8 *)(__pH2CCmd)) + 1)
+
+/* H2C_CUSTOMER_STR_W3 0xC8 */
+#define H2C_CUSTOMER_STR_W3_LEN 5
+#define SET_H2CCMD_CUSTOMER_STR_W3_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
+#define H2CCMD_CUSTOMER_STR_W3_BYTE12(__pH2CCmd)			(((u8 *)(__pH2CCmd)) + 1)
+s32 rtw_hal_h2c_customer_str_write(_adapter *adapter, const u8 *cs);
+s32 rtw_hal_customer_str_write(_adapter *adapter, const u8 *cs);
+#endif /* CONFIG_RTW_CUSTOMER_STR */
+
+/* _AP_Offload 0x08 */
+#define SET_H2CCMD_AP_WOWLAN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+/* _BCN_RsvdPage	0x09 */
+#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+/* _Probersp_RsvdPage 0x0a */
+#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+/* _Probersp_RsvdPage 0x13 */
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_INDEX(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_PLUS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_HIGH_ACTIVE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_DURATION(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+/* _AP_PS 0x26 */
+#define SET_H2CCMD_AP_WOW_PS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_32K_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_RF(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_AP_WOW_PS_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+
+#ifdef CONFIG_LPS_POFF
+/*PARTIAL OFF Control 0x29*/
+#define SET_H2CCMD_LPS_POFF_CTRL_EN(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+/*PARTIAL OFF PARAM   0x2A*/
+#define SET_H2CCMD_LPS_POFF_PARAM_RDVLD(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_LPS_POFF_PARAM_WRVLD(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_LPS_POFF_PARAM_STARTADDL(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_H2CCMD_LPS_POFF_PARAM_STARTADDH(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+#define SET_H2CCMD_LPS_POFF_PARAM_ENDADDL(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
+#define SET_H2CCMD_LPS_POFF_PARAM_ENDADDH(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
+#endif
+
+#ifdef CONFIG_FW_MULTI_PORT_SUPPORT
+/* DEFAULT PORT ID 0x2C*/
+#define SET_H2CCMD_DFTPID_PORT_ID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 8, (__Value))
+#define SET_H2CCMD_DFTPID_MAC_ID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
+#endif
+
+#ifdef CONFIG_MCC_MODE
+/* MCC LOC CMD 0x10 */
+#define SET_H2CCMD_MCC_RSVDPAGE_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+
+/* MCC MAC ID CMD 0x16 */
+#define SET_H2CCMD_MCC_MACID_BITMAP_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_MCC_MACID_BITMAP_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+
+/* MCC INFO CMD 0x18 */
+#define SET_H2CCMD_MCC_CTRL_ORDER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#define SET_H2CCMD_MCC_CTRL_TOTALNUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
+#define SET_H2CCMD_MCC_CTRL_CHIDX(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_MCC_CTRL_BW(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 2, __Value)
+#define SET_H2CCMD_MCC_CTRL_BW40SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 2, 3, __Value)
+#define SET_H2CCMD_MCC_CTRL_BW80SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 5, 3, __Value)
+#define SET_H2CCMD_MCC_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_MCC_CTRL_ROLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 3, __Value)
+#define SET_H2CCMD_MCC_CTRL_INCURCH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 3, 1, __Value)
+#define SET_H2CCMD_MCC_CTRL_RSVD0(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 4, __Value)
+#define SET_H2CCMD_MCC_CTRL_RSVD1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+#define SET_H2CCMD_MCC_CTRL_RFETYPE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 0, 4, __Value)
+#define SET_H2CCMD_MCC_CTRL_DISTXNULL(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 4, 1, __Value)
+#define SET_H2CCMD_MCC_CTRL_C2HRPT(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 5, 2, __Value)
+#define SET_H2CCMD_MCC_CTRL_CHSCAN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 7, 1, __Value)
+
+/* MCC NoA CMD 0x19 */
+#define SET_H2CCMD_MCC_NOA_FW_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_MCC_NOA_TSF_SYNC_OFFSET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 7, __Value)
+#define SET_H2CCMD_MCC_NOA_START_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_MCC_NOA_INTERVAL(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_MCC_EARLY_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+
+/* MCC IQK CMD 0x1A */
+#define SET_H2CCMD_MCC_IQK_READY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_MCC_IQK_ORDER(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 4, __Value)
+#define SET_H2CCMD_MCC_IQK_PATH(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 2, __Value)
+#define SET_H2CCMD_MCC_IQK_RX_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_MCC_IQK_RX_M1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 2, __Value)
+#define SET_H2CCMD_MCC_IQK_RX_M2(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 2, 6, __Value)
+#define SET_H2CCMD_MCC_IQK_RX_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 4, __Value)
+#define SET_H2CCMD_MCC_IQK_TX_L(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#define SET_H2CCMD_MCC_IQK_TX_M1(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 3, __Value)
+#define SET_H2CCMD_MCC_IQK_TX_M2(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 3, 5, __Value)
+#define SET_H2CCMD_MCC_IQK_TX_H(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+6, 0, 6, __Value)
+#endif /* CONFIG_MCC_MODE */
+
+/* CHNL SWITCH OPER OFFLOAD 0x1C */
+#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_CH_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_MODE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 2, __Value)
+#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_40M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 2, 3, __Value)
+#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_80M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 5, 3, __Value)
+#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_RFE_TYPE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 2, 0, 4, __Value)
+
+#if defined(CONFIG_BT_COEXIST) && defined(CONFIG_FW_MULTI_PORT_SUPPORT)
+#define SET_H2CCMD_BTC_WL_PORT_ID(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
+#endif
+
+/* _WoWLAN PARAM_CMD_0x80 */
+#define SET_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+#define SET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 7, __Value)
+#define SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 7, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 1, 7, __Value)
+#define SET_H2CCMD_WOWLAN_LOWPR_RX(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 1, __Value)
+#define SET_H2CCMD_WOWLAN_CHANGE_UNIT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 2, 1, __Value)
+/* _REMOTE_WAKEUP_CMD_0x81 */
+#define SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_NBNS_FILTER_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 2, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_TKIP_OFFLOAD_EN(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 3, 1, __Value)
+
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 1, __Value)
+#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_PARSING_UNTIL_WAKEUP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 4, 1, __Value)
+
+/* AOAC_GLOBAL_INFO_0x82 */
+#define SET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+
+/* AOAC_RSVDPAGE_LOC_0x83 */
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NEIGHBOR_ADV(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#ifdef CONFIG_GTK_OL
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
+#endif /* CONFIG_GTK_OL */
+
+/* AOAC_RSVDPAGE_2_0x84 */
+
+/* AOAC_RSVDPAGE_3_0x88 */
+#ifdef CONFIG_PNO_SUPPORT
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
+#endif
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_AOAC_REPORT(__pH2CCmd, __Value) \
+	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 8, __Value)
+
+#ifdef CONFIG_PNO_SUPPORT
+/* D0_Scan_Offload_Info_0x86 */
+#define SET_H2CCMD_AOAC_NLO_FUN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 3, 1, __Value)
+#define SET_H2CCMD_AOAC_NLO_IPS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 4, 1, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#endif /* CONFIG_PNO_SUPPORT */
+
+#ifdef CONFIG_P2P_WOWLAN
+/* P2P_RsvdPage_0x8a */
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+#endif /* CONFIG_P2P_WOWLAN */
+
+#ifdef CONFIG_LPS_PG
+#define SET_H2CCMD_LPSPG_SEC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)/*SecurityCAM_En*/
+#define SET_H2CCMD_LPSPG_MBID_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)/*BSSIDCAM_En*/
+#define SET_H2CCMD_LPSPG_PMC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)/*PatternMatchCAM_En*/
+#define SET_H2CCMD_LPSPG_MACID_SEARCH_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)/*MACIDSearch_En*/
+#define SET_H2CCMD_LPSPG_TXSC_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)/*TXSC_En*/
+#define SET_H2CCMD_LPSPG_MU_RATE_TB_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)/*MURateTable_En*/
+#define SET_H2CCMD_LPSPG_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)/*Loc_LPS_PG*/
+#endif
+
+/* ---------------------------------------------------------------------------------------------------------
+ * -------------------------------------------    Structure    --------------------------------------------------
+ * --------------------------------------------------------------------------------------------------------- */
+typedef struct _RSVDPAGE_LOC {
+	u8 LocProbeRsp;
+	u8 LocPsPoll;
+	u8 LocNullData;
+	u8 LocQosNull;
+	u8 LocBTQosNull;
+#ifdef CONFIG_WOWLAN
+	u8 LocRemoteCtrlInfo;
+	u8 LocArpRsp;
+	u8 LocNbrAdv;
+	u8 LocGTKRsp;
+	u8 LocGTKInfo;
+	u8 LocProbeReq;
+	u8 LocNetList;
+#ifdef CONFIG_GTK_OL
+	u8 LocGTKEXTMEM;
+#endif /* CONFIG_GTK_OL */
+	u8 LocAOACReport;
+#ifdef CONFIG_PNO_SUPPORT
+	u8 LocPNOInfo;
+	u8 LocScanInfo;
+	u8 LocSSIDInfo;
+	u8 LocProbePacket;
+#endif /* CONFIG_PNO_SUPPORT */
+#endif /* CONFIG_WOWLAN	 */
+	u8 LocApOffloadBCN;
+#ifdef CONFIG_P2P_WOWLAN
+	u8 LocP2PBeacon;
+	u8 LocP2PProbeRsp;
+	u8 LocNegoRsp;
+	u8 LocInviteRsp;
+	u8 LocPDRsp;
+#endif /* CONFIG_P2P_WOWLAN */
+} RSVDPAGE_LOC, *PRSVDPAGE_LOC;
+
+#endif
+void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
+u8 rtw_hal_set_fw_media_status_cmd(_adapter *adapter, u8 mstatus, u8 macid);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	/* WOW command function */
+	void rtw_hal_set_fw_wow_related_cmd(_adapter *padapter, u8 enable);
+	#ifdef CONFIG_P2P_WOWLAN
+		/* H2C 0x8A */
+		u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter *adapter, PRSVDPAGE_LOC rsvdpageloc);
+		/* H2C 0x8B */
+		u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter *adapter);
+	#endif /* CONFIG_P2P_WOWLAN */
+#endif
diff --git a/drivers/staging/rtl8188eu/include/hal_com_led.h b/drivers/staging/rtl8188eu/include/hal_com_led.h
new file mode 100644
index 000000000000..9df983694787
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_com_led.h
@@ -0,0 +1,268 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_COMMON_LED_H_
+#define __HAL_COMMON_LED_H_
+
+
+#define MSECS(t)        (HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
+
+/* ********************************************************************************
+ *	LED Behavior Constant.
+ * ********************************************************************************
+ * Default LED behavior.
+ *   */
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+#define LED_INITIAL_INTERVAL		1800
+
+/* LED Customerization */
+
+/* NETTRONIX */
+#define LED_BLINK_NORMAL_INTERVAL_NETTRONIX	100
+#define LED_BLINK_SLOWLY_INTERVAL_NETTRONIX	2000
+
+/* PORNET */
+#define LED_BLINK_SLOWLY_INTERVAL_PORNET	1000
+#define LED_BLINK_NORMAL_INTERVAL_PORNET	100
+#define LED_BLINK_FAST_INTERVAL_BITLAND		30
+
+/* AzWave. */
+#define LED_CM2_BLINK_ON_INTERVAL		250
+#define LED_CM2_BLINK_OFF_INTERVAL		4750
+#define LED_CM8_BLINK_OFF_INTERVAL		3750	/* for QMI */
+
+/* RunTop */
+#define LED_RunTop_BLINK_INTERVAL		300
+
+/* ALPHA */
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA_500MS 500 /* add by ylb 20121012 for customer led for alpha */
+#define LED_BLINK_LINK_INTERVAL_ALPHA		500	/* 500 */
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180	/* 150 */
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+/* 111122 by hpfan: Customized for Xavi */
+#define LED_CM11_BLINK_INTERVAL			300
+#define LED_CM11_LINK_ON_INTERVEL		3000
+
+/* Netgear */
+#define LED_BLINK_LINK_INTERVAL_NETGEAR		500
+#define LED_BLINK_LINK_SLOWLY_INTERVAL_NETGEAR		1000
+
+#define LED_WPS_BLINK_OFF_INTERVAL_NETGEAR		100
+#define LED_WPS_BLINK_ON_INTERVAL_NETGEAR		500
+
+/* Belkin AC950 */
+#define LED_BLINK_LINK_INTERVAL_ON_BELKIN	200
+#define LED_BLINK_LINK_INTERVAL_OFF_BELKIN	100
+#define LED_BLINK_ERROR_INTERVAL_BELKIN		100
+
+/* by chiyokolin for Azurewave */
+#define LED_CM12_BLINK_INTERVAL_5Mbps		160
+#define LED_CM12_BLINK_INTERVAL_10Mbps		80
+#define LED_CM12_BLINK_INTERVAL_20Mbps		50
+#define LED_CM12_BLINK_INTERVAL_40Mbps		40
+#define LED_CM12_BLINK_INTERVAL_80Mbps		30
+#define LED_CM12_BLINK_INTERVAL_MAXMbps		25
+
+/* Dlink */
+#define	LED_BLINK_NO_LINK_INTERVAL		1000
+#define	LED_BLINK_LINK_IDEL_INTERVAL		100
+
+#define	LED_BLINK_SCAN_ON_INTERVAL		30
+#define	LED_BLINK_SCAN_OFF_INTERVAL		300
+
+#define LED_WPS_BLINK_ON_INTERVAL_DLINK		30
+#define LED_WPS_BLINK_OFF_INTERVAL_DLINK			300
+#define LED_WPS_BLINK_LINKED_ON_INTERVAL_DLINK			5000
+
+/* ********************************************************************************
+ * LED object.
+ * ******************************************************************************** */
+
+typedef enum _LED_CTL_MODE {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11, /* added for runtop */
+	LED_CTL_STOP_WPS_FAIL = 12, /* added for ALPHA	 */
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, /* added for BELKIN */
+	LED_CTL_CONNECTION_NO_TRANSFER = 14,
+} LED_CTL_MODE;
+
+typedef	enum _LED_STATE {
+	LED_UNKNOWN = 0,
+	RTW_LED_ON = 1,
+	RTW_LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_BLINK_POWER_ON = 5,
+	LED_BLINK_SCAN = 6,	/* LED is blinking during scanning period, the # of times to blink is depend on time for scanning. */
+	LED_BLINK_NO_LINK = 7, /* LED is blinking during no link state. */
+	LED_BLINK_StartToBlink = 8, /* Customzied for Sercomm Printer Server case */
+	LED_BLINK_TXRX = 9,
+	LED_BLINK_WPS = 10,	/* LED is blinkg during WPS communication */
+	LED_BLINK_WPS_STOP = 11,	/* for ALPHA */
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	/* for BELKIN */
+	LED_BLINK_RUNTOP = 13,	/* Customized for RunTop */
+	LED_BLINK_CAMEO = 14,
+	LED_BLINK_XAVI = 15,
+	LED_BLINK_ALWAYS_ON = 16,
+	LED_BLINK_LINK_IN_PROCESS = 17,  /* Customized for Belkin AC950 */
+	LED_BLINK_AUTH_ERROR = 18,  /* Customized for Belkin AC950 */
+	LED_BLINK_Azurewave_5Mbps = 19,
+	LED_BLINK_Azurewave_10Mbps = 20,
+	LED_BLINK_Azurewave_20Mbps = 21,
+	LED_BLINK_Azurewave_40Mbps = 22,
+	LED_BLINK_Azurewave_80Mbps = 23,
+	LED_BLINK_Azurewave_MAXMbps = 24,
+	LED_BLINK_LINK_IDEL = 25,
+	LED_BLINK_WPS_LINKED = 26,
+} LED_STATE;
+
+typedef enum _LED_PIN {
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1,
+	LED_PIN_LED2
+} LED_PIN;
+
+/* ********************************************************************************
+ * USB  LED Definition.
+ * ******************************************************************************** */
+
+#define IS_LED_WPS_BLINKING(_LED_USB)	(((PLED_USB)_LED_USB)->CurrLedState == LED_BLINK_WPS \
+		|| ((PLED_USB)_LED_USB)->CurrLedState == LED_BLINK_WPS_STOP \
+		|| ((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_USB)	(((PLED_USB)_LED_USB)->bLedWPSBlinkInProgress \
+		|| ((PLED_USB)_LED_USB)->bLedScanBlinkInProgress)
+
+
+typedef	enum _LED_STRATEGY_USB {
+	SW_LED_MODE0, /* SW control 1 LED via GPIO0. It is default option. */
+	SW_LED_MODE1, /* 2 LEDs, through LED0 and LED1. For ALPHA. */
+	SW_LED_MODE2, /* SW control 1 LED via GPIO0, customized for AzWave 8187 minicard. */
+	SW_LED_MODE3, /* SW control 1 LED via GPIO0, customized for Sercomm Printer Server case. */
+	SW_LED_MODE4, /* for Edimax / Belkin */
+	SW_LED_MODE5, /* for Sercomm / Belkin	 */
+	SW_LED_MODE6,	/* for 88CU minicard, porting from ce SW_LED_MODE7 */
+	SW_LED_MODE7,	/* for Netgear special requirement */
+	SW_LED_MODE8, /* for LC */
+	SW_LED_MODE9, /* for Belkin AC950 */
+	SW_LED_MODE10, /* for Netgear A6200V2 */
+	SW_LED_MODE11, /* for Edimax / ASUS */
+	SW_LED_MODE12, /* for WNC/NEC */
+	SW_LED_MODE13, /* for Netgear A6100, 8811Au */
+	SW_LED_MODE14, /* for Buffalo, DNI, 8811Au */
+	SW_LED_MODE15, /* for DLINK,  8811Au/8812AU	 */
+	HW_LED, /* HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.) */
+} LED_STRATEGY_USB, *PLED_STRATEGY_USB;
+
+
+typedef struct _LED_USB {
+	PADAPTER			padapter;
+
+	LED_PIN			LedPin;	/* Identify how to implement this SW led. */
+
+	LED_STATE			CurrLedState; /* Current LED state. */
+	bool				bLedOn; /* true if LED is ON, false if LED is OFF. */
+
+	bool				bSWLedCtrl;
+
+	bool				bLedBlinkInProgress; /* true if it is blinking, false o.w.. */
+	/* ALPHA, added by chiyoko, 20090106 */
+	bool				bLedNoLinkBlinkInProgress;
+	bool				bLedLinkBlinkInProgress;
+	bool				bLedStartToLinkBlinkInProgress;
+	bool				bLedScanBlinkInProgress;
+	bool				bLedWPSBlinkInProgress;
+
+	u32					BlinkTimes; /* Number of times to toggle led state for blinking. */
+	u8					BlinkCounter; /* Added for turn off overlap led after blinking a while, by page, 20120821 */
+	LED_STATE			BlinkingLedState; /* Next state for blinking, either LED_ON or LED_OFF are. */
+
+	struct timer_list 			BlinkTimer; /* Timer object for led blinking. */
+
+	_workitem			BlinkWorkItem; /* Workitem used by BlinkTimer to manipulate H/W to blink LED.' */
+} LED_USB, *PLED_USB;
+
+typedef struct _LED_USB	LED_DATA, *PLED_DATA;
+typedef enum _LED_STRATEGY_USB	LED_STRATEGY, *PLED_STRATEGY;
+
+void
+LedControlUSB(
+	PADAPTER		Adapter,
+	LED_CTL_MODE		LedAction
+);
+
+struct led_priv {
+	/* add for led controll */
+	LED_DATA			SwLed0;
+	LED_DATA			SwLed1;
+	LED_DATA			SwLed2;
+	LED_STRATEGY		LedStrategy;
+	u8					bRegUseLed;
+	void (*LedControlHandler)(_adapter *padapter, LED_CTL_MODE LedAction);
+	void (*SwLedOn)(_adapter *padapter, PLED_DATA pLed);
+	void (*SwLedOff)(_adapter *padapter, PLED_DATA pLed);
+	/* add for led controll */
+};
+
+#ifdef CONFIG_SW_LED
+#define rtw_led_control(adapter, LedAction) \
+	do { \
+		if ((adapter)->ledpriv.LedControlHandler) \
+			(adapter)->ledpriv.LedControlHandler((adapter), (LedAction)); \
+	} while (0)
+#else /* CONFIG_SW_LED */
+#define rtw_led_control(adapter, LedAction)
+#endif /* CONFIG_SW_LED */
+
+#define SwLedOn(adapter, pLed) \
+	do { \
+		if ((adapter)->ledpriv.SwLedOn) \
+			(adapter)->ledpriv.SwLedOn((adapter), (pLed)); \
+	} while (0)
+
+#define SwLedOff(adapter, pLed) \
+	do { \
+		if ((adapter)->ledpriv.SwLedOff) \
+			(adapter)->ledpriv.SwLedOff((adapter), (pLed)); \
+	} while (0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void BlinkTimerCallback(void *data);
+#else
+void BlinkTimerCallback(struct timer_list *t);
+#endif
+void BlinkWorkItemCallback(_workitem *work);
+
+void ResetLedStatus(PLED_DATA pLed);
+
+void
+InitLed(
+	_adapter			*padapter,
+	PLED_DATA		pLed,
+	LED_PIN		LedPin
+);
+
+void
+DeInitLed(
+	PLED_DATA		pLed
+);
+
+/* hal... */
+extern void BlinkHandler(PLED_DATA	pLed);
+
+#endif /* __RTW_LED_H_ */
diff --git a/drivers/staging/rtl8188eu/include/hal_com_phycfg.h b/drivers/staging/rtl8188eu/include/hal_com_phycfg.h
new file mode 100644
index 000000000000..8354ff66c6e1
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_com_phycfg.h
@@ -0,0 +1,332 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_COM_PHYCFG_H__
+#define __HAL_COM_PHYCFG_H__
+
+#define		PathA                     			0x0	/* Useless */
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+typedef enum _RF_TX_NUM {
+	RF_1TX = 0,
+	RF_2TX,
+	RF_3TX,
+	RF_4TX,
+	RF_MAX_TX_NUM,
+	RF_TX_NUM_NONIMPLEMENT,
+} RF_TX_NUM;
+
+#define MAX_POWER_INDEX		0x3F
+
+typedef enum _REGULATION_TXPWR_LMT {
+	TXPWR_LMT_FCC = 0,
+	TXPWR_LMT_MKK = 1,
+	TXPWR_LMT_ETSI = 2,
+	TXPWR_LMT_WW = 3,
+
+	TXPWR_LMT_MAX_REGULATION_NUM = 4
+} REGULATION_TXPWR_LMT;
+
+#define TX_PWR_LMT_REF_VHT_FROM_HT	BIT0
+#define TX_PWR_LMT_REF_HT_FROM_VHT	BIT1
+
+/*------------------------------Define structure----------------------------*/
+typedef struct _BB_REGISTER_DEFINITION {
+	u32 rfintfs;			/* set software control: */
+	/*		0x870~0x877[8 bytes] */
+
+	u32 rfintfo; 			/* output data: */
+	/*		0x860~0x86f [16 bytes] */
+
+	u32 rfintfe; 			/* output enable: */
+	/*		0x860~0x86f [16 bytes] */
+
+	u32 rf3wireOffset;	/* LSSI data: */
+	/*		0x840~0x84f [16 bytes] */
+
+	u32 rfHSSIPara2;	/* wire parameter control2 :  */
+	/*		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes] */
+
+	u32 rfLSSIReadBack;	/* LSSI RF readback data SI mode */
+	/*		0x8a0~0x8af [16 bytes] */
+
+	u32 rfLSSIReadBackPi;	/* LSSI RF readback data PI mode 0x8b8-8bc for Path A and B */
+
+} BB_REGISTER_DEFINITION_T, *PBB_REGISTER_DEFINITION_T;
+
+
+/* ---------------------------------------------------------------------- */
+u8
+PHY_GetTxPowerByRateBase(
+	PADAPTER		Adapter,
+	u8				Band,
+	u8				RfPath,
+	u8				TxNum,
+	RATE_SECTION	RateSection
+);
+
+void
+PHY_GetRateValuesOfTxPowerByRate(
+	PADAPTER pAdapter,
+	u32 RegAddr,
+	u32 BitMask,
+	u32 Value,
+	u8 *Rate,
+	s8 *PwrByRateVal,
+	u8 *RateNum
+);
+
+u8
+PHY_GetRateIndexOfTxPowerByRate(
+	u8	Rate
+);
+
+void
+phy_set_tx_power_index_by_rate_section(
+	PADAPTER		pAdapter,
+	u8				RFPath,
+	u8				Channel,
+	u8				RateSection
+);
+
+s8
+_PHY_GetTxPowerByRate(
+	PADAPTER	pAdapter,
+	u8			Band,
+	u8			RFPath,
+	u8			TxNum,
+	u8			RateIndex
+);
+
+s8
+PHY_GetTxPowerByRate(
+	PADAPTER	pAdapter,
+	u8			Band,
+	u8			RFPath,
+	u8			TxNum,
+	u8			RateIndex
+);
+
+#ifdef CONFIG_PHYDM_POWERTRACK_BY_TSSI
+s8
+PHY_GetTxPowerByRateOriginal(
+	PADAPTER	pAdapter,
+	u8			Band,
+	u8			RFPath,
+	u8			TxNum,
+	u8			Rate
+);
+#endif
+
+void
+PHY_SetTxPowerByRate(
+	PADAPTER	pAdapter,
+	u8			Band,
+	u8			RFPath,
+	u8			TxNum,
+	u8			Rate,
+	s8			Value
+);
+
+void
+phy_set_tx_power_level_by_path(
+	PADAPTER	Adapter,
+	u8			channel,
+	u8			path
+);
+
+void
+PHY_SetTxPowerIndexByRateArray(
+	PADAPTER		pAdapter,
+	u8				RFPath,
+	CHANNEL_WIDTH	BandWidth,
+	u8				Channel,
+	u8				*Rates,
+	u8				RateArraySize
+);
+
+void
+PHY_InitTxPowerByRate(
+	PADAPTER	pAdapter
+);
+
+void
+phy_store_tx_power_by_rate(
+	PADAPTER	pAdapter,
+	u32			Band,
+	u32			RfPath,
+	u32			TxNum,
+	u32			RegAddr,
+	u32			BitMask,
+	u32			Data
+);
+
+void
+PHY_TxPowerByRateConfiguration(
+	PADAPTER			pAdapter
+);
+
+u8
+PHY_GetTxPowerIndexBase(
+	PADAPTER		pAdapter,
+	u8				RFPath,
+	u8				Rate,
+	CHANNEL_WIDTH	BandWidth,
+	u8				Channel,
+	bool *		bIn24G
+);
+
+s8
+PHY_GetTxPowerLimit(
+	PADAPTER		Adapter,
+	u32				RegPwrTblSel,
+	BAND_TYPE		Band,
+	CHANNEL_WIDTH	Bandwidth,
+	u8				RfPath,
+	u8				DataRate,
+	u8				Channel
+);
+
+s8
+PHY_GetTxPowerLimit_no_sc(
+	PADAPTER			Adapter,
+	u32					RegPwrTblSel,
+	BAND_TYPE			Band,
+	CHANNEL_WIDTH		Bandwidth,
+	u8					RfPath,
+	u8					DataRate,
+	u8					Channel
+);
+
+#ifdef CONFIG_PHYDM_POWERTRACK_BY_TSSI
+s8
+PHY_GetTxPowerLimitOriginal(
+	PADAPTER		Adapter,
+	u32				RegPwrTblSel,
+	BAND_TYPE		Band,
+	CHANNEL_WIDTH	Bandwidth,
+	u8				RfPath,
+	u8				DataRate,
+	u8				Channel
+);
+#endif
+
+void
+PHY_ConvertTxPowerLimitToPowerIndex(
+	PADAPTER			Adapter
+);
+
+void
+PHY_InitTxPowerLimit(
+	PADAPTER			Adapter
+);
+
+s8
+PHY_GetTxPowerTrackingOffset(
+	PADAPTER	pAdapter,
+	u8			Rate,
+	u8			RFPath
+);
+
+struct txpwr_idx_comp {
+	u8 base;
+	s8 by_rate;
+	s8 limit;
+	s8 tpt;
+	s8 ebias;
+};
+
+u8
+phy_get_tx_power_index(
+	PADAPTER			pAdapter,
+	u8					RFPath,
+	u8					Rate,
+	CHANNEL_WIDTH		BandWidth,
+	u8					Channel
+);
+
+void
+PHY_SetTxPowerIndex(
+	PADAPTER		pAdapter,
+	u32				PowerIndex,
+	u8				RFPath,
+	u8				Rate
+);
+
+void dump_tx_power_idx_title(void *sel, _adapter *adapter);
+void dump_tx_power_idx_by_path_rs(void *sel, _adapter *adapter, u8 rfpath, u8 rs);
+void dump_tx_power_idx(void *sel, _adapter *adapter);
+
+bool phy_is_tx_power_limit_needed(_adapter *adapter);
+bool phy_is_tx_power_by_rate_needed(_adapter *adapter);
+int phy_load_tx_power_by_rate(_adapter *adapter, u8 chk_file);
+int phy_load_tx_power_limit(_adapter *adapter, u8 chk_file);
+void phy_load_tx_power_ext_info(_adapter *adapter, u8 chk_file);
+void phy_reload_tx_power_ext_info(_adapter *adapter);
+void phy_reload_default_tx_power_ext_info(_adapter *adapter);
+
+const struct map_t *hal_pg_txpwr_def_info(_adapter *adapter);
+
+void dump_pg_txpwr_info_2g(void *sel, TxPowerInfo24G *txpwr_info, u8 rfpath_num, u8 max_tx_cnt);
+void dump_pg_txpwr_info_5g(void *sel, TxPowerInfo5G *txpwr_info, u8 rfpath_num, u8 max_tx_cnt);
+
+void dump_hal_txpwr_info_2g(void *sel, _adapter *adapter, u8 rfpath_num, u8 max_tx_cnt);
+void dump_hal_txpwr_info_5g(void *sel, _adapter *adapter, u8 rfpath_num, u8 max_tx_cnt);
+
+void hal_load_txpwr_info(
+	_adapter *adapter,
+	TxPowerInfo24G *pwr_info_2g,
+	TxPowerInfo5G *pwr_info_5g,
+	u8 *pg_data
+);
+
+void dump_tx_power_ext_info(void *sel, _adapter *adapter);
+void dump_target_tx_power(void *sel, _adapter *adapter);
+void dump_tx_power_by_rate(void *sel, _adapter *adapter);
+void dump_tx_power_limit(void *sel, _adapter *adapter);
+
+int rtw_get_phy_file_path(_adapter *adapter, const char *file_name);
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+#define MAC_FILE_FW_NIC			"FW_NIC.bin"
+#define MAC_FILE_FW_WW_IMG		"FW_WoWLAN.bin"
+#define PHY_FILE_MAC_REG		"MAC_REG.txt"
+
+#define PHY_FILE_AGC_TAB		"AGC_TAB.txt"
+#define PHY_FILE_PHY_REG		"PHY_REG.txt"
+#define PHY_FILE_PHY_REG_MP		"PHY_REG_MP.txt"
+#define PHY_FILE_PHY_REG_PG		"PHY_REG_PG.txt"
+
+#define PHY_FILE_RADIO_A		"RadioA.txt"
+#define PHY_FILE_RADIO_B		"RadioB.txt"
+#define PHY_FILE_RADIO_C		"RadioC.txt"
+#define PHY_FILE_RADIO_D		"RadioD.txt"
+#define PHY_FILE_TXPWR_TRACK	"TxPowerTrack.txt"
+#define PHY_FILE_TXPWR_LMT		"TXPWR_LMT.txt"
+
+#define PHY_FILE_WIFI_ANT_ISOLATION	"wifi_ant_isolation.txt"
+
+#define MAX_PARA_FILE_BUF_LEN	25600
+
+#define LOAD_MAC_PARA_FILE				BIT0
+#define LOAD_BB_PARA_FILE					BIT1
+#define LOAD_BB_PG_PARA_FILE				BIT2
+#define LOAD_BB_MP_PARA_FILE				BIT3
+#define LOAD_RF_PARA_FILE					BIT4
+#define LOAD_RF_TXPWR_TRACK_PARA_FILE	BIT5
+#define LOAD_RF_TXPWR_LMT_PARA_FILE		BIT6
+
+int phy_ConfigMACWithParaFile(PADAPTER	Adapter, char	*pFileName);
+int phy_ConfigBBWithParaFile(PADAPTER	Adapter, char	*pFileName, u32	ConfigType);
+int phy_ConfigBBWithPgParaFile(PADAPTER	Adapter, const char *pFileName);
+int phy_ConfigBBWithMpParaFile(PADAPTER	Adapter, char	*pFileName);
+int PHY_ConfigRFWithParaFile(PADAPTER	Adapter, char	*pFileName, u8	eRFPath);
+int PHY_ConfigRFWithTxPwrTrackParaFile(PADAPTER	Adapter, char	*pFileName);
+int PHY_ConfigRFWithPowerLimitTableParaFile(PADAPTER	Adapter, const char *pFileName);
+void phy_free_filebuf_mask(_adapter *padapter, u8 mask);
+void phy_free_filebuf(_adapter *padapter);
+#endif /* CONFIG_LOAD_PHY_PARA_FROM_FILE */
+
+#endif /* __HAL_COMMON_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_com_reg.h b/drivers/staging/rtl8188eu/include/hal_com_reg.h
new file mode 100644
index 000000000000..a4a4e049f671
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_com_reg.h
@@ -0,0 +1,1795 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_COMMON_REG_H__
+#define __HAL_COMMON_REG_H__
+
+
+#define MAC_ADDR_LEN				6
+
+#define HAL_NAV_UPPER_UNIT		128		/* micro-second */
+
+/* 8188E PKT_BUFF_ACCESS_CTRL value */
+#define TXPKT_BUF_SELECT				0x69
+#define RXPKT_BUF_SELECT				0xA5
+#define DISABLE_TRXPKT_BUF_ACCESS		0x0
+
+#ifndef RTW_HALMAC
+/* ************************************************************
+*
+* ************************************************************ */
+
+/* -----------------------------------------------------
+*
+*	0x0000h ~ 0x00FFh	System Configuration
+*
+* ----------------------------------------------------- */
+#define REG_SYS_ISO_CTRL				0x0000
+#define REG_SYS_FUNC_EN				0x0002
+#define REG_APS_FSMCO					0x0004
+#define REG_SYS_CLKR					0x0008
+#define REG_SYS_CLK_CTRL				REG_SYS_CLKR
+#define REG_9346CR						0x000A
+#define REG_SYS_EEPROM_CTRL			0x000A
+#define REG_EE_VPD						0x000C
+#define REG_AFE_MISC					0x0010
+#define REG_SPS0_CTRL					0x0011
+#define REG_SPS0_CTRL_6					0x0016
+#define REG_POWER_OFF_IN_PROCESS		0x0017
+#define REG_SPS_OCP_CFG				0x0018
+#define REG_RSV_CTRL					0x001C
+#define REG_RF_CTRL						0x001F
+#define REG_LDOA15_CTRL				0x0020
+#define REG_LDOV12D_CTRL				0x0021
+#define REG_LDOHCI12_CTRL				0x0022
+#define REG_LPLDO_CTRL					0x0023
+#define REG_AFE_XTAL_CTRL				0x0024
+#define REG_AFE_LDO_CTRL				0x0027 /* 1.5v for 8188EE test chip, 1.4v for MP chip */
+#define REG_AFE_PLL_CTRL				0x0028
+#define REG_MAC_PHY_CTRL				0x002c /* for 92d, DMDP, SMSP, DMSP contrl */
+#define REG_APE_PLL_CTRL_EXT			0x002c
+#define REG_EFUSE_CTRL					0x0030
+#define REG_EFUSE_TEST					0x0034
+#define REG_PWR_DATA					0x0038
+#define REG_CAL_TIMER					0x003C
+#define REG_ACLK_MON					0x003E
+#define REG_GPIO_MUXCFG				0x0040
+#define REG_GPIO_IO_SEL					0x0042
+#define REG_MAC_PINMUX_CFG			0x0043
+#define REG_GPIO_PIN_CTRL				0x0044
+#define REG_GPIO_INTM					0x0048
+#define REG_LEDCFG0						0x004C
+#define REG_LEDCFG1						0x004D
+#define REG_LEDCFG2						0x004E
+#define REG_LEDCFG3						0x004F
+#define REG_FSIMR						0x0050
+#define REG_FSISR						0x0054
+#define REG_HSIMR						0x0058
+#define REG_HSISR						0x005c
+#define REG_GPIO_PIN_CTRL_2			0x0060 /* RTL8723 WIFI/BT/GPS Multi-Function GPIO Pin Control. */
+#define REG_GPIO_IO_SEL_2				0x0062 /* RTL8723 WIFI/BT/GPS Multi-Function GPIO Select. */
+#define REG_PAD_CTRL_1				0x0064
+#define REG_MULTI_FUNC_CTRL			0x0068 /* RTL8723 WIFI/BT/GPS Multi-Function control source. */
+#define REG_GSSR						0x006c
+#define REG_AFE_XTAL_CTRL_EXT			0x0078 /* RTL8188E */
+#define REG_XCK_OUT_CTRL				0x007c /* RTL8188E */
+#define REG_MCUFWDL					0x0080
+#define REG_WOL_EVENT					0x0081 /* RTL8188E */
+#define REG_MCUTSTCFG					0x0084
+#define REG_FDHM0						0x0088
+#define REG_HOST_SUSP_CNT				0x00BC	/* RTL8192C Host suspend counter on FPGA platform */
+#define REG_SYSTEM_ON_CTRL			0x00CC	/* For 8723AE Reset after S3 */
+#define REG_EFUSE_ACCESS				0x00CF	/* Efuse access protection for RTL8723 */
+#define REG_BIST_SCAN					0x00D0
+#define REG_BIST_RPT					0x00D4
+#define REG_BIST_ROM_RPT				0x00D8
+#define REG_USB_SIE_INTF				0x00E0
+#define REG_PCIE_MIO_INTF				0x00E4
+#define REG_PCIE_MIO_INTD				0x00E8
+#define REG_HPON_FSM					0x00EC
+#define REG_SYS_CFG						0x00F0
+#define REG_GPIO_OUTSTS				0x00F4	/* For RTL8723 only. */
+#define REG_TYPE_ID						0x00FC
+
+/*
+* 2010/12/29 MH Add for 92D
+*   */
+#define REG_MAC_PHY_CTRL_NORMAL		0x00f8
+
+
+/* -----------------------------------------------------
+*
+*	0x0100h ~ 0x01FFh	MACTOP General Configuration
+*
+* ----------------------------------------------------- */
+#define REG_CR							0x0100
+#define REG_PBP							0x0104
+#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
+#define REG_TRXDMA_CTRL				0x010C
+#define REG_TRXFF_BNDY					0x0114
+#define REG_TRXFF_STATUS				0x0118
+#define REG_RXFF_PTR					0x011C
+#define REG_HIMR						0x0120
+#define REG_HISR						0x0124
+#define REG_HIMRE						0x0128
+#define REG_HISRE						0x012C
+#define REG_CPWM						0x012F
+#define REG_FWIMR						0x0130
+#define REG_FWISR						0x0134
+#define REG_FTIMR						0x0138
+#define REG_FTISR						0x013C /* RTL8192C */
+#define REG_PKTBUF_DBG_CTRL			0x0140
+#define REG_RXPKTBUF_CTRL				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_PKTBUF_DBG_DATA_L			0x0144
+#define REG_PKTBUF_DBG_DATA_H		0x0148
+
+#define REG_TC0_CTRL					0x0150
+#define REG_TC1_CTRL					0x0154
+#define REG_TC2_CTRL					0x0158
+#define REG_TC3_CTRL					0x015C
+#define REG_TC4_CTRL					0x0160
+#define REG_TCUNIT_BASE				0x0164
+#define REG_MBIST_START				0x0174
+#define REG_MBIST_DONE					0x0178
+#define REG_MBIST_FAIL					0x017C
+#define REG_32K_CTRL					0x0194 /* RTL8188E */
+#define REG_C2HEVT_MSG_NORMAL		0x01A0
+#define REG_C2HEVT_CLEAR				0x01AF
+#define REG_MCUTST_1					0x01c0
+#define REG_MCUTST_WOWLAN			0x01C7	/* Defined after 8188E series. */
+#define REG_FMETHR						0x01C8
+#define REG_HMETFR						0x01CC
+#define REG_HMEBOX_0					0x01D0
+#define REG_HMEBOX_1					0x01D4
+#define REG_HMEBOX_2					0x01D8
+#define REG_HMEBOX_3					0x01DC
+#define REG_LLT_INIT					0x01E0
+#define REG_HMEBOX_EXT_0				0x01F0
+#define REG_HMEBOX_EXT_1				0x01F4
+#define REG_HMEBOX_EXT_2				0x01F8
+#define REG_HMEBOX_EXT_3				0x01FC
+
+
+/* -----------------------------------------------------
+*
+*	0x0200h ~ 0x027Fh	TXDMA Configuration
+*
+* ----------------------------------------------------- */
+#define REG_RQPN						0x0200
+#define REG_FIFOPAGE					0x0204
+#define REG_TDECTRL						0x0208
+#define REG_TXDMA_OFFSET_CHK			0x020C
+#define REG_TXDMA_STATUS				0x0210
+#define REG_RQPN_NPQ					0x0214
+#define REG_AUTO_LLT					0x0224
+
+
+/* -----------------------------------------------------
+*
+*	0x0280h ~ 0x02FFh	RXDMA Configuration
+*
+* ----------------------------------------------------- */
+#define REG_RXDMA_AGG_PG_TH			0x0280
+#define REG_RXPKT_NUM					0x0284
+#define REG_RXDMA_STATUS				0x0288
+
+/* -----------------------------------------------------
+*
+*	0x0300h ~ 0x03FFh	PCIe
+*
+* ----------------------------------------------------- */
+#ifndef CONFIG_TRX_BD_ARCH	/* prevent CONFIG_TRX_BD_ARCH to use old registers */
+
+#define REG_PCIE_CTRL_REG				0x0300
+#define REG_INT_MIG					0x0304	/* Interrupt Migration */
+#define REG_BCNQ_DESA					0x0308	/* TX Beacon Descriptor Address */
+#define REG_HQ_DESA					0x0310	/* TX High Queue Descriptor Address */
+#define REG_MGQ_DESA					0x0318	/* TX Manage Queue Descriptor Address */
+#define REG_VOQ_DESA					0x0320	/* TX VO Queue Descriptor Address */
+#define REG_VIQ_DESA					0x0328	/* TX VI Queue Descriptor Address */
+#define REG_BEQ_DESA					0x0330	/* TX BE Queue Descriptor Address */
+#define REG_BKQ_DESA					0x0338	/* TX BK Queue Descriptor Address */
+#define REG_RX_DESA					0x0340	/* RX Queue Descriptor Address */
+/* sherry added for DBI Read/Write  20091126 */
+#define REG_DBI_WDATA					0x0348	/*  Backdoor REG for Access Configuration */
+#define REG_DBI_RDATA					0x034C	/* Backdoor REG for Access Configuration */
+#define REG_DBI_CTRL					0x0350	/* Backdoor REG for Access Configuration */
+#define REG_DBI_FLAG					0x0352	/* Backdoor REG for Access Configuration */
+#define REG_MDIO					0x0354	/* MDIO for Access PCIE PHY */
+#define REG_DBG_SEL					0x0360	/* Debug Selection Register */
+#define REG_PCIE_HRPWM					0x0361	/* PCIe RPWM */
+#define REG_PCIE_HCPWM					0x0363	/* PCIe CPWM */
+#define REG_WATCH_DOG					0x0368
+#define REG_RX_RXBD_NUM					0x0382
+
+/* RTL8723 series ------------------------------- */
+#define REG_PCIE_HISR_EN				0x0394	/* PCIE Local Interrupt Enable Register */
+#define REG_PCIE_HISR					0x03A0
+#define REG_PCIE_HISRE					0x03A4
+#define REG_PCIE_HIMR					0x03A8
+#define REG_PCIE_HIMRE					0x03AC
+
+#endif /* !CONFIG_TRX_BD_ARCH */
+
+#define REG_USB_HIMR					0xFE38
+#define REG_USB_HIMRE					0xFE3C
+#define REG_USB_HISR					0xFE78
+#define REG_USB_HISRE					0xFE7C
+
+
+/* -----------------------------------------------------
+*
+*	0x0400h ~ 0x047Fh	Protocol Configuration
+*
+* ----------------------------------------------------- */
+
+/* 92C, 92D */
+#define REG_VOQ_INFO	0x0400
+#define REG_VIQ_INFO	0x0404
+#define REG_BEQ_INFO	0x0408
+#define REG_BKQ_INFO	0x040C
+
+/* 88E, 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q0_INFO	0x400
+#define REG_Q1_INFO	0x404
+#define REG_Q2_INFO	0x408
+#define REG_Q3_INFO	0x40C
+
+#define REG_MGQ_INFO	0x0410
+#define REG_HGQ_INFO	0x0414
+#define REG_BCNQ_INFO	0x0418
+#define REG_TXPKT_EMPTY				0x041A
+#define REG_CPU_MGQ_INFORMATION		0x041C
+#define REG_FWHW_TXQ_CTRL				0x0420
+#define REG_HWSEQ_CTRL					0x0423
+#define REG_BCNQ_BDNY					0x0424
+#define REG_MGQ_BDNY					0x0425
+#define REG_LIFETIME_CTRL				0x0426
+#define REG_MULTI_BCNQ_OFFSET			0x0427
+#define REG_SPEC_SIFS					0x0428
+#define REG_RL							0x042A
+#define REG_DARFRC						0x0430
+#define REG_RARFRC						0x0438
+#define REG_RRSR						0x0440
+#define REG_ARFR0						0x0444
+#define REG_ARFR1						0x0448
+#define REG_ARFR2						0x044C
+#define REG_ARFR3						0x0450
+#define REG_CCK_CHECK					0x0454
+#define REG_BCNQ1_BDNY					0x0457
+
+#define REG_AGGLEN_LMT					0x0458
+#define REG_AMPDU_MIN_SPACE			0x045C
+#define REG_WMAC_LBK_BF_HD			0x045D
+#define REG_FAST_EDCA_CTRL				0x0460
+#define REG_RD_RESP_PKT_TH				0x0463
+
+/* 8723A, 8812A, 8821A, 92E, 8723B */
+#define REG_Q4_INFO	0x468
+#define REG_Q5_INFO	0x46C
+#define REG_Q6_INFO	0x470
+#define REG_Q7_INFO	0x474
+
+#define REG_INIRTS_RATE_SEL				0x0480
+#define REG_INIDATA_RATE_SEL			0x0484
+
+/* 8723B, 92E, 8812A, 8821A*/
+#define REG_MACID_SLEEP_3				0x0484
+#define REG_MACID_SLEEP_1				0x0488
+
+#define REG_POWER_STAGE1				0x04B4
+#define REG_POWER_STAGE2				0x04B8
+#define REG_PKT_VO_VI_LIFE_TIME		0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME		0x04C2
+#define REG_STBC_SETTING				0x04C4
+#define REG_QUEUE_CTRL					0x04C6
+#define REG_SINGLE_AMPDU_CTRL			0x04c7
+#define REG_PROT_MODE_CTRL			0x04C8
+#define REG_MAX_AGGR_NUM				0x04CA
+#define REG_RTS_MAX_AGGR_NUM			0x04CB
+#define REG_BAR_MODE_CTRL				0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
+
+/* 8723A */
+#define REG_MACID_DROP	0x04D0
+
+/* 88E */
+#define REG_EARLY_MODE_CONTROL	0x04D0
+
+/* 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP_2	0x04D0
+
+/* 8723A, 8723B, 92E, 8812A, 8821A */
+#define REG_MACID_SLEEP	0x04D4
+
+#define REG_NQOS_SEQ					0x04DC
+#define REG_QOS_SEQ					0x04DE
+#define REG_NEED_CPU_HANDLE			0x04E0
+#define REG_PKT_LOSE_RPT				0x04E1
+#define REG_PTCL_ERR_STATUS			0x04E2
+#define REG_TX_RPT_CTRL					0x04EC
+#define REG_TX_RPT_TIME					0x04F0	/* 2 byte */
+#define REG_DUMMY						0x04FC
+
+/* -----------------------------------------------------
+*
+*	0x0500h ~ 0x05FFh	EDCA Configuration
+*
+* ----------------------------------------------------- */
+#define REG_EDCA_VO_PARAM				0x0500
+#define REG_EDCA_VI_PARAM				0x0504
+#define REG_EDCA_BE_PARAM				0x0508
+#define REG_EDCA_BK_PARAM				0x050C
+#define REG_BCNTCFG						0x0510
+#define REG_PIFS							0x0512
+#define REG_RDG_PIFS					0x0513
+#define REG_SIFS_CTX					0x0514
+#define REG_SIFS_TRX					0x0516
+#define REG_TSFTR_SYN_OFFSET			0x0518
+#define REG_AGGR_BREAK_TIME			0x051A
+#define REG_SLOT						0x051B
+#define REG_TX_PTCL_CTRL				0x0520
+#define REG_TXPAUSE						0x0522
+#define REG_DIS_TXREQ_CLR				0x0523
+#define REG_RD_CTRL						0x0524
+/*
+* Format for offset 540h-542h:
+*	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
+*	[7:4]:   Reserved.
+*	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
+*	[23:20]: Reserved
+* Description:
+*	              |
+*      |<--Setup--|--Hold------------>|
+*   --------------|----------------------
+*                 |
+*                TBTT
+* Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
+* Described by Designer Tim and Bruce, 2011-01-14.
+*   */
+#define REG_TBTT_PROHIBIT				0x0540
+#define REG_RD_NAV_NXT					0x0544
+#define REG_NAV_PROT_LEN				0x0546
+#define REG_BCN_CTRL					0x0550
+#define REG_BCN_CTRL_1					0x0551
+#define REG_MBID_NUM					0x0552
+#define REG_DUAL_TSF_RST				0x0553
+#define REG_BCN_INTERVAL				0x0554	/* The same as REG_MBSSID_BCN_SPACE */
+#define REG_DRVERLYINT					0x0558
+#define REG_BCNDMATIM					0x0559
+#define REG_ATIMWND					0x055A
+#define REG_USTIME_TSF					0x055C
+#define REG_BCN_MAX_ERR				0x055D
+#define REG_RXTSF_OFFSET_CCK			0x055E
+#define REG_RXTSF_OFFSET_OFDM			0x055F
+#define REG_TSFTR						0x0560
+#define REG_TSFTR1						0x0568	/* HW Port 1 TSF Register */
+#define REG_ATIMWND_1					0x0570
+#define REG_P2P_CTWIN					0x0572 /* 1 Byte long (in unit of TU) */
+#define REG_PSTIMER						0x0580
+#define REG_TIMER0						0x0584
+#define REG_TIMER1						0x0588
+#define REG_ACMHWCTRL					0x05C0
+#define REG_NOA_DESC_SEL				0x05CF
+#define REG_NOA_DESC_DURATION		0x05E0
+#define REG_NOA_DESC_INTERVAL			0x05E4
+#define REG_NOA_DESC_START			0x05E8
+#define REG_NOA_DESC_COUNT			0x05EC
+
+#define REG_DMC							0x05F0	/* Dual MAC Co-Existence Register */
+#define REG_SCH_TX_CMD					0x05F8
+
+#define REG_FW_RESET_TSF_CNT_1		0x05FC
+#define REG_FW_RESET_TSF_CNT_0		0x05FD
+#define REG_FW_BCN_DIS_CNT			0x05FE
+
+/* -----------------------------------------------------
+*
+*	0x0600h ~ 0x07FFh	WMAC Configuration
+*
+* ----------------------------------------------------- */
+#define REG_APSD_CTRL					0x0600
+#define REG_BWOPMODE					0x0603
+#define REG_TCR							0x0604
+#define REG_RCR							0x0608
+#define REG_RX_PKT_LIMIT				0x060C
+#define REG_RX_DLK_TIME				0x060D
+#define REG_RX_DRVINFO_SZ				0x060F
+
+#define REG_MACID						0x0610
+#define REG_BSSID						0x0618
+#define REG_MAR							0x0620
+#define REG_MBIDCAMCFG_1				0x0628
+#define REG_MBIDCAMCFG_2				0x062C
+
+#define REG_PNO_STATUS					0x0631
+#define REG_USTIME_EDCA				0x0638
+#define REG_MAC_SPEC_SIFS				0x063A
+/* 20100719 Joseph: Hardware register definition change. (HW datasheet v54) */
+#define REG_RESP_SIFS_CCK				0x063C	/* [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK */
+#define REG_RESP_SIFS_OFDM                    0x063E	/* [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK */
+
+#define REG_ACKTO						0x0640
+#define REG_CTS2TO						0x0641
+#define REG_EIFS							0x0642
+
+
+/* RXERR_RPT */
+#define RXERR_TYPE_OFDM_PPDU			0
+#define RXERR_TYPE_OFDMfalse_ALARM	1
+#define RXERR_TYPE_OFDM_MPDU_OK		2
+#define RXERR_TYPE_OFDM_MPDU_FAIL	3
+#define RXERR_TYPE_CCK_PPDU			4
+#define RXERR_TYPE_CCKfalse_ALARM	5
+#define RXERR_TYPE_CCK_MPDU_OK		6
+#define RXERR_TYPE_CCK_MPDU_FAIL		7
+#define RXERR_TYPE_HT_PPDU				8
+#define RXERR_TYPE_HTfalse_ALARM	9
+#define RXERR_TYPE_HT_MPDU_TOTAL		10
+#define RXERR_TYPE_HT_MPDU_OK			11
+#define RXERR_TYPE_HT_MPDU_FAIL		12
+#define RXERR_TYPE_RX_FULL_DROP		15
+
+#define RXERR_COUNTER_MASK			0xFFFFF
+#define RXERR_RPT_RST					BIT(27)
+#define _RXERR_RPT_SEL(type)			((type) << 28)
+
+/*
+* Note:
+*	The NAV upper value is very important to WiFi 11n 5.2.3 NAV test. The default value is
+*	always too small, but the WiFi TestPlan test by 25,000 microseconds of NAV through sending
+*	CTS in the air. We must update this value greater than 25,000 microseconds to pass the item.
+*	The offset of NAV_UPPER in 8192C Spec is incorrect, and the offset should be 0x0652. Commented
+*	by SD1 Scott.
+* By Bruce, 2011-07-18.
+*   */
+#define REG_NAV_UPPER					0x0652	/* unit of 128 */
+
+/* WMA, BA, CCX */
+#define REG_NAV_CTRL					0x0650
+#define REG_BACAMCMD					0x0654
+#define REG_BACAMCONTENT				0x0658
+#define REG_LBDLY						0x0660
+#define REG_FWDLY						0x0661
+#define REG_RXERR_RPT					0x0664
+#define REG_WMAC_TRXPTCL_CTL			0x0668
+
+/* Security */
+#define REG_CAMCMD						0x0670
+#define REG_CAMWRITE					0x0674
+#define REG_CAMREAD					0x0678
+#define REG_CAMDBG						0x067C
+#define REG_SECCFG						0x0680
+
+/* Power */
+#define REG_WOW_CTRL					0x0690
+#define REG_PS_RX_INFO					0x0692
+#define REG_WMMPS_UAPSD_TID			0x0693
+#define REG_WKFMCAM_CMD				0x0698
+#define REG_WKFMCAM_NUM				REG_WKFMCAM_CMD
+#define REG_WKFMCAM_RWD				0x069C
+#define REG_RXFLTMAP0					0x06A0
+#define REG_RXFLTMAP1					0x06A2
+#define REG_RXFLTMAP2					0x06A4
+#define REG_BCN_PSR_RPT				0x06A8
+#define REG_BT_COEX_TABLE				0x06C0
+
+/* Hardware Port 1 */
+#define REG_MACID1						0x0700
+#define REG_BSSID1						0x0708
+/* Hardware Port 2 */
+#define REG_MACID2						0x1620
+#define REG_BSSID2						0x1628
+/* Hardware Port 3*/
+#define REG_MACID3						0x1630
+#define REG_BSSID3						0x1638
+/* Hardware Port 4 */
+#define REG_MACID4						0x1640
+#define REG_BSSID4						0x1648
+
+
+#define REG_CR_EXT						0x1100
+
+/* -----------------------------------------------------
+*
+*	0xFE00h ~ 0xFE55h	USB Configuration
+*
+* ----------------------------------------------------- */
+#define REG_USB_INFO					0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO			0xFE5B
+#define REG_USB_AGG_TO					0xFE5C
+#define REG_USB_AGG_TH					0xFE5D
+
+#define REG_USB_HRPWM					0xFE58
+#define REG_USB_HCPWM					0xFE57
+
+/* for 92DU high_Queue low_Queue Normal_Queue select */
+#define REG_USB_High_NORMAL_Queue_Select_MAC0	0xFE44
+/* #define REG_USB_LOW_Queue_Select_MAC0		0xFE45 */
+#define REG_USB_High_NORMAL_Queue_Select_MAC1	0xFE47
+/* #define REG_USB_LOW_Queue_Select_MAC1		0xFE48 */
+
+/* For test chip */
+#define REG_TEST_USB_TXQS				0xFE48
+#define REG_TEST_SIE_VID				0xFE60		/* 0xFE60~0xFE61 */
+#define REG_TEST_SIE_PID				0xFE62		/* 0xFE62~0xFE63 */
+#define REG_TEST_SIE_OPTIONAL			0xFE64
+#define REG_TEST_SIE_CHIRP_K			0xFE65
+#define REG_TEST_SIE_PHY				0xFE66		/* 0xFE66~0xFE6B */
+#define REG_TEST_SIE_MAC_ADDR			0xFE70		/* 0xFE70~0xFE75 */
+#define REG_TEST_SIE_STRING			0xFE80		/* 0xFE80~0xFEB9 */
+
+
+/* For normal chip */
+#define REG_NORMAL_SIE_VID				0xFE60		/* 0xFE60~0xFE61 */
+#define REG_NORMAL_SIE_PID				0xFE62		/* 0xFE62~0xFE63 */
+#define REG_NORMAL_SIE_OPTIONAL		0xFE64
+#define REG_NORMAL_SIE_EP				0xFE65		/* 0xFE65~0xFE67 */
+#define REG_NORMAL_SIE_PHY			0xFE68		/* 0xFE68~0xFE6B */
+#define REG_NORMAL_SIE_OPTIONAL2		0xFE6C
+#define REG_NORMAL_SIE_GPS_EP			0xFE6D		/* 0xFE6D, for RTL8723 only. */
+#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		/* 0xFE70~0xFE75 */
+#define REG_NORMAL_SIE_STRING			0xFE80		/* 0xFE80~0xFEDF */
+
+
+/* -----------------------------------------------------
+*
+*	Redifine 8192C register definition for compatibility
+*
+* ----------------------------------------------------- */
+
+/* TODO: use these definition when using REG_xxx naming rule.
+* NOTE: DO NOT Remove these definition. Use later. */
+
+#define EFUSE_CTRL				REG_EFUSE_CTRL		/* E-Fuse Control. */
+#define EFUSE_TEST				REG_EFUSE_TEST		/* E-Fuse Test. */
+#define MSR						(REG_CR + 2)		/* Media Status register */
+/* #define ISR						REG_HISR */
+#define MSR1						REG_CR_EXT
+
+#define TSFR						REG_TSFTR			/* Timing Sync Function Timer Register. */
+#define TSFR1					REG_TSFTR1			/* HW Port 1 TSF Register */
+
+#define PBP						REG_PBP
+
+/* Redifine MACID register, to compatible prior ICs. */
+#define IDR0						REG_MACID			/* MAC ID Register, Offset 0x0050-0x0053 */
+#define IDR4						(REG_MACID + 4)		/* MAC ID Register, Offset 0x0054-0x0055 */
+
+
+/*
+* 9. Security Control Registers	(Offset: )
+*   */
+#define RWCAM					REG_CAMCMD		/* IN 8190 Data Sheet is called CAMcmd */
+#define WCAMI					REG_CAMWRITE	/* Software write CAM input content */
+#define RCAMO					REG_CAMREAD		/* Software read/write CAM config */
+#define CAMDBG					REG_CAMDBG
+#define SECR						REG_SECCFG		/* Security Configuration Register */
+
+/* Unused register */
+#define UnusedRegister			0x1BF
+#define DCAM					UnusedRegister
+#define PSR						UnusedRegister
+#define BBAddr					UnusedRegister
+#define PhyDataR					UnusedRegister
+
+/* Min Spacing related settings. */
+#define MAX_MSS_DENSITY_2T			0x13
+#define MAX_MSS_DENSITY_1T			0x0A
+
+/* ----------------------------------------------------------------------------
+* 8192C Cmd9346CR bits					(Offset 0xA, 16bit)
+* ---------------------------------------------------------------------------- */
+#define CmdEEPROM_En				BIT(5)	 /* EEPROM enable when set 1 */
+#define CmdEERPOMSEL				BIT(4)	/* System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346 */
+#define Cmd9346CR_9356SEL			BIT(4)
+
+/* ----------------------------------------------------------------------------
+* 8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
+* ---------------------------------------------------------------------------- */
+#define GPIOSEL_GPIO				0
+#define GPIOSEL_ENBT				BIT(5)
+
+/* ----------------------------------------------------------------------------
+* 8192C GPIO PIN Control Register (offset 0x44, 4 byte)
+* ---------------------------------------------------------------------------- */
+#define GPIO_IN					REG_GPIO_PIN_CTRL		/* GPIO pins input value */
+#define GPIO_OUT				(REG_GPIO_PIN_CTRL+1)	/* GPIO pins output value */
+#define GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	/* GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
+#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)
+
+/* ----------------------------------------------------------------------------
+* 8811A GPIO PIN Control Register (offset 0x60, 4 byte)
+* ---------------------------------------------------------------------------- */
+#define GPIO_IN_8811A			REG_GPIO_PIN_CTRL_2		/* GPIO pins input value */
+#define GPIO_OUT_8811A			(REG_GPIO_PIN_CTRL_2+1)	/* GPIO pins output value */
+#define GPIO_IO_SEL_8811A		(REG_GPIO_PIN_CTRL_2+2)	/* GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
+#define GPIO_MOD_8811A			(REG_GPIO_PIN_CTRL_2+3)
+
+/* ----------------------------------------------------------------------------
+* 8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte)
+* ---------------------------------------------------------------------------- */
+#define HSIMR_GPIO12_0_INT_EN			BIT(0)
+#define HSIMR_SPS_OCP_INT_EN			BIT(5)
+#define HSIMR_RON_INT_EN				BIT(6)
+#define HSIMR_PDN_INT_EN				BIT(7)
+#define HSIMR_GPIO9_INT_EN				BIT(25)
+
+/* ----------------------------------------------------------------------------
+* 8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte)
+* ---------------------------------------------------------------------------- */
+#define HSISR_GPIO12_0_INT				BIT(0)
+#define HSISR_SPS_OCP_INT				BIT(5)
+#define HSISR_RON_INT					BIT(6)
+#define HSISR_PDNINT					BIT(7)
+#define HSISR_GPIO9_INT					BIT(25)
+
+/* ----------------------------------------------------------------------------
+* 8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
+* ---------------------------------------------------------------------------- */
+/*
+Network Type
+00: No link
+01: Link in ad hoc network
+10: Link in infrastructure network
+11: AP mode
+Default: 00b.
+*/
+#define MSR_NOLINK				0x00
+#define MSR_ADHOC				0x01
+#define MSR_INFRA				0x02
+#define MSR_AP					0x03
+
+/* ----------------------------------------------------------------------------
+* USB INTR CONTENT
+* ---------------------------------------------------------------------------- */
+#define USB_C2H_CMDID_OFFSET					0
+#define USB_C2H_SEQ_OFFSET					1
+#define USB_C2H_EVENT_OFFSET					2
+#define USB_INTR_CPWM_OFFSET					16
+#define USB_INTR_CONTENT_C2H_OFFSET			0
+#define USB_INTR_CONTENT_CPWM1_OFFSET		16
+#define USB_INTR_CONTENT_CPWM2_OFFSET		20
+#define USB_INTR_CONTENT_HISR_OFFSET			48
+#define USB_INTR_CONTENT_HISRE_OFFSET		52
+#define USB_INTR_CONTENT_LENGTH				56
+
+/* ----------------------------------------------------------------------------
+* Response Rate Set Register	(offset 0x440, 24bits)
+* ---------------------------------------------------------------------------- */
+#define RRSR_1M					BIT(0)
+#define RRSR_2M					BIT(1)
+#define RRSR_5_5M				BIT(2)
+#define RRSR_11M				BIT(3)
+#define RRSR_6M					BIT(4)
+#define RRSR_9M					BIT(5)
+#define RRSR_12M				BIT(6)
+#define RRSR_18M				BIT(7)
+#define RRSR_24M				BIT(8)
+#define RRSR_36M				BIT(9)
+#define RRSR_48M				BIT(10)
+#define RRSR_54M				BIT(11)
+#define RRSR_MCS0				BIT(12)
+#define RRSR_MCS1				BIT(13)
+#define RRSR_MCS2				BIT(14)
+#define RRSR_MCS3				BIT(15)
+#define RRSR_MCS4				BIT(16)
+#define RRSR_MCS5				BIT(17)
+#define RRSR_MCS6				BIT(18)
+#define RRSR_MCS7				BIT(19)
+
+#define RRSR_CCK_RATES (RRSR_11M | RRSR_5_5M | RRSR_2M | RRSR_1M)
+#define RRSR_OFDM_RATES (RRSR_54M | RRSR_48M | RRSR_36M | RRSR_24M | RRSR_18M | RRSR_12M | RRSR_9M | RRSR_6M)
+
+/* WOL bit information */
+#define HAL92C_WOL_PTK_UPDATE_EVENT		BIT(0)
+#define HAL92C_WOL_GTK_UPDATE_EVENT		BIT(1)
+#define HAL92C_WOL_DISASSOC_EVENT		BIT(2)
+#define HAL92C_WOL_DEAUTH_EVENT			BIT(3)
+#define HAL92C_WOL_FW_DISCONNECT_EVENT	BIT(4)
+
+
+/*----------------------------------------------------------------------------
+**      REG_CCK_CHECK						(offset 0x454)
+------------------------------------------------------------------------------*/
+#define BIT_BCN_PORT_SEL		BIT(5)
+
+#endif /* RTW_HALMAC */
+
+/* ----------------------------------------------------------------------------
+ * Rate Definition
+ * ---------------------------------------------------------------------------- */
+/* CCK */
+#define	RATR_1M					0x00000001
+#define	RATR_2M					0x00000002
+#define	RATR_55M					0x00000004
+#define	RATR_11M					0x00000008
+/* OFDM		 */
+#define	RATR_6M					0x00000010
+#define	RATR_9M					0x00000020
+#define	RATR_12M					0x00000040
+#define	RATR_18M					0x00000080
+#define	RATR_24M					0x00000100
+#define	RATR_36M					0x00000200
+#define	RATR_48M					0x00000400
+#define	RATR_54M					0x00000800
+/* MCS 1 Spatial Stream	 */
+#define	RATR_MCS0					0x00001000
+#define	RATR_MCS1					0x00002000
+#define	RATR_MCS2					0x00004000
+#define	RATR_MCS3					0x00008000
+#define	RATR_MCS4					0x00010000
+#define	RATR_MCS5					0x00020000
+#define	RATR_MCS6					0x00040000
+#define	RATR_MCS7					0x00080000
+/* MCS 2 Spatial Stream */
+#define	RATR_MCS8					0x00100000
+#define	RATR_MCS9					0x00200000
+#define	RATR_MCS10					0x00400000
+#define	RATR_MCS11					0x00800000
+#define	RATR_MCS12					0x01000000
+#define	RATR_MCS13					0x02000000
+#define	RATR_MCS14					0x04000000
+#define	RATR_MCS15					0x08000000
+
+/* CCK */
+#define RATE_1M					BIT(0)
+#define RATE_2M					BIT(1)
+#define RATE_5_5M				BIT(2)
+#define RATE_11M				BIT(3)
+/* OFDM */
+#define RATE_6M					BIT(4)
+#define RATE_9M					BIT(5)
+#define RATE_12M				BIT(6)
+#define RATE_18M				BIT(7)
+#define RATE_24M				BIT(8)
+#define RATE_36M				BIT(9)
+#define RATE_48M				BIT(10)
+#define RATE_54M				BIT(11)
+/* MCS 1 Spatial Stream */
+#define RATE_MCS0				BIT(12)
+#define RATE_MCS1				BIT(13)
+#define RATE_MCS2				BIT(14)
+#define RATE_MCS3				BIT(15)
+#define RATE_MCS4				BIT(16)
+#define RATE_MCS5				BIT(17)
+#define RATE_MCS6				BIT(18)
+#define RATE_MCS7				BIT(19)
+/* MCS 2 Spatial Stream */
+#define RATE_MCS8				BIT(20)
+#define RATE_MCS9				BIT(21)
+#define RATE_MCS10				BIT(22)
+#define RATE_MCS11				BIT(23)
+#define RATE_MCS12				BIT(24)
+#define RATE_MCS13				BIT(25)
+#define RATE_MCS14				BIT(26)
+#define RATE_MCS15				BIT(27)
+
+
+/* ALL CCK Rate */
+#define	RATE_ALL_CCK				(RATR_1M | RATR_2M | RATR_55M | RATR_11M)
+#define	RATE_ALL_OFDM_AG			(RATR_6M | RATR_9M | RATR_12M | RATR_18M | RATR_24M|\
+	RATR_36M | RATR_48M | RATR_54M)
+#define	RATE_ALL_OFDM_1SS			(RATR_MCS0 | RATR_MCS1 | RATR_MCS2 | RATR_MCS3 |\
+	RATR_MCS4 | RATR_MCS5 | RATR_MCS6 | RATR_MCS7)
+#define	RATE_ALL_OFDM_2SS			(RATR_MCS8 | RATR_MCS9 | RATR_MCS10 | RATR_MCS11|\
+	RATR_MCS12 | RATR_MCS13 | RATR_MCS14 | RATR_MCS15)
+
+#define RATE_BITMAP_ALL			0xFFFFF
+
+/* Only use CCK 1M rate for ACK */
+#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
+#define RATE_RRSR_WITHOUT_CCK		0xFFFF0
+
+/* ----------------------------------------------------------------------------
+ * BW_OPMODE bits				(Offset 0x603, 8bit)
+ * ---------------------------------------------------------------------------- */
+#define BW_OPMODE_20MHZ			BIT(2)
+#define BW_OPMODE_5G				BIT(1)
+
+/* ----------------------------------------------------------------------------
+ * CAM Config Setting (offset 0x680, 1 byte)
+ * ----------------------------------------------------------------------------			 */
+#define CAM_VALID				BIT(15)
+#define CAM_NOTVALID			0x0000
+#define CAM_USEDK				BIT(5)
+
+#define CAM_CONTENT_COUNT	8
+
+#define CAM_NONE				0x0
+#define CAM_WEP40				0x01
+#define CAM_TKIP				0x02
+#define CAM_AES					0x04
+#define CAM_WEP104				0x05
+#define CAM_SMS4				0x6
+
+#define TOTAL_CAM_ENTRY		32
+#define HALF_CAM_ENTRY			16
+
+#define CAM_CONFIG_USEDK		true
+#define CAM_CONFIG_NO_USEDK	false
+
+#define CAM_WRITE				BIT(16)
+#define CAM_READ				0x00000000
+#define CAM_POLLINIG			BIT(31)
+
+/*
+ * 10. Power Save Control Registers
+ *   */
+#define WOW_PMEN				BIT(0) /* Power management Enable. */
+#define WOW_WOMEN				BIT(1) /* WoW function on or off. */
+#define WOW_MAGIC				BIT(2) /* Magic packet */
+#define WOW_UWF				BIT(3) /* Unicast Wakeup frame. */
+
+/*
+ * 12. Host Interrupt Status Registers
+ *
+ * ----------------------------------------------------------------------------
+ * 8190 IMR/ISR bits
+ * ---------------------------------------------------------------------------- */
+#define IMR8190_DISABLED		0x0
+#define IMR_DISABLED			0x0
+/* IMR DW0 Bit 0-31 */
+#define IMR_BCNDMAINT6			BIT(31)		/* Beacon DMA Interrupt 6 */
+#define IMR_BCNDMAINT5			BIT(30)		/* Beacon DMA Interrupt 5 */
+#define IMR_BCNDMAINT4			BIT(29)		/* Beacon DMA Interrupt 4 */
+#define IMR_BCNDMAINT3			BIT(28)		/* Beacon DMA Interrupt 3 */
+#define IMR_BCNDMAINT2			BIT(27)		/* Beacon DMA Interrupt 2 */
+#define IMR_BCNDMAINT1			BIT(26)		/* Beacon DMA Interrupt 1 */
+#define IMR_BCNDOK8				BIT(25)		/* Beacon Queue DMA OK Interrupt 8 */
+#define IMR_BCNDOK7				BIT(24)		/* Beacon Queue DMA OK Interrupt 7 */
+#define IMR_BCNDOK6				BIT(23)		/* Beacon Queue DMA OK Interrupt 6 */
+#define IMR_BCNDOK5				BIT(22)		/* Beacon Queue DMA OK Interrupt 5 */
+#define IMR_BCNDOK4				BIT(21)		/* Beacon Queue DMA OK Interrupt 4 */
+#define IMR_BCNDOK3				BIT(20)		/* Beacon Queue DMA OK Interrupt 3 */
+#define IMR_BCNDOK2				BIT(19)		/* Beacon Queue DMA OK Interrupt 2 */
+#define IMR_BCNDOK1				BIT(18)		/* Beacon Queue DMA OK Interrupt 1 */
+#define IMR_TIMEOUT2			BIT(17)		/* Timeout interrupt 2 */
+#define IMR_TIMEOUT1			BIT(16)		/* Timeout interrupt 1 */
+#define IMR_TXFOVW				BIT(15)		/* Transmit FIFO Overflow */
+#define IMR_PSTIMEOUT			BIT(14)		/* Power save time out interrupt */
+#define IMR_BcnInt				BIT(13)		/* Beacon DMA Interrupt 0 */
+#define IMR_RXFOVW				BIT(12)		/* Receive FIFO Overflow */
+#define IMR_RDU					BIT(11)		/* Receive Descriptor Unavailable */
+#define IMR_ATIMEND				BIT(10)		/* For 92C, ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt. */
+#define IMR_BDOK				BIT(9)		/* Beacon Queue DMA OK Interrupt */
+#define IMR_HIGHDOK				BIT(8)		/* High Queue DMA OK Interrupt */
+#define IMR_TBDOK				BIT(7)		/* Transmit Beacon OK interrupt */
+#define IMR_MGNTDOK			BIT(6)		/* Management Queue DMA OK Interrupt */
+#define IMR_TBDER				BIT(5)		/* For 92C, Transmit Beacon Error Interrupt */
+#define IMR_BKDOK				BIT(4)		/* AC_BK DMA OK Interrupt */
+#define IMR_BEDOK				BIT(3)		/* AC_BE DMA OK Interrupt */
+#define IMR_VIDOK				BIT(2)		/* AC_VI DMA OK Interrupt */
+#define IMR_VODOK				BIT(1)		/* AC_VO DMA Interrupt */
+#define IMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */
+
+/* 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh) */
+#define IMR_TSF_BIT32_TOGGLE	BIT(15)
+#define IMR_BcnInt_E				BIT(12)
+#define IMR_TXERR				BIT(11)
+#define IMR_RXERR				BIT(10)
+#define IMR_C2HCMD				BIT(9)
+#define IMR_CPWM				BIT(8)
+/* RSVD [2-7] */
+#define IMR_OCPINT				BIT(1)
+#define IMR_WLANOFF			BIT(0)
+
+/* ----------------------------------------------------------------------------
+ * 8723E series PCIE Host IMR/ISR bit
+ * ---------------------------------------------------------------------------- */
+/* IMR DW0 Bit 0-31 */
+#define PHIMR_TIMEOUT2				BIT(31)
+#define PHIMR_TIMEOUT1				BIT(30)
+#define PHIMR_PSTIMEOUT			BIT(29)
+#define PHIMR_GTINT4				BIT(28)
+#define PHIMR_GTINT3				BIT(27)
+#define PHIMR_TXBCNERR				BIT(26)
+#define PHIMR_TXBCNOK				BIT(25)
+#define PHIMR_TSF_BIT32_TOGGLE	BIT(24)
+#define PHIMR_BCNDMAINT3			BIT(23)
+#define PHIMR_BCNDMAINT2			BIT(22)
+#define PHIMR_BCNDMAINT1			BIT(21)
+#define PHIMR_BCNDMAINT0			BIT(20)
+#define PHIMR_BCNDOK3				BIT(19)
+#define PHIMR_BCNDOK2				BIT(18)
+#define PHIMR_BCNDOK1				BIT(17)
+#define PHIMR_BCNDOK0				BIT(16)
+#define PHIMR_HSISR_IND_ON			BIT(15)
+#define PHIMR_BCNDMAINT_E			BIT(14)
+#define PHIMR_ATIMEND_E			BIT(13)
+#define PHIMR_ATIM_CTW_END		BIT(12)
+#define PHIMR_HISRE_IND			BIT(11)	/* RO. HISRE Indicator (HISRE & HIMRE is true, this bit is set to 1) */
+#define PHIMR_C2HCMD				BIT(10)
+#define PHIMR_CPWM2				BIT(9)
+#define PHIMR_CPWM					BIT(8)
+#define PHIMR_HIGHDOK				BIT(7)		/* High Queue DMA OK Interrupt */
+#define PHIMR_MGNTDOK				BIT(6)		/* Management Queue DMA OK Interrupt */
+#define PHIMR_BKDOK					BIT(5)		/* AC_BK DMA OK Interrupt */
+#define PHIMR_BEDOK					BIT(4)		/* AC_BE DMA OK Interrupt */
+#define PHIMR_VIDOK					BIT(3)		/* AC_VI DMA OK Interrupt */
+#define PHIMR_VODOK				BIT(2)		/* AC_VO DMA Interrupt */
+#define PHIMR_RDU					BIT(1)		/* Receive Descriptor Unavailable */
+#define PHIMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */
+
+/* PCIE Host Interrupt Status Extension bit */
+#define PHIMR_BCNDMAINT7			BIT(23)
+#define PHIMR_BCNDMAINT6			BIT(22)
+#define PHIMR_BCNDMAINT5			BIT(21)
+#define PHIMR_BCNDMAINT4			BIT(20)
+#define PHIMR_BCNDOK7				BIT(19)
+#define PHIMR_BCNDOK6				BIT(18)
+#define PHIMR_BCNDOK5				BIT(17)
+#define PHIMR_BCNDOK4				BIT(16)
+/* bit12 15: RSVD */
+#define PHIMR_TXERR					BIT(11)
+#define PHIMR_RXERR					BIT(10)
+#define PHIMR_TXFOVW				BIT(9)
+#define PHIMR_RXFOVW				BIT(8)
+/* bit2-7: RSVD */
+#define PHIMR_OCPINT				BIT(1)
+/* bit0: RSVD */
+
+#define UHIMR_TIMEOUT2				BIT(31)
+#define UHIMR_TIMEOUT1				BIT(30)
+#define UHIMR_PSTIMEOUT			BIT(29)
+#define UHIMR_GTINT4				BIT(28)
+#define UHIMR_GTINT3				BIT(27)
+#define UHIMR_TXBCNERR				BIT(26)
+#define UHIMR_TXBCNOK				BIT(25)
+#define UHIMR_TSF_BIT32_TOGGLE	BIT(24)
+#define UHIMR_BCNDMAINT3			BIT(23)
+#define UHIMR_BCNDMAINT2			BIT(22)
+#define UHIMR_BCNDMAINT1			BIT(21)
+#define UHIMR_BCNDMAINT0			BIT(20)
+#define UHIMR_BCNDOK3				BIT(19)
+#define UHIMR_BCNDOK2				BIT(18)
+#define UHIMR_BCNDOK1				BIT(17)
+#define UHIMR_BCNDOK0				BIT(16)
+#define UHIMR_HSISR_IND			BIT(15)
+#define UHIMR_BCNDMAINT_E			BIT(14)
+/* RSVD	BIT(13) */
+#define UHIMR_CTW_END				BIT(12)
+/* RSVD	BIT(11) */
+#define UHIMR_C2HCMD				BIT(10)
+#define UHIMR_CPWM2				BIT(9)
+#define UHIMR_CPWM					BIT(8)
+#define UHIMR_HIGHDOK				BIT(7)		/* High Queue DMA OK Interrupt */
+#define UHIMR_MGNTDOK				BIT(6)		/* Management Queue DMA OK Interrupt */
+#define UHIMR_BKDOK				BIT(5)		/* AC_BK DMA OK Interrupt */
+#define UHIMR_BEDOK				BIT(4)		/* AC_BE DMA OK Interrupt */
+#define UHIMR_VIDOK					BIT(3)		/* AC_VI DMA OK Interrupt */
+#define UHIMR_VODOK				BIT(2)		/* AC_VO DMA Interrupt */
+#define UHIMR_RDU					BIT(1)		/* Receive Descriptor Unavailable */
+#define UHIMR_ROK					BIT(0)		/* Receive DMA OK Interrupt */
+
+/* USB Host Interrupt Status Extension bit */
+#define UHIMR_BCNDMAINT7			BIT(23)
+#define UHIMR_BCNDMAINT6			BIT(22)
+#define UHIMR_BCNDMAINT5			BIT(21)
+#define UHIMR_BCNDMAINT4			BIT(20)
+#define UHIMR_BCNDOK7				BIT(19)
+#define UHIMR_BCNDOK6				BIT(18)
+#define UHIMR_BCNDOK5				BIT(17)
+#define UHIMR_BCNDOK4				BIT(16)
+/* bit14-15: RSVD */
+#define UHIMR_ATIMEND_E			BIT(13)
+#define UHIMR_ATIMEND				BIT(12)
+#define UHIMR_TXERR					BIT(11)
+#define UHIMR_RXERR					BIT(10)
+#define UHIMR_TXFOVW				BIT(9)
+#define UHIMR_RXFOVW				BIT(8)
+/* bit2-7: RSVD */
+#define UHIMR_OCPINT				BIT(1)
+/* bit0: RSVD */
+
+
+#define HAL_NIC_UNPLUG_ISR			0xFFFFFFFF	/* The value when the NIC is unplugged for PCI. */
+#define HAL_NIC_UNPLUG_PCI_ISR		0xEAEAEAEA	/* The value when the NIC is unplugged for PCI in PCI interrupt (page 3). */
+
+/* ----------------------------------------------------------------------------
+ * 8188 IMR/ISR bits
+ * ---------------------------------------------------------------------------- */
+#define IMR_DISABLED_88E			0x0
+/* IMR DW0(0x0060-0063) Bit 0-31 */
+#define IMR_TXCCK_88E				BIT(30)		/* TXRPT interrupt when CCX bit of the packet is set	 */
+#define IMR_PSTIMEOUT_88E			BIT(29)		/* Power Save Time Out Interrupt */
+#define IMR_GTINT4_88E				BIT(28)		/* When GTIMER4 expires, this bit is set to 1	 */
+#define IMR_GTINT3_88E				BIT(27)		/* When GTIMER3 expires, this bit is set to 1	 */
+#define IMR_TBDER_88E				BIT(26)		/* Transmit Beacon0 Error			 */
+#define IMR_TBDOK_88E				BIT(25)		/* Transmit Beacon0 OK			 */
+#define IMR_TSF_BIT32_TOGGLE_88E	BIT(24)		/* TSF Timer BIT32 toggle indication interrupt			 */
+#define IMR_BCNDMAINT0_88E		BIT(20)		/* Beacon DMA Interrupt 0			 */
+#define IMR_BCNDERR0_88E			BIT(16)		/* Beacon Queue DMA Error 0 */
+#define IMR_HSISR_IND_ON_INT_88E	BIT(15)		/* HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)			 */
+#define IMR_BCNDMAINT_E_88E		BIT(14)		/* Beacon DMA Interrupt Extension for Win7			 */
+#define IMR_ATIMEND_88E			BIT(12)		/* CTWidnow End or ATIM Window End */
+#define IMR_HISR1_IND_INT_88E		BIT(11)		/* HISR1 Indicator (HISR1 & HIMR1 is true, this bit is set to 1) */
+#define IMR_C2HCMD_88E				BIT(10)		/* CPU to Host Command INT Status, Write 1 clear	 */
+#define IMR_CPWM2_88E				BIT(9)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
+#define IMR_CPWM_88E				BIT(8)			/* CPU power Mode exchange INT Status, Write 1 clear	 */
+#define IMR_HIGHDOK_88E			BIT(7)			/* High Queue DMA OK	 */
+#define IMR_MGNTDOK_88E			BIT(6)			/* Management Queue DMA OK	 */
+#define IMR_BKDOK_88E				BIT(5)			/* AC_BK DMA OK		 */
+#define IMR_BEDOK_88E				BIT(4)			/* AC_BE DMA OK	 */
+#define IMR_VIDOK_88E				BIT(3)			/* AC_VI DMA OK		 */
+#define IMR_VODOK_88E				BIT(2)			/* AC_VO DMA OK	 */
+#define IMR_RDU_88E					BIT(1)			/* Rx Descriptor Unavailable	 */
+#define IMR_ROK_88E					BIT(0)			/* Receive DMA OK */
+
+/* IMR DW1(0x00B4-00B7) Bit 0-31 */
+#define IMR_BCNDMAINT7_88E		BIT(27)		/* Beacon DMA Interrupt 7 */
+#define IMR_BCNDMAINT6_88E		BIT(26)		/* Beacon DMA Interrupt 6 */
+#define IMR_BCNDMAINT5_88E		BIT(25)		/* Beacon DMA Interrupt 5 */
+#define IMR_BCNDMAINT4_88E		BIT(24)		/* Beacon DMA Interrupt 4 */
+#define IMR_BCNDMAINT3_88E		BIT(23)		/* Beacon DMA Interrupt 3 */
+#define IMR_BCNDMAINT2_88E		BIT(22)		/* Beacon DMA Interrupt 2 */
+#define IMR_BCNDMAINT1_88E		BIT(21)		/* Beacon DMA Interrupt 1 */
+#define IMR_BCNDOK7_88E			BIT(20)		/* Beacon Queue DMA OK Interrupt 7 */
+#define IMR_BCNDOK6_88E			BIT(19)		/* Beacon Queue DMA OK Interrupt 6 */
+#define IMR_BCNDOK5_88E			BIT(18)		/* Beacon Queue DMA OK Interrupt 5 */
+#define IMR_BCNDOK4_88E			BIT(17)		/* Beacon Queue DMA OK Interrupt 4 */
+#define IMR_BCNDOK3_88E			BIT(16)		/* Beacon Queue DMA OK Interrupt 3 */
+#define IMR_BCNDOK2_88E			BIT(15)		/* Beacon Queue DMA OK Interrupt 2 */
+#define IMR_BCNDOK1_88E			BIT(14)		/* Beacon Queue DMA OK Interrupt 1 */
+#define IMR_ATIMEND_E_88E			BIT(13)		/* ATIM Window End Extension for Win7 */
+#define IMR_TXERR_88E				BIT(11)		/* Tx Error Flag Interrupt Status, write 1 clear. */
+#define IMR_RXERR_88E				BIT(10)		/* Rx Error Flag INT Status, Write 1 clear */
+#define IMR_TXFOVW_88E				BIT(9)			/* Transmit FIFO Overflow */
+#define IMR_RXFOVW_88E				BIT(8)			/* Receive FIFO Overflow */
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C,
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+/*
+Based on Datasheet V33---090401
+Register Summary
+Current IOREG MAP
+0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
+0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
+0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
+0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
+0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
+0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
+0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
+0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
+0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
+*/
+/* ---------------------------------------------------------------------------- */
+/*		 8192C (TXPAUSE) transmission pause 	(Offset 0x522, 8 bits) */
+/* ---------------------------------------------------------------------------- */
+/* Note:
+*	The the bits of stoping AC(VO/VI/BE/BK) queue in datasheet RTL8192S/RTL8192C are wrong,
+*	the correct arragement is VO - Bit0, VI - Bit1, BE - Bit2, and BK - Bit3.
+*	8723 and 88E may be not correct either in the eralier version. Confirmed with DD Tim.
+* By Bruce, 2011-09-22. */
+#define StopBecon		BIT(6)
+#define StopHigh			BIT(5)
+#define StopMgt			BIT(4)
+#define StopBK			BIT(3)
+#define StopBE			BIT(2)
+#define StopVI			BIT(1)
+#define StopVO			BIT(0)
+
+/* ----------------------------------------------------------------------------
+ * 8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
+ * ---------------------------------------------------------------------------- */
+#define RCR_APPFCS				BIT(31)	/* WMAC append FCS after pauload */
+#define RCR_APP_MIC				BIT(30)	/* MACRX will retain the MIC at the bottom of the packet. */
+#define RCR_APP_ICV				BIT(29)	/* MACRX will retain the ICV at the bottom of the packet. */
+#define RCR_APP_PHYST_RXFF		BIT(28)	/* PHY Status is appended before RX packet in RXFF */
+#define RCR_APP_BA_SSN			BIT(27)	/* SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC. */
+#define RCR_VHT_DACK			BIT(26)	/* This bit to control response type for vht single mpdu data packet. 1. ACK as response 0. BA as response */
+#define RCR_TCPOFLD_EN			BIT(25)	/* Enable TCP checksum offload */
+#define RCR_ENMBID				BIT(24)	/* Enable Multiple BssId. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries. */
+#define RCR_LSIGEN				BIT(23)	/* Enable LSIG TXOP Protection function. Search KEYCAM for each rx packet to check if LSIGEN bit is set. */
+#define RCR_MFBEN				BIT(22)	/* Enable immediate MCS Feedback function. When Rx packet with MRQ = 1'b1, then search KEYCAM to find sender's MCS Feedback function and send response. */
+#define RCR_DISCHKPPDLLEN		BIT(21)	/* Do not check PPDU while the PPDU length is smaller than 14 byte. */
+#define RCR_PKTCTL_DLEN			BIT(20)	/* While rx path dead lock occurs, reset rx path */
+#define RCR_DISGCLK				BIT(19)	/* Disable macrx clock gating control (no used) */
+#define RCR_TIM_PARSER_EN		BIT(18)	/* RX Beacon TIM Parser. */
+#define RCR_BC_MD_EN			BIT(17)	/* Broadcast data packet more data bit check interrupt enable.*/
+#define RCR_UC_MD_EN			BIT(16)	/* Unicast data packet more data bit check interrupt enable. */
+#define RCR_RXSK_PERPKT			BIT(15)	/* Executing key search per MPDU */
+#define RCR_HTC_LOC_CTRL		BIT(14)	/* MFC<--HTC = 1 MFC-->HTC = 0 */
+#define RCR_AMF					BIT(13)	/* Accept management type frame */
+#define RCR_ACF					BIT(12)	/* Accept control type frame. Control frames BA, BAR, and PS-Poll (when in AP mode) are not controlled by this bit. They are controlled by ADF. */
+#define RCR_ADF					BIT(11)	/* Accept data type frame. This bit also regulates BA, BAR, and PS-Poll (AP mode only). */
+#define RCR_DISDECMYPKT			BIT(10)	/* This bit determines whether hw need to do decryption.1: If A1 match, do decryption.0: Do decryption. */
+#define RCR_AICV					BIT(9)		/* Accept ICV error packet */
+#define RCR_ACRC32				BIT(8)		/* Accept CRC32 error packet */
+#define RCR_CBSSID_BCN			BIT(7)		/* Accept BSSID match packet (Rx beacon, probe rsp) */
+#define RCR_CBSSID_DATA		BIT(6)		/* Accept BSSID match packet (Data) */
+#define RCR_APWRMGT			BIT(5)		/* Accept power management packet */
+#define RCR_ADD3				BIT(4)		/* Accept address 3 match packet */
+#define RCR_AB					BIT(3)		/* Accept broadcast packet */
+#define RCR_AM					BIT(2)		/* Accept multicast packet */
+#define RCR_APM					BIT(1)		/* Accept physical match packet */
+#define RCR_AAP					BIT(0)		/* Accept all unicast packet */
+
+
+/* -----------------------------------------------------
+ *
+ *	0x0000h ~ 0x00FFh	System Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 SYS_ISO_CTRL */
+#define ISO_MD2PP				BIT(0)
+#define ISO_UA2USB				BIT(1)
+#define ISO_UD2CORE				BIT(2)
+#define ISO_PA2PCIE				BIT(3)
+#define ISO_PD2CORE				BIT(4)
+#define ISO_IP2MAC				BIT(5)
+#define ISO_DIOP					BIT(6)
+#define ISO_DIOE					BIT(7)
+#define ISO_EB2CORE				BIT(8)
+#define ISO_DIOR					BIT(9)
+#define PWC_EV12V				BIT(15)
+
+
+/* 2 SYS_FUNC_EN */
+#define FEN_BBRSTB				BIT(0)
+#define FEN_BB_GLB_RSTn		BIT(1)
+#define FEN_USBA				BIT(2)
+#define FEN_UPLL				BIT(3)
+#define FEN_USBD				BIT(4)
+#define FEN_DIO_PCIE			BIT(5)
+#define FEN_PCIEA				BIT(6)
+#define FEN_PPLL					BIT(7)
+#define FEN_PCIED				BIT(8)
+#define FEN_DIOE				BIT(9)
+#define FEN_CPUEN				BIT(10)
+#define FEN_DCORE				BIT(11)
+#define FEN_ELDR				BIT(12)
+#define FEN_EN_25_1				BIT(13)
+#define FEN_HWPDN				BIT(14)
+#define FEN_MREGEN				BIT(15)
+
+/* 2 APS_FSMCO */
+#define PFM_LDALL				BIT(0)
+#define PFM_ALDN				BIT(1)
+#define PFM_LDKP				BIT(2)
+#define PFM_WOWL				BIT(3)
+#define EnPDN					BIT(4)
+#define PDN_PL					BIT(5)
+#define APFM_ONMAC				BIT(8)
+#define APFM_OFF				BIT(9)
+#define APFM_RSM				BIT(10)
+#define AFSM_HSUS				BIT(11)
+#define AFSM_PCIE				BIT(12)
+#define APDM_MAC				BIT(13)
+#define APDM_HOST				BIT(14)
+#define APDM_HPDN				BIT(15)
+#define RDY_MACON				BIT(16)
+#define SUS_HOST				BIT(17)
+#define ROP_ALD					BIT(20)
+#define ROP_PWR					BIT(21)
+#define ROP_SPS					BIT(22)
+#define SOP_MRST				BIT(25)
+#define SOP_FUSE				BIT(26)
+#define SOP_ABG					BIT(27)
+#define SOP_AMB					BIT(28)
+#define SOP_RCK					BIT(29)
+#define SOP_A8M					BIT(30)
+#define XOP_BTCK				BIT(31)
+
+/* 2 SYS_CLKR */
+#define ANAD16V_EN				BIT(0)
+#define ANA8M					BIT(1)
+#define MACSLP					BIT(4)
+#define LOADER_CLK_EN			BIT(5)
+
+
+/* 2 9346CR /REG_SYS_EEPROM_CTRL */
+#define BOOT_FROM_EEPROM		BIT(4)
+#define EEPROMSEL				BIT(4)
+#define EEPROM_EN				BIT(5)
+
+
+/* 2 RF_CTRL */
+#define RF_EN					BIT(0)
+#define RF_RSTB					BIT(1)
+#define RF_SDMRSTB				BIT(2)
+
+
+/* 2 LDOV12D_CTRL */
+#define LDV12_EN				BIT(0)
+#define LDV12_SDBY				BIT(1)
+#define LPLDO_HSM				BIT(2)
+#define LPLDO_LSM_DIS			BIT(3)
+#define _LDV12_VADJ(x)			(((x) & 0xF) << 4)
+
+
+
+/* 2 EFUSE_TEST (For RTL8723 partially) */
+#define EF_TRPT					BIT(7)
+#define EF_CELL_SEL				(BIT(8) | BIT(9)) /* 00: Wifi Efuse, 01: BT Efuse0, 10: BT Efuse1, 11: BT Efuse2 */
+#define LDOE25_EN				BIT(31)
+#define EFUSE_SEL(x)				(((x) & 0x3) << 8)
+#define EFUSE_SEL_MASK			0x300
+#define EFUSE_WIFI_SEL_0		0x0
+#define EFUSE_BT_SEL_0			0x1
+#define EFUSE_BT_SEL_1			0x2
+#define EFUSE_BT_SEL_2			0x3
+
+
+/* 2 8051FWDL
+ * 2 MCUFWDL */
+#define MCUFWDL_EN				BIT(0)
+#define MCUFWDL_RDY			BIT(1)
+#define FWDL_ChkSum_rpt		BIT(2)
+#define MACINI_RDY				BIT(3)
+#define BBINI_RDY				BIT(4)
+#define RFINI_RDY				BIT(5)
+#define WINTINI_RDY				BIT(6)
+#define RAM_DL_SEL				BIT(7)
+#define CPU_DL_READY			BIT(15) /* add flag  by gw for fw download ready 20130826 */
+#define ROM_DLEN				BIT(19)
+#define CPRST					BIT(23)
+
+
+/* 2 REG_SYS_CFG */
+#define XCLK_VLD				BIT(0)
+#define ACLK_VLD				BIT(1)
+#define UCLK_VLD				BIT(2)
+#define PCLK_VLD				BIT(3)
+#define PCIRSTB					BIT(4)
+#define V15_VLD					BIT(5)
+#define SW_OFFLOAD_EN			BIT(7)
+#define SIC_IDLE					BIT(8)
+#define BD_MAC2					BIT(9)
+#define BD_MAC1					BIT(10)
+#define IC_MACPHY_MODE		BIT(11)
+#define CHIP_VER				(BIT(12) | BIT(13) | BIT(14) | BIT(15))
+#define BT_FUNC					BIT(16)
+#define VENDOR_ID				BIT(19)
+#define EXT_VENDOR_ID			(BIT(18) | BIT(19)) /* Currently only for RTL8723B */
+#define PAD_HWPD_IDN			BIT(22)
+#define TRP_VAUX_EN				BIT(23)	/* RTL ID */
+#define TRP_BT_EN				BIT(24)
+#define BD_PKG_SEL				BIT(25)
+#define BD_HCI_SEL				BIT(26)
+#define TYPE_ID					BIT(27)
+#define RF_TYPE_ID				BIT(27)
+
+#define RTL_ID					BIT(23) /* TestChip ID, 1:Test(RLE); 0:MP(RL) */
+#define SPS_SEL					BIT(24) /* 1:LDO regulator mode; 0:Switching regulator mode */
+
+
+#define CHIP_VER_RTL_MASK		0xF000	/* Bit 12 ~ 15 */
+#define CHIP_VER_RTL_SHIFT		12
+#define EXT_VENDOR_ID_SHIFT	18
+
+/* 2 REG_GPIO_OUTSTS (For RTL8723 only) */
+#define EFS_HCI_SEL				(BIT(0) | BIT(1))
+#define PAD_HCI_SEL				(BIT(2) | BIT(3))
+#define HCI_SEL					(BIT(4) | BIT(5))
+#define PKG_SEL_HCI				BIT(6)
+#define FEN_GPS					BIT(7)
+#define FEN_BT					BIT(8)
+#define FEN_WL					BIT(9)
+#define FEN_PCI					BIT(10)
+#define FEN_USB					BIT(11)
+#define BTRF_HWPDN_N			BIT(12)
+#define WLRF_HWPDN_N			BIT(13)
+#define PDN_BT_N				BIT(14)
+#define PDN_GPS_N				BIT(15)
+#define BT_CTL_HWPDN			BIT(16)
+#define GPS_CTL_HWPDN			BIT(17)
+#define PPHY_SUSB				BIT(20)
+#define UPHY_SUSB				BIT(21)
+#define PCI_SUSEN				BIT(22)
+#define USB_SUSEN				BIT(23)
+#define RF_RL_ID					(BIT(31) | BIT(30) | BIT(29) | BIT(28))
+
+
+/* -----------------------------------------------------
+ *
+ *	0x0100h ~ 0x01FFh	MACTOP General Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 Function Enable Registers
+ * 2 CR */
+#define HCI_TXDMA_EN			BIT(0)
+#define HCI_RXDMA_EN			BIT(1)
+#define TXDMA_EN				BIT(2)
+#define RXDMA_EN				BIT(3)
+#define PROTOCOL_EN				BIT(4)
+#define SCHEDULE_EN				BIT(5)
+#define MACTXEN					BIT(6)
+#define MACRXEN					BIT(7)
+#define ENSWBCN					BIT(8)
+#define ENSEC					BIT(9)
+#define CALTMR_EN				BIT(10)	/* 32k CAL TMR enable */
+
+/* Network type */
+#define _NETTYPE(x)				(((x) & 0x3) << 16)
+#define MASK_NETTYPE			0x30000
+#define NT_NO_LINK				0x0
+#define NT_LINK_AD_HOC			0x1
+#define NT_LINK_AP				0x2
+#define NT_AS_AP				0x3
+
+/* 2 PBP - Page Size Register */
+#define GET_RX_PAGE_SIZE(value)			((value) & 0xF)
+#define GET_TX_PAGE_SIZE(value)			(((value) & 0xF0) >> 4)
+#define _PSRX_MASK				0xF
+#define _PSTX_MASK				0xF0
+#define _PSRX(x)				(x)
+#define _PSTX(x)				((x) << 4)
+
+#define PBP_64					0x0
+#define PBP_128					0x1
+#define PBP_256					0x2
+#define PBP_512					0x3
+#define PBP_1024				0x4
+
+
+/* 2 TX/RXDMA */
+#define RXDMA_ARBBW_EN		BIT(0)
+#define RXSHFT_EN				BIT(1)
+#define RXDMA_AGG_EN			BIT(2)
+#define QS_VO_QUEUE			BIT(8)
+#define QS_VI_QUEUE				BIT(9)
+#define QS_BE_QUEUE			BIT(10)
+#define QS_BK_QUEUE			BIT(11)
+#define QS_MANAGER_QUEUE		BIT(12)
+#define QS_HIGH_QUEUE			BIT(13)
+
+#define HQSEL_VOQ				BIT(0)
+#define HQSEL_VIQ				BIT(1)
+#define HQSEL_BEQ				BIT(2)
+#define HQSEL_BKQ				BIT(3)
+#define HQSEL_MGTQ				BIT(4)
+#define HQSEL_HIQ				BIT(5)
+
+/* For normal driver, 0x10C */
+#define _TXDMA_CMQ_MAP(x)			(((x) & 0x3) << 16)
+#define _TXDMA_HIQ_MAP(x)			(((x) & 0x3) << 14)
+#define _TXDMA_MGQ_MAP(x)			(((x) & 0x3) << 12)
+#define _TXDMA_BKQ_MAP(x)			(((x) & 0x3) << 10)
+#define _TXDMA_BEQ_MAP(x)			(((x) & 0x3) << 8)
+#define _TXDMA_VIQ_MAP(x)			(((x) & 0x3) << 6)
+#define _TXDMA_VOQ_MAP(x)			(((x) & 0x3) << 4)
+
+#define QUEUE_EXTRA				0
+#define QUEUE_LOW				1
+#define QUEUE_NORMAL			2
+#define QUEUE_HIGH				3
+
+
+/* 2 TRXFF_BNDY */
+
+
+/* 2 LLT_INIT */
+#define _LLT_NO_ACTIVE				0x0
+#define _LLT_WRITE_ACCESS			0x1
+#define _LLT_READ_ACCESS			0x2
+
+#define _LLT_INIT_DATA(x)			((x) & 0xFF)
+#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
+#define _LLT_OP(x)					(((x) & 0x3) << 30)
+#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
+
+
+/* -----------------------------------------------------
+ *
+ *	0x0200h ~ 0x027Fh	TXDMA Configuration
+ *
+ * ----------------------------------------------------- */
+/* 2 RQPN */
+#define _HPQ(x)					((x) & 0xFF)
+#define _LPQ(x)					(((x) & 0xFF) << 8)
+#define _PUBQ(x)					(((x) & 0xFF) << 16)
+#define _NPQ(x)					((x) & 0xFF)			/* NOTE: in RQPN_NPQ register */
+#define _EPQ(x)					(((x) & 0xFF) << 16)	/* NOTE: in RQPN_EPQ register */
+
+
+#define HPQ_PUBLIC_DIS			BIT(24)
+#define LPQ_PUBLIC_DIS			BIT(25)
+#define LD_RQPN					BIT(31)
+
+
+/* 2 TDECTL */
+#define BLK_DESC_NUM_SHIFT			4
+#define BLK_DESC_NUM_MASK			0xF
+
+
+/* 2 TXDMA_OFFSET_CHK */
+#define DROP_DATA_EN				BIT(9)
+
+/* 2 AUTO_LLT */
+#define BIT_SHIFT_TXPKTNUM 24
+#define BIT_MASK_TXPKTNUM 0xff
+#define BIT_TXPKTNUM(x) (((x) & BIT_MASK_TXPKTNUM) << BIT_SHIFT_TXPKTNUM)
+
+#define BIT_TDE_DBG_SEL BIT(23)
+#define BIT_AUTO_INIT_LLT BIT(16)
+
+#define BIT_SHIFT_Tx_OQT_free_space 8
+#define BIT_MASK_Tx_OQT_free_space 0xff
+#define BIT_Tx_OQT_free_space(x) (((x) & BIT_MASK_Tx_OQT_free_space) << BIT_SHIFT_Tx_OQT_free_space)
+
+
+/* -----------------------------------------------------
+ *
+ *	0x0280h ~ 0x028Bh	RX DMA Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 REG_RXDMA_CONTROL, 0x0286h
+ * Write only. When this bit is set, RXDMA will decrease RX PKT counter by one. Before
+ * this bit is polled, FW shall update RXFF_RD_PTR first. This register is write pulse and auto clear.
+ * #define RXPKT_RELEASE_POLL			BIT(0)
+ * Read only. When RXMA finishes on-going DMA operation, RXMDA will report idle state in
+ * this bit. FW can start releasing packets after RXDMA entering idle mode.
+ * #define RXDMA_IDLE					BIT(1)
+ * When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host
+ * completed, and stop DMA packet to host. RXDMA will then report Default: 0;
+ * #define RW_RELEASE_EN				BIT(2) */
+
+/* 2 REG_RXPKT_NUM, 0x0284 */
+#define	RXPKT_RELEASE_POLL	BIT(16)
+#define	RXDMA_IDLE				BIT(17)
+#define	RW_RELEASE_EN			BIT(18)
+
+/* -----------------------------------------------------
+ *
+ *	0x0400h ~ 0x047Fh	Protocol Configuration
+ *
+ * ----------------------------------------------------- */
+/* 2 FWHW_TXQ_CTRL */
+#define EN_AMPDU_RTY_NEW			BIT(7)
+
+
+/* 2 SPEC SIFS */
+#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
+#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
+
+/* 2 RL */
+#define	RETRY_LIMIT_SHORT_SHIFT			8
+#define	RETRY_LIMIT_LONG_SHIFT			0
+
+/* -----------------------------------------------------
+ *
+ *	0x0500h ~ 0x05FFh	EDCA Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 EDCA setting */
+#define AC_PARAM_TXOP_LIMIT_OFFSET		16
+#define AC_PARAM_ECW_MAX_OFFSET			12
+#define AC_PARAM_ECW_MIN_OFFSET			8
+#define AC_PARAM_AIFS_OFFSET				0
+
+
+#define _LRL(x)					((x) & 0x3F)
+#define _SRL(x)					(((x) & 0x3F) << 8)
+
+
+/* 2 BCN_CTRL */
+#define EN_TXBCN_RPT			BIT(2)
+#define EN_BCN_FUNCTION		BIT(3)
+#define STOP_BCNQ				BIT(6)
+#define DIS_RX_BSSID_FIT		BIT(6)
+
+#define DIS_ATIM					BIT(0)
+#define DIS_BCNQ_SUB			BIT(1)
+#define DIS_TSF_UDT				BIT(4)
+
+/* The same function but different bit field. */
+#define DIS_TSF_UDT0_NORMAL_CHIP	BIT(4)
+#define DIS_TSF_UDT0_TEST_CHIP	BIT(5)
+
+
+/* 2 ACMHWCTRL */
+#define AcmHw_HwEn				BIT(0)
+#define AcmHw_BeqEn			BIT(1)
+#define AcmHw_ViqEn				BIT(2)
+#define AcmHw_VoqEn			BIT(3)
+#define AcmHw_BeqStatus		BIT(4)
+#define AcmHw_ViqStatus			BIT(5)
+#define AcmHw_VoqStatus		BIT(6)
+
+/* 2 */ /* REG_DUAL_TSF_RST (0x553) */
+#define DUAL_TSF_RST_P2P		BIT(4)
+
+/* 2 */ /* REG_NOA_DESC_SEL (0x5CF) */
+#define NOA_DESC_SEL_0			0
+#define NOA_DESC_SEL_1			BIT(4)
+
+/* -----------------------------------------------------
+ *
+ *	0x0600h ~ 0x07FFh	WMAC Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 APSD_CTRL */
+#define APSDOFF					BIT(6)
+
+/* 2 TCR */
+#define TSFRST					BIT(0)
+#define DIS_GCLK					BIT(1)
+#define PAD_SEL					BIT(2)
+#define PWR_ST					BIT(6)
+#define PWRBIT_OW_EN			BIT(7)
+#define ACRC						BIT(8)
+#define CFENDFORM				BIT(9)
+#define ICV						BIT(10)
+
+
+/* 2 RCR */
+#define AAP						BIT(0)
+#define APM						BIT(1)
+#define AM						BIT(2)
+#define AB						BIT(3)
+#define ADD3						BIT(4)
+#define APWRMGT				BIT(5)
+#define CBSSID					BIT(6)
+#define CBSSID_DATA				BIT(6)
+#define CBSSID_BCN				BIT(7)
+#define ACRC32					BIT(8)
+#define AICV						BIT(9)
+#define ADF						BIT(11)
+#define ACF						BIT(12)
+#define AMF						BIT(13)
+#define HTC_LOC_CTRL			BIT(14)
+#define UC_DATA_EN				BIT(16)
+#define BM_DATA_EN				BIT(17)
+#define MFBEN					BIT(22)
+#define LSIGEN					BIT(23)
+#define EnMBID					BIT(24)
+#define FORCEACK				BIT(26)
+#define APP_BASSN				BIT(27)
+#define APP_PHYSTS				BIT(28)
+#define APP_ICV					BIT(29)
+#define APP_MIC					BIT(30)
+#define APP_FCS					BIT(31)
+
+
+/* 2 SECCFG */
+#define SCR_TxUseDK				BIT(0)			/* Force Tx Use Default Key */
+#define SCR_RxUseDK				BIT(1)			/* Force Rx Use Default Key */
+#define SCR_TxEncEnable			BIT(2)			/* Enable Tx Encryption */
+#define SCR_RxDecEnable			BIT(3)			/* Enable Rx Decryption */
+#define SCR_SKByA2				BIT(4)			/* Search kEY BY A2 */
+#define SCR_NoSKMC				BIT(5)			/* No Key Search Multicast */
+#define SCR_TXBCUSEDK			BIT(6)			/* Force Tx Broadcast packets Use Default Key */
+#define SCR_RXBCUSEDK			BIT(7)			/* Force Rx Broadcast packets Use Default Key */
+#define SCR_CHK_KEYID			BIT(8)
+#define SCR_CHK_BMC				BIT(9)			/* add option to support a2+keyid+bcm */
+
+/*REG_MBIDCAMCFG           (Offset 0x0628/0x62C)*/
+#define BIT_MBIDCAM_POLL		BIT(31)
+#define BIT_MBIDCAM_WT_EN		BIT(30)
+
+#define MBIDCAM_ADDR_MASK		0x1F
+#define MBIDCAM_ADDR_SHIFT		24
+
+#define BIT_MBIDCAM_VALID		BIT(23)
+#define BIT_LSIC_TXOP_EN		BIT(17)
+#define BIT_CTS_EN				BIT(16)
+
+/* -----------------------------------------------------
+ *
+ *	SDIO Bus Specification
+ *
+ * ----------------------------------------------------- */
+
+/* I/O bus domain address mapping */
+#define SDIO_LOCAL_BASE		0x10250000
+#define WLAN_IOREG_BASE		0x10260000
+#define FIRMWARE_FIFO_BASE	0x10270000
+#define TX_HIQ_BASE				0x10310000
+#define TX_MIQ_BASE				0x10320000
+#define TX_LOQ_BASE				0x10330000
+#define TX_EPQ_BASE				0x10350000
+#define RX_RX0FF_BASE			0x10340000
+
+/* SDIO host local register space mapping. */
+#define SDIO_LOCAL_MSK				0x0FFF
+#define WLAN_IOREG_MSK		0x7FFF
+#define WLAN_FIFO_MSK			      	0x1FFF	/* Aggregation Length[12:0] */
+#define WLAN_RX0FF_MSK				0x0003
+
+#define SDIO_WITHOUT_REF_DEVICE_ID	0	/* Without reference to the SDIO Device ID */
+#define SDIO_LOCAL_DEVICE_ID           		0	/* 0b[16], 000b[15:13] */
+#define WLAN_TX_HIQ_DEVICE_ID			4	/* 0b[16], 100b[15:13] */
+#define WLAN_TX_MIQ_DEVICE_ID 		5	/* 0b[16], 101b[15:13] */
+#define WLAN_TX_LOQ_DEVICE_ID 		6	/* 0b[16], 110b[15:13] */
+#define WLAN_TX_EXQ_DEVICE_ID		3	/* 0b[16], 011b[15:13] */
+#define WLAN_RX0FF_DEVICE_ID 			7	/* 0b[16], 111b[15:13] */
+#define WLAN_IOREG_DEVICE_ID 			8	/* 1b[16] */
+
+/* SDIO Tx Free Page Index */
+#define HI_QUEUE_IDX			0
+#define MID_QUEUE_IDX			1
+#define LOW_QUEUE_IDX				2
+#define PUBLIC_QUEUE_IDX			3
+
+#define SDIO_MAX_TX_QUEUE			3		/* HIQ, MIQ and LOQ */
+#define SDIO_MAX_RX_QUEUE			1
+
+#define SDIO_REG_TX_CTRL			0x0000 /* SDIO Tx Control */
+#define SDIO_REG_HIMR				0x0014 /* SDIO Host Interrupt Mask */
+#define SDIO_REG_HISR				0x0018 /* SDIO Host Interrupt Service Routine */
+#define SDIO_REG_HCPWM			0x0019 /* HCI Current Power Mode */
+#define SDIO_REG_RX0_REQ_LEN		0x001C /* RXDMA Request Length */
+#define SDIO_REG_OQT_FREE_PG		0x001E /* OQT Free Page */
+#define SDIO_REG_FREE_TXPG			0x0020 /* Free Tx Buffer Page */
+#define SDIO_REG_HCPWM1			0x0024 /* HCI Current Power Mode 1 */
+#define SDIO_REG_HCPWM2			0x0026 /* HCI Current Power Mode 2 */
+#define SDIO_REG_FREE_TXPG_SEQ	0x0028 /* Free Tx Page Sequence */
+#define SDIO_REG_HTSFR_INFO		0x0030 /* HTSF Informaion */
+#define SDIO_REG_HRPWM1			0x0080 /* HCI Request Power Mode 1 */
+#define SDIO_REG_HRPWM2			0x0082 /* HCI Request Power Mode 2 */
+#define SDIO_REG_HPS_CLKR			0x0084 /* HCI Power Save Clock */
+#define SDIO_REG_HSUS_CTRL			0x0086 /* SDIO HCI Suspend Control */
+#define SDIO_REG_HIMR_ON			0x0090 /* SDIO Host Extension Interrupt Mask Always */
+#define SDIO_REG_HISR_ON			0x0091 /* SDIO Host Extension Interrupt Status Always */
+
+#define SDIO_HIMR_DISABLED			0
+
+/* RTL8723/RTL8188E SDIO Host Interrupt Mask Register */
+#define SDIO_HIMR_RX_REQUEST_MSK		BIT(0)
+#define SDIO_HIMR_AVAL_MSK			BIT(1)
+#define SDIO_HIMR_TXERR_MSK			BIT(2)
+#define SDIO_HIMR_RXERR_MSK			BIT(3)
+#define SDIO_HIMR_TXFOVW_MSK			BIT(4)
+#define SDIO_HIMR_RXFOVW_MSK			BIT(5)
+#define SDIO_HIMR_TXBCNOK_MSK			BIT(6)
+#define SDIO_HIMR_TXBCNERR_MSK		BIT(7)
+#define SDIO_HIMR_BCNERLY_INT_MSK		BIT(16)
+#define SDIO_HIMR_C2HCMD_MSK			BIT(17)
+#define SDIO_HIMR_CPWM1_MSK			BIT(18)
+#define SDIO_HIMR_CPWM2_MSK			BIT(19)
+#define SDIO_HIMR_HSISR_IND_MSK		BIT(20)
+#define SDIO_HIMR_GTINT3_IND_MSK		BIT(21)
+#define SDIO_HIMR_GTINT4_IND_MSK		BIT(22)
+#define SDIO_HIMR_PSTIMEOUT_MSK		BIT(23)
+#define SDIO_HIMR_OCPINT_MSK			BIT(24)
+#define SDIO_HIMR_ATIMEND_MSK			BIT(25)
+#define SDIO_HIMR_ATIMEND_E_MSK		BIT(26)
+#define SDIO_HIMR_CTWEND_MSK			BIT(27)
+
+/* RTL8188E SDIO Specific */
+#define SDIO_HIMR_MCU_ERR_MSK			BIT(28)
+#define SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT(29)
+
+/* SDIO Host Interrupt Service Routine */
+#define SDIO_HISR_RX_REQUEST			BIT(0)
+#define SDIO_HISR_AVAL					BIT(1)
+#define SDIO_HISR_TXERR					BIT(2)
+#define SDIO_HISR_RXERR					BIT(3)
+#define SDIO_HISR_TXFOVW				BIT(4)
+#define SDIO_HISR_RXFOVW				BIT(5)
+#define SDIO_HISR_TXBCNOK				BIT(6)
+#define SDIO_HISR_TXBCNERR				BIT(7)
+#define SDIO_HISR_BCNERLY_INT			BIT(16)
+#define SDIO_HISR_C2HCMD				BIT(17)
+#define SDIO_HISR_CPWM1				BIT(18)
+#define SDIO_HISR_CPWM2				BIT(19)
+#define SDIO_HISR_HSISR_IND			BIT(20)
+#define SDIO_HISR_GTINT3_IND			BIT(21)
+#define SDIO_HISR_GTINT4_IND			BIT(22)
+#define SDIO_HISR_PSTIMEOUT			BIT(23)
+#define SDIO_HISR_OCPINT				BIT(24)
+#define SDIO_HISR_ATIMEND				BIT(25)
+#define SDIO_HISR_ATIMEND_E			BIT(26)
+#define SDIO_HISR_CTWEND				BIT(27)
+
+/* RTL8188E SDIO Specific */
+#define SDIO_HISR_MCU_ERR				BIT(28)
+#define SDIO_HISR_TSF_BIT32_TOGGLE	BIT(29)
+
+#define MASK_SDIO_HISR_CLEAR		(SDIO_HISR_TXERR |\
+		SDIO_HISR_RXERR |\
+		SDIO_HISR_TXFOVW |\
+		SDIO_HISR_RXFOVW |\
+		SDIO_HISR_TXBCNOK |\
+		SDIO_HISR_TXBCNERR |\
+		SDIO_HISR_C2HCMD |\
+		SDIO_HISR_CPWM1 |\
+		SDIO_HISR_CPWM2 |\
+		SDIO_HISR_HSISR_IND |\
+		SDIO_HISR_GTINT3_IND |\
+		SDIO_HISR_GTINT4_IND |\
+		SDIO_HISR_PSTIMEOUT |\
+		SDIO_HISR_OCPINT)
+
+/* SDIO HCI Suspend Control Register */
+#define HCI_RESUME_PWR_RDY			BIT(1)
+#define HCI_SUS_CTRL					BIT(0)
+
+/* SDIO Tx FIFO related */
+#define SDIO_TX_FREE_PG_QUEUE			4	/* The number of Tx FIFO free page */
+#define SDIO_TX_FIFO_PAGE_SZ			128
+
+	#define MAX_TX_AGG_PACKET_NUMBER	0xFF
+	#define MAX_TX_AGG_PACKET_NUMBER_8812	64
+
+/* -----------------------------------------------------
+ *
+ *	0xFE00h ~ 0xFE55h	USB Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* 2 USB Information (0xFE17) */
+#define USB_IS_HIGH_SPEED			0
+#define USB_IS_FULL_SPEED			1
+#define USB_SPEED_MASK				BIT(5)
+
+#define USB_NORMAL_SIE_EP_MASK	0xF
+#define USB_NORMAL_SIE_EP_SHIFT	4
+
+/* 2 Special Option */
+#define USB_AGG_EN				BIT(3)
+
+/* 0; Use interrupt endpoint to upload interrupt pkt
+ * 1; Use bulk endpoint to upload interrupt pkt, */
+#define INT_BULK_SEL			BIT(4)
+
+/* 2REG_C2HEVT_CLEAR */
+#define C2H_EVT_HOST_CLOSE		0x00	/* Set by driver and notify FW that the driver has read the C2H command message */
+#define C2H_EVT_FW_CLOSE		0xFF	/* Set by FW indicating that FW had set the C2H command message and it's not yet read by driver. */
+
+
+/* 2REG_MULTI_FUNC_CTRL(For RTL8723 Only) */
+#define WL_HWPDN_EN			BIT(0)	/* Enable GPIO[9] as WiFi HW PDn source */
+#define WL_HWPDN_SL			BIT(1)	/* WiFi HW PDn polarity control */
+#define WL_FUNC_EN				BIT(2)	/* WiFi function enable */
+#define WL_HWROF_EN			BIT(3)	/* Enable GPIO[9] as WiFi RF HW PDn source */
+#define BT_HWPDN_EN			BIT(16)	/* Enable GPIO[11] as BT HW PDn source */
+#define BT_HWPDN_SL			BIT(17)	/* BT HW PDn polarity control */
+#define BT_FUNC_EN				BIT(18)	/* BT function enable */
+#define BT_HWROF_EN			BIT(19)	/* Enable GPIO[11] as BT/GPS RF HW PDn source */
+#define GPS_HWPDN_EN			BIT(20)	/* Enable GPIO[10] as GPS HW PDn source */
+#define GPS_HWPDN_SL			BIT(21)	/* GPS HW PDn polarity control */
+#define GPS_FUNC_EN			BIT(22)	/* GPS function enable */
+
+/* 3 REG_LIFECTRL_CTRL */
+#define HAL92C_EN_PKT_LIFE_TIME_BK		BIT(3)
+#define HAL92C_EN_PKT_LIFE_TIME_BE		BIT(2)
+#define HAL92C_EN_PKT_LIFE_TIME_VI		BIT(1)
+#define HAL92C_EN_PKT_LIFE_TIME_VO		BIT(0)
+
+#define HAL92C_MSDU_LIFE_TIME_UNIT		128	/* in us, said by Tim. */
+
+/* 2 8192D PartNo. */
+#define PARTNO_92D_NIC							(BIT7 | BIT6)
+#define PARTNO_92D_NIC_REMARK				(BIT5 | BIT4)
+#define PARTNO_SINGLE_BAND_VS				BIT(3)
+#define PARTNO_SINGLE_BAND_VS_REMARK		BIT(1)
+#define PARTNO_CONCURRENT_BAND_VC			(BIT3 | BIT2)
+#define PARTNO_CONCURRENT_BAND_VC_REMARK	(BIT1 | BIT0)
+
+/* ********************************************************
+ * General definitions
+ * ******************************************************** */
+
+	#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E(__Adapter)	(175)
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8703B		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188F		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723D		255
+
+#define POLLING_LLT_THRESHOLD				20
+#define POLLING_READY_TIMEOUT_COUNT		1000
+
+
+/* GPIO BIT */
+#define	HAL_8812A_HW_GPIO_WPS_BIT	BIT(2)
+#define	HAL_8192C_HW_GPIO_WPS_BIT	BIT(2)
+#define	HAL_8192EU_HW_GPIO_WPS_BIT	BIT(7)
+#define	HAL_8188E_HW_GPIO_WPS_BIT	BIT(7)
+
+#endif /* __HAL_COMMON_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_data.h b/drivers/staging/rtl8188eu/include/hal_data.h
new file mode 100755
index 000000000000..b2a089dcc023
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_data.h
@@ -0,0 +1,901 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_DATA_H__
+#define __HAL_DATA_H__
+
+#include "../hal/phydm_precomp.h"
+#ifdef CONFIG_BT_COEXIST
+	#include <hal_btcoex.h>
+#endif
+
+/*
+ * <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
+ *   */
+typedef enum _RT_MULTI_FUNC {
+	RT_MULTI_FUNC_NONE	= 0x00,
+	RT_MULTI_FUNC_WIFI	= 0x01,
+	RT_MULTI_FUNC_BT		= 0x02,
+	RT_MULTI_FUNC_GPS	= 0x04,
+} RT_MULTI_FUNC, *PRT_MULTI_FUNC;
+/*
+ * <Roger_Notes> For RTL8723 WiFi PDn/GPIO polarity control configuration. 2010.10.08.
+ *   */
+typedef enum _RT_POLARITY_CTL {
+	RT_POLARITY_LOW_ACT	= 0,
+	RT_POLARITY_HIGH_ACT	= 1,
+} RT_POLARITY_CTL, *PRT_POLARITY_CTL;
+
+/* For RTL8723 regulator mode. by tynli. 2011.01.14. */
+typedef enum _RT_REGULATOR_MODE {
+	RT_SWITCHING_REGULATOR	= 0,
+	RT_LDO_REGULATOR			= 1,
+} RT_REGULATOR_MODE, *PRT_REGULATOR_MODE;
+
+/*
+ * Interface type.
+ *   */
+typedef	enum _INTERFACE_SELECT_PCIE {
+	INTF_SEL0_SOLO_MINICARD			= 0,		/* WiFi solo-mCard */
+	INTF_SEL1_BT_COMBO_MINICARD		= 1,		/* WiFi+BT combo-mCard */
+	INTF_SEL2_PCIe						= 2,		/* PCIe Card */
+} INTERFACE_SELECT_PCIE, *PINTERFACE_SELECT_PCIE;
+
+
+typedef	enum _INTERFACE_SELECT_USB {
+	INTF_SEL0_USB 				= 0,		/* USB */
+	INTF_SEL1_USB_High_Power  	= 1,		/* USB with high power PA */
+	INTF_SEL2_MINICARD		  	= 2,		/* Minicard */
+	INTF_SEL3_USB_Solo 		= 3,		/* USB solo-Slim module */
+	INTF_SEL4_USB_Combo		= 4,		/* USB Combo-Slim module */
+	INTF_SEL5_USB_Combo_MF	= 5,		/* USB WiFi+BT Multi-Function Combo, i.e., Proprietary layout(AS-VAU) which is the same as SDIO card */
+} INTERFACE_SELECT_USB, *PINTERFACE_SELECT_USB;
+
+typedef enum _RT_AMPDU_BRUST_MODE {
+	RT_AMPDU_BRUST_NONE		= 0,
+	RT_AMPDU_BRUST_92D		= 1,
+	RT_AMPDU_BRUST_88E		= 2,
+	RT_AMPDU_BRUST_8812_4	= 3,
+	RT_AMPDU_BRUST_8812_8	= 4,
+	RT_AMPDU_BRUST_8812_12	= 5,
+	RT_AMPDU_BRUST_8812_15	= 6,
+	RT_AMPDU_BRUST_8723B		= 7,
+} RT_AMPDU_BRUST, *PRT_AMPDU_BRUST_MODE;
+
+/* Tx Power Limit Table Size */
+#define MAX_REGULATION_NUM						4
+#define MAX_RF_PATH_NUM_IN_POWER_LIMIT_TABLE	4
+#define MAX_2_4G_BANDWIDTH_NUM					2
+#define MAX_RATE_SECTION_NUM						10
+#define MAX_5G_BANDWIDTH_NUM						4
+
+#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			10 /* CCK:1, OFDM:1, HT:4, VHT:4 */
+#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			9 /* OFDM:1, HT:4, VHT:4 */
+
+
+/* ###### duplicate code,will move to ODM ######### */
+/* #define IQK_MAC_REG_NUM		4 */
+/* #define IQK_ADDA_REG_NUM		16 */
+
+/* #define IQK_BB_REG_NUM			10 */
+#define IQK_BB_REG_NUM_92C	9
+#define IQK_BB_REG_NUM_92D	10
+#define IQK_BB_REG_NUM_test	6
+
+#define IQK_Matrix_Settings_NUM_92D	(1+24+21)
+
+/* #define HP_THERMAL_NUM		8 */
+/* ###### duplicate code,will move to ODM ######### */
+
+#ifdef RTW_RX_AGGREGATION
+typedef enum _RX_AGG_MODE {
+	RX_AGG_DISABLE,
+	RX_AGG_DMA,
+	RX_AGG_USB,
+	RX_AGG_MIX
+} RX_AGG_MODE;
+
+/* #define MAX_RX_DMA_BUFFER_SIZE	10240 */		/* 10K for 8192C RX DMA buffer */
+
+#endif /* RTW_RX_AGGREGATION */
+
+/* E-Fuse */
+#define EFUSE_MAP_SIZE	512
+
+#define EFUSE_MAX_SIZE	256
+/* end of E-Fuse */
+
+#define Mac_OFDM_OK			0x00000000
+#define Mac_OFDM_Fail		0x10000000
+#define Mac_OFDM_FasleAlarm	0x20000000
+#define Mac_CCK_OK			0x30000000
+#define Mac_CCK_Fail		0x40000000
+#define Mac_CCK_FasleAlarm	0x50000000
+#define Mac_HT_OK			0x60000000
+#define Mac_HT_Fail			0x70000000
+#define Mac_HT_FasleAlarm	0x90000000
+#define Mac_DropPacket		0xA0000000
+
+/* For store initial value of BB register */
+typedef struct _BB_INIT_REGISTER {
+	u16	offset;
+	u32	value;
+
+} BB_INIT_REGISTER, *PBB_INIT_REGISTER;
+
+#define PAGE_SIZE_128	128
+#define PAGE_SIZE_256	256
+#define PAGE_SIZE_512	512
+
+#define HCI_SUS_ENTER		0
+#define HCI_SUS_LEAVING		1
+#define HCI_SUS_LEAVE		2
+#define HCI_SUS_ENTERING	3
+#define HCI_SUS_ERR			4
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+typedef enum _ACS_OP {
+	ACS_INIT,		/*ACS - Variable init*/
+	ACS_RESET,		/*ACS - NHM Counter reset*/
+	ACS_SELECT,		/*ACS - NHM Counter Statistics */
+} ACS_OP;
+
+typedef enum _ACS_STATE {
+	ACS_DISABLE,
+	ACS_ENABLE,
+} ACS_STATE;
+
+struct auto_chan_sel {
+	ATOMIC_T state;
+	u8	ch; /* previous channel*/
+};
+#endif /*CONFIG_AUTO_CHNL_SEL_NHM*/
+
+#define EFUSE_FILE_UNUSED 0
+#define EFUSE_FILE_FAILED 1
+#define EFUSE_FILE_LOADED 2
+
+#define MACADDR_FILE_UNUSED 0
+#define MACADDR_FILE_FAILED 1
+#define MACADDR_FILE_LOADED 2
+
+#define KFREE_FLAG_ON				BIT(0)
+#define KFREE_FLAG_THERMAL_K_ON		BIT(1)
+
+#define MAX_IQK_INFO_BACKUP_CHNL_NUM	5
+#define MAX_IQK_INFO_BACKUP_REG_NUM		10
+
+struct kfree_data_t {
+	u8 flag;
+	s8 bb_gain[BB_GAIN_NUM][RF_PATH_MAX];
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	s8 pa_bias_5g[RF_PATH_MAX];
+	s8 pad_bias_5g[RF_PATH_MAX];
+#endif
+	s8 thermal;
+};
+
+bool kfree_data_is_bb_gain_empty(struct kfree_data_t *data);
+
+struct hal_spec_t {
+	char *ic_name;
+	u8 macid_num;
+
+	u8 sec_cam_ent_num;
+	u8 sec_cap;
+
+	u8 rfpath_num_2g:4;	/* used for tx power index path */
+	u8 rfpath_num_5g:4;	/* used for tx power index path */
+
+	u8 max_tx_cnt;
+	u8 tx_nss_num:4;
+	u8 rx_nss_num:4;
+	u8 band_cap;	/* value of BAND_CAP_XXX */
+	u8 bw_cap;		/* value of BW_CAP_XXX */
+	u8 port_num;
+	u8 proto_cap;	/* value of PROTO_CAP_XXX */
+	u8 wl_func;		/* value of WL_FUNC_XXX */
+	u8 hci_type;	/* value of HCI Type */
+};
+
+#define HAL_SPEC_CHK_RF_PATH_2G(_spec, _path) ((_spec)->rfpath_num_2g > (_path))
+#define HAL_SPEC_CHK_RF_PATH_5G(_spec, _path) ((_spec)->rfpath_num_5g > (_path))
+#define HAL_SPEC_CHK_RF_PATH(_spec, _band, _path) ( \
+	_band == BAND_ON_2_4G ? HAL_SPEC_CHK_RF_PATH_2G(_spec, _path) : \
+	_band == BAND_ON_5G ? HAL_SPEC_CHK_RF_PATH_5G(_spec, _path) : 0)
+
+#define HAL_SPEC_CHK_TX_CNT(_spec, _cnt_idx) ((_spec)->max_tx_cnt > (_cnt_idx))
+
+#ifdef CONFIG_PHY_CAPABILITY_QUERY
+struct phy_spec_t {
+	u32 trx_cap;
+	u32 stbc_cap;
+	u32 ldpc_cap;
+	u32 txbf_param;
+	u32 txbf_cap;
+};
+#endif
+struct hal_iqk_reg_backup {
+	u8 central_chnl;
+	u8 bw_mode;
+	u32 reg_backup[MAX_RF_PATH][MAX_IQK_INFO_BACKUP_REG_NUM];
+};
+
+typedef struct hal_com_data {
+	HAL_VERSION			version_id;
+	RT_MULTI_FUNC		MultiFunc; /* For multi-function consideration. */
+	RT_POLARITY_CTL		PolarityCtl; /* For Wifi PDn Polarity control. */
+	RT_REGULATOR_MODE	RegulatorMode; /* switching regulator or LDO */
+	u8	hw_init_completed;
+	/****** FW related ******/
+	u16 firmware_version;
+	u16	FirmwareVersionRev;
+	u16 firmware_sub_version;
+	u16	FirmwareSignature;
+	u8	RegFWOffload;
+	u8	fw_ractrl;
+	u8	FwRsvdPageStartOffset; /* 2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.*/
+	u8	LastHMEBoxNum;	/* H2C - for host message to fw */
+
+	/****** current WIFI_PHY values ******/
+	WIRELESS_MODE	CurrentWirelessMode;
+	CHANNEL_WIDTH	current_channel_bw;
+	BAND_TYPE		current_band_type;	/* 0:2.4G, 1:5G */
+	BAND_TYPE		BandSet;
+	u8				current_channel;
+	u8				cch_20;
+	u8				cch_40;
+	u8				cch_80;
+	u8				CurrentCenterFrequencyIndex1;
+	u8				nCur40MhzPrimeSC;	/* Control channel sub-carrier */
+	u8				nCur80MhzPrimeSC;   /* used for primary 40MHz of 80MHz mode */
+	bool		bSwChnlAndSetBWInProgress;
+	u8				bDisableSWChannelPlan; /* flag of disable software change channel plan	 */
+	u16				BasicRateSet;
+	u32				ReceiveConfig;
+	u8				rx_tsf_addr_filter_config; /* for 8822B/8821C USE */
+	bool			bSwChnl;
+	bool			bSetChnlBW;
+	bool			bSWToBW40M;
+	bool			bSWToBW80M;
+	bool			bChnlBWInitialized;
+	u32				BackUp_BB_REG_4_2nd_CCA[3];
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	struct auto_chan_sel acs;
+#endif
+	/****** rf_ctrl *****/
+	u8	rf_chip;
+	u8	rf_type;
+	u8	PackageType;
+	u8	NumTotalRFPath;
+	u8	antenna_test;
+
+	/****** Debug ******/
+	u16	ForcedDataRate;	/* Force Data Rate. 0: Auto, 0x02: 1M ~ 0x6C: 54M. */
+	u8	u1ForcedIgiLb;	/* forced IGI lower bound */
+	u8	bDumpRxPkt;
+	u8	bDumpTxPkt;
+	u8	bDisableTXPowerTraining;
+
+
+	/****** EEPROM setting.******/
+	u8	bautoload_fail_flag;
+	u8	efuse_file_status;
+	u8	macaddr_file_status;
+	u8	EepromOrEfuse;
+	u8	efuse_eeprom_data[EEPROM_MAX_SIZE]; /*92C:256bytes, 88E:512bytes, we use union set (512bytes)*/
+	u8	InterfaceSel; /* board type kept in eFuse */
+	u16	CustomerID;
+
+	u16	EEPROMVID;
+	u16	EEPROMSVID;
+	u8	EEPROMUsbSwitch;
+	u16	EEPROMPID;
+	u16	EEPROMSDID;
+
+	u8	EEPROMCustomerID;
+	u8	EEPROMSubCustomerID;
+	u8	EEPROMVersion;
+	u8	EEPROMRegulatory;
+	u8	eeprom_thermal_meter;
+	u8	EEPROMBluetoothCoexist;
+	u8	EEPROMBluetoothType;
+	u8	EEPROMBluetoothAntNum;
+	u8	EEPROMBluetoothAntIsolation;
+	u8	EEPROMBluetoothRadioShared;
+	u8	EEPROMMACAddr[ETH_ALEN];
+	u8	tx_bbswing_24G;
+	u8	tx_bbswing_5G;
+
+#ifdef CONFIG_RF_POWER_TRIM
+	u8	EEPROMRFGainOffset;
+	u8	EEPROMRFGainVal;
+	struct kfree_data_t kfree_data;
+#endif /*CONFIG_RF_POWER_TRIM*/
+
+	u8	EfuseUsedPercentage;
+	u16	EfuseUsedBytes;
+	/*u8		EfuseMap[2][HWSET_MAX_SIZE_JAGUAR];*/
+	EFUSE_HAL	EfuseHal;
+
+	/*---------------------------------------------------------------------------------*/
+	/* 2.4G TX power info for target TX power*/
+	u8	Index24G_CCK_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
+	u8	Index24G_BW40_Base[MAX_RF_PATH][CENTER_CH_2G_NUM];
+	s8	CCK_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	OFDM_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+
+	/* 5G TX power info for target TX power*/
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	u8	Index5G_BW40_Base[MAX_RF_PATH][CENTER_CH_5G_ALL_NUM];
+	u8	Index5G_BW80_Base[MAX_RF_PATH][CENTER_CH_5G_80M_NUM];
+	s8	OFDM_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW80_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+#endif
+
+	u8	Regulation2_4G;
+	u8	Regulation5G;
+
+	/********************************
+	*	TX power by rate table at most 4RF path.
+	*	The register is
+	*
+	*	VHT TX power by rate off setArray =
+	*	Band:-2G&5G = 0 / 1
+	*	RF: at most 4*4 = ABCD=0/1/2/3
+	*	CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
+	**********************************/
+
+	u8 txpwr_by_rate_undefined_band_path[TX_PWR_BY_RATE_NUM_BAND]
+		[TX_PWR_BY_RATE_NUM_RF];
+
+	s8	TxPwrByRateOffset[TX_PWR_BY_RATE_NUM_BAND]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RATE];
+
+#ifdef CONFIG_PHYDM_POWERTRACK_BY_TSSI
+	s8	TxPwrByRate[TX_PWR_BY_RATE_NUM_BAND]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RATE];
+#endif
+	/* --------------------------------------------------------------------------------- */
+
+	u8 tx_pwr_lmt_5g_20_40_ref;
+
+	/* Power Limit Table for 2.4G */
+	s8	TxPwrLimit_2_4G[MAX_REGULATION_NUM]
+		[MAX_2_4G_BANDWIDTH_NUM]
+		[MAX_RATE_SECTION_NUM]
+		[CENTER_CH_2G_NUM]
+		[MAX_RF_PATH];
+
+	/* Power Limit Table for 5G */
+	s8	TxPwrLimit_5G[MAX_REGULATION_NUM]
+		[MAX_5G_BANDWIDTH_NUM]
+		[MAX_RATE_SECTION_NUM]
+		[CENTER_CH_5G_ALL_NUM]
+		[MAX_RF_PATH];
+
+
+#ifdef CONFIG_PHYDM_POWERTRACK_BY_TSSI
+	s8	TxPwrLimit_2_4G_Original[MAX_REGULATION_NUM]
+		[MAX_2_4G_BANDWIDTH_NUM]
+		[MAX_RATE_SECTION_NUM]
+		[CENTER_CH_2G_NUM]
+		[MAX_RF_PATH];
+
+
+	s8	TxPwrLimit_5G_Original[MAX_REGULATION_NUM]
+		[MAX_5G_BANDWIDTH_NUM]
+		[MAX_RATE_SECTION_NUM]
+		[CENTER_CH_5G_ALL_NUM]
+		[MAX_RF_PATH];
+
+#endif
+
+	/* Store the original power by rate value of the base of each rate section of rf path A & B */
+	u8	TxPwrByRateBase2_4G[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[MAX_BASE_NUM_IN_PHY_REG_PG_2_4G];
+	u8	TxPwrByRateBase5G[TX_PWR_BY_RATE_NUM_RF]
+		[TX_PWR_BY_RATE_NUM_RF]
+		[MAX_BASE_NUM_IN_PHY_REG_PG_5G];
+
+	u8	txpwr_by_rate_loaded:1;
+	u8	txpwr_by_rate_from_file:1;
+	u8	txpwr_limit_loaded:1;
+	u8	txpwr_limit_from_file:1;
+	u8	rf_power_tracking_type;
+
+	/* Read/write are allow for following hardware information variables	 */
+	u8	crystal_cap;
+
+	u8	PAType_2G;
+	u8	PAType_5G;
+	u8	LNAType_2G;
+	u8	LNAType_5G;
+	u8	ExternalPA_2G;
+	u8	ExternalLNA_2G;
+	u8	external_pa_5g;
+	u8	external_lna_5g;
+	u16	TypeGLNA;
+	u16	TypeGPA;
+	u16	TypeALNA;
+	u16	TypeAPA;
+	u16	rfe_type;
+
+	u8	bLedOpenDrain; /* Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16. */
+	u32	ac_param_be; /* Original parameter for BE, use for EDCA turbo.	*/
+
+	BB_REGISTER_DEFINITION_T	PHYRegDef[MAX_RF_PATH];	/* Radio A/B/C/D */
+
+	u32	RfRegChnlVal[MAX_RF_PATH];
+
+	/* RDG enable */
+	bool	 bRDGEnable;
+
+	u8	RegTxPause;
+	/* Beacon function related global variable. */
+	u8	RegBcnCtrlVal;
+	u8	RegFwHwTxQCtrl;
+	u8	RegReg542;
+	u8	RegCR_1;
+	u8	Reg837;
+	u16	RegRRSR;
+
+	/****** antenna diversity ******/
+	u8	AntDivCfg;
+	u8	with_extenal_ant_switch;
+	u8	b_fix_tx_ant;
+	u8	AntDetection;
+	u8	TRxAntDivType;
+	u8	ant_path; /* for 8723B s0/s1 selection	 */
+	u32	antenna_tx_path;					/* Antenna path Tx */
+	u32	AntennaRxPath;					/* Antenna path Rx */
+	u8 sw_antdiv_bl_state;
+
+	/******** PHY DM & DM Section **********/
+	u8			DM_Type;
+	_lock		IQKSpinLock;
+	u8			INIDATA_RATE[MACID_NUM_SW_LIMIT];
+	/* Upper and Lower Signal threshold for Rate Adaptive*/
+	int			entry_min_undecorated_smoothed_pwdb;
+	int			entry_max_undecorated_smoothed_pwdb;
+	int			min_undecorated_pwdb_for_dm;
+	struct PHY_DM_STRUCT	 odmpriv;
+	u8			bIQKInitialized;
+	u8			bNeedIQK;
+	u8		IQK_MP_Switch;
+	/******** PHY DM & DM Section **********/
+
+
+
+	/* 2010/08/09 MH Add CU power down mode. */
+	bool		pwrdown;
+
+	/* Add for dual MAC  0--Mac0 1--Mac1 */
+	u32	interfaceIndex;
+
+#ifdef CONFIG_P2P
+	u8	p2p_ps_offload;
+#endif
+	/* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
+	u8	bMacPwrCtrlOn;
+	u8 hci_sus_state;
+
+	u8	RegIQKFWOffload;
+	struct submit_ctx	iqk_sctx;
+
+	RT_AMPDU_BRUST		AMPDUBurstMode; /* 92C maybe not use, but for compile successfully */
+
+	u8	OutEpQueueSel;
+	u8	OutEpNumber;
+
+#ifdef RTW_RX_AGGREGATION
+	RX_AGG_MODE rxagg_mode;
+
+	/* For RX Aggregation DMA Mode */
+	u8 rxagg_dma_size;
+	u8 rxagg_dma_timeout;
+#endif /* RTW_RX_AGGREGATION */
+
+
+	/* 2010/12/10 MH Add for USB aggreation mode dynamic shceme. */
+	bool		UsbRxHighSpeedMode;
+	bool		UsbTxVeryHighSpeedMode;
+	u32			UsbBulkOutSize;
+	bool		bSupportUSB3;
+	u8			usb_intf_start;
+
+	/* Interrupt relatd register information. */
+	u32			IntArray[3];/* HISR0,HISR1,HSISR */
+	u32			IntrMask[3];
+#ifdef CONFIG_USB_TX_AGGREGATION
+	u8			UsbTxAggMode;
+	u8			UsbTxAggDescNum;
+#endif /* CONFIG_USB_TX_AGGREGATION */
+
+#ifdef CONFIG_USB_RX_AGGREGATION
+	u16			HwRxPageSize;				/* Hardware setting */
+
+	/* For RX Aggregation USB Mode */
+	u8			rxagg_usb_size;
+	u8			rxagg_usb_timeout;
+#endif/* CONFIG_USB_RX_AGGREGATION */
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	struct sreset_priv srestpriv;
+#endif /* #ifdef DBG_CONFIG_ERROR_DETECT */
+
+#ifdef CONFIG_BT_COEXIST
+	/* For bluetooth co-existance */
+	BT_COEXIST		bt_coexist;
+#endif /* CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_LOAD_PHY_PARA_FROM_FILE
+	char	para_file_buf[MAX_PARA_FILE_BUF_LEN];
+	char *mac_reg;
+	u32	mac_reg_len;
+	char *bb_phy_reg;
+	u32	bb_phy_reg_len;
+	char *bb_agc_tab;
+	u32	bb_agc_tab_len;
+	char *bb_phy_reg_pg;
+	u32	bb_phy_reg_pg_len;
+	char *bb_phy_reg_mp;
+	u32	bb_phy_reg_mp_len;
+	char *rf_radio_a;
+	u32	rf_radio_a_len;
+	char *rf_radio_b;
+	u32	rf_radio_b_len;
+	char *rf_tx_pwr_track;
+	u32	rf_tx_pwr_track_len;
+	char *rf_tx_pwr_lmt;
+	u32	rf_tx_pwr_lmt_len;
+#endif
+
+#ifdef CONFIG_BACKGROUND_NOISE_MONITOR
+	s16 noise[ODM_MAX_CHANNEL_NUM];
+#endif
+
+	struct hal_spec_t hal_spec;
+#ifdef CONFIG_PHY_CAPABILITY_QUERY
+	struct phy_spec_t phy_spec;
+#endif
+	u8	RfKFreeEnable;
+	u8	RfKFree_ch_group;
+	bool				bCCKinCH14;
+	BB_INIT_REGISTER	RegForRecover[5];
+
+	u32 RxGainOffset[4]; /*{2G, 5G_Low, 5G_Middle, G_High}*/
+	u8 BackUp_IG_REG_4_Chnl_Section[4]; /*{A,B,C,D}*/
+
+	struct hal_iqk_reg_backup iqk_reg_backup[MAX_IQK_INFO_BACKUP_CHNL_NUM];
+
+#ifdef RTW_HALMAC
+	u8 drv_rsvd_page_number;
+#endif
+
+#ifdef CONFIG_BEAMFORMING
+	u8 backup_snd_ptcl_ctrl;
+#ifdef RTW_BEAMFORMING_VERSION_2
+	struct beamforming_info beamforming_info;
+#endif /* RTW_BEAMFORMING_VERSION_2 */
+#endif /* CONFIG_BEAMFORMING */
+
+	u8 not_xmitframe_fw_dl; /*not use xmitframe to download fw*/
+} HAL_DATA_COMMON, *PHAL_DATA_COMMON;
+
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+	int rtw_hw_suspend(_adapter *padapter);
+	int rtw_hw_resume(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_GLOBAL_UI_PID
+extern int ui_pid[3];
+#endif
+
+typedef struct hal_com_data HAL_DATA_TYPE, *PHAL_DATA_TYPE;
+#define GET_HAL_DATA(__pAdapter)		((HAL_DATA_TYPE *)((__pAdapter)->HalData))
+#define GET_HAL_SPEC(__pAdapter)			(&(GET_HAL_DATA((__pAdapter))->hal_spec))
+#define GET_ODM(__pAdapter)			(&(GET_HAL_DATA((__pAdapter))->odmpriv))
+
+#define GET_HAL_RFPATH_NUM(__pAdapter)		(((HAL_DATA_TYPE *)((__pAdapter)->HalData))->NumTotalRFPath)
+#define RT_GetInterfaceSelection(_Adapter)		(GET_HAL_DATA(_Adapter)->InterfaceSel)
+#define GET_RF_TYPE(__pAdapter)				(GET_HAL_DATA(__pAdapter)->rf_type)
+#define GET_KFREE_DATA(_adapter) (&(GET_HAL_DATA((_adapter))->kfree_data))
+
+#define	SUPPORT_HW_RADIO_DETECT(Adapter)	(RT_GetInterfaceSelection(Adapter) == INTF_SEL2_MINICARD || \
+		RT_GetInterfaceSelection(Adapter) == INTF_SEL3_USB_Solo || \
+		RT_GetInterfaceSelection(Adapter) == INTF_SEL4_USB_Combo)
+
+#define get_hal_mac_addr(adapter)				(GET_HAL_DATA(adapter)->EEPROMMACAddr)
+#define is_boot_from_eeprom(adapter)			(GET_HAL_DATA(adapter)->EepromOrEfuse)
+#define rtw_get_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed)
+#define rtw_is_hw_init_completed(adapter)		(GET_HAL_DATA(adapter)->hw_init_completed == true)
+
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+#define GET_ACS_STATE(padapter)					(ATOMIC_READ(&GET_HAL_DATA(padapter)->acs.state))
+#define SET_ACS_STATE(padapter, set_state)			(ATOMIC_SET(&GET_HAL_DATA(padapter)->acs.state, set_state))
+#define rtw_get_acs_channel(padapter)				(GET_HAL_DATA(padapter)->acs.ch)
+#define rtw_set_acs_channel(padapter, survey_ch)	(GET_HAL_DATA(padapter)->acs.ch = survey_ch)
+#endif /*CONFIG_AUTO_CHNL_SEL_NHM*/
+
+#ifdef RTW_HALMAC
+int rtw_halmac_deinit_adapter(struct dvobj_priv *);
+#endif /* RTW_HALMAC */
+
+/* alias for phydm coding style */
+#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
+#define REG_OFDM_0_ECCA_THRESHOLD		rOFDM0_ECCAThreshold
+#define REG_FPGA0_XB_LSSI_READ_BACK		rFPGA0_XB_LSSIReadBack
+#define REG_FPGA0_TX_GAIN_STAGE			rFPGA0_TxGainStage
+#define REG_OFDM_0_XA_AGC_CORE1			rOFDM0_XAAGCCore1
+#define REG_OFDM_0_XB_AGC_CORE1			rOFDM0_XBAGCCore1
+#define REG_A_TX_SCALE_JAGUAR			rA_TxScale_Jaguar
+#define REG_B_TX_SCALE_JAGUAR			rB_TxScale_Jaguar
+
+#define REG_FPGA0_XAB_RF_INTERFACE_SW	rFPGA0_XAB_RFInterfaceSW
+#define REG_FPGA0_XAB_RF_PARAMETER	rFPGA0_XAB_RFParameter
+#define REG_FPGA0_XA_HSSI_PARAMETER1	rFPGA0_XA_HSSIParameter1
+#define REG_FPGA0_XA_LSSI_PARAMETER	rFPGA0_XA_LSSIParameter
+#define REG_FPGA0_XA_RF_INTERFACE_OE	rFPGA0_XA_RFInterfaceOE
+#define REG_FPGA0_XB_HSSI_PARAMETER1	rFPGA0_XB_HSSIParameter1
+#define REG_FPGA0_XB_LSSI_PARAMETER	rFPGA0_XB_LSSIParameter
+#define REG_FPGA0_XB_LSSI_READ_BACK	rFPGA0_XB_LSSIReadBack
+#define REG_FPGA0_XB_RF_INTERFACE_OE	rFPGA0_XB_RFInterfaceOE
+#define REG_FPGA0_XCD_RF_INTERFACE_SW	rFPGA0_XCD_RFInterfaceSW
+#define REG_FPGA0_XCD_SWITCH_CONTROL	rFPGA0_XCD_SwitchControl
+#define REG_FPGA1_TX_BLOCK	rFPGA1_TxBlock
+#define REG_FPGA1_TX_INFO	rFPGA1_TxInfo
+#define REG_IQK_AGC_CONT	rIQK_AGC_Cont
+#define REG_IQK_AGC_PTS	rIQK_AGC_Pts
+#define REG_IQK_AGC_RSP	rIQK_AGC_Rsp
+#define REG_OFDM_0_AGC_RSSI_TABLE	rOFDM0_AGCRSSITable
+#define REG_OFDM_0_ECCA_THRESHOLD	rOFDM0_ECCAThreshold
+#define REG_OFDM_0_RX_IQ_EXT_ANTA	rOFDM0_RxIQExtAnta
+#define REG_OFDM_0_TR_MUX_PAR	rOFDM0_TRMuxPar
+#define REG_OFDM_0_TRX_PATH_ENABLE	rOFDM0_TRxPathEnable
+#define REG_OFDM_0_XA_AGC_CORE1	rOFDM0_XAAGCCore1
+#define REG_OFDM_0_XA_RX_IQ_IMBALANCE	rOFDM0_XARxIQImbalance
+#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
+#define REG_OFDM_0_XB_AGC_CORE1	rOFDM0_XBAGCCore1
+#define REG_OFDM_0_XB_RX_IQ_IMBALANCE	rOFDM0_XBRxIQImbalance
+#define REG_OFDM_0_XB_TX_IQ_IMBALANCE	rOFDM0_XBTxIQImbalance
+#define REG_OFDM_0_XC_TX_AFE	rOFDM0_XCTxAFE
+#define REG_OFDM_0_XD_TX_AFE	rOFDM0_XDTxAFE
+
+/*#define REG_A_CFO_LONG_DUMP_92E	rA_CfoLongDump_92E*/
+#define REG_A_CFO_LONG_DUMP_JAGUAR	rA_CfoLongDump_Jaguar
+/*#define REG_A_CFO_SHORT_DUMP_92E	rA_CfoShortDump_92E*/
+#define REG_A_CFO_SHORT_DUMP_JAGUAR	rA_CfoShortDump_Jaguar
+#define REG_A_RFE_PINMUX_JAGUAR	rA_RFE_Pinmux_Jaguar
+/*#define REG_A_RSSI_DUMP_92E	rA_RSSIDump_92E*/
+#define REG_A_RSSI_DUMP_JAGUAR	rA_RSSIDump_Jaguar
+/*#define REG_A_RX_SNR_DUMP_92E	rA_RXsnrDump_92E*/
+#define REG_A_RX_SNR_DUMP_JAGUAR	rA_RXsnrDump_Jaguar
+/*#define REG_A_TX_AGC	rA_TXAGC*/
+#define REG_A_TX_SCALE_JAGUAR	rA_TxScale_Jaguar
+#define REG_BW_INDICATION_JAGUAR	rBWIndication_Jaguar
+/*#define REG_B_BBSWING	rB_BBSWING*/
+/*#define REG_B_CFO_LONG_DUMP_92E	rB_CfoLongDump_92E*/
+#define REG_B_CFO_LONG_DUMP_JAGUAR	rB_CfoLongDump_Jaguar
+/*#define REG_B_CFO_SHORT_DUMP_92E	rB_CfoShortDump_92E*/
+#define REG_B_CFO_SHORT_DUMP_JAGUAR	rB_CfoShortDump_Jaguar
+/*#define REG_B_RSSI_DUMP_92E	rB_RSSIDump_92E*/
+#define REG_B_RSSI_DUMP_JAGUAR	rB_RSSIDump_Jaguar
+/*#define REG_B_RX_SNR_DUMP_92E	rB_RXsnrDump_92E*/
+#define REG_B_RX_SNR_DUMP_JAGUAR	rB_RXsnrDump_Jaguar
+/*#define REG_B_TX_AGC	rB_TXAGC*/
+#define REG_B_TX_SCALE_JAGUAR	rB_TxScale_Jaguar
+#define REG_BLUE_TOOTH	rBlue_Tooth
+#define REG_CCK_0_AFE_SETTING	rCCK0_AFESetting
+/*#define REG_C_BBSWING	rC_BBSWING*/
+/*#define REG_C_TX_AGC	rC_TXAGC*/
+#define REG_C_TX_SCALE_JAGUAR2	rC_TxScale_Jaguar2
+#define REG_CONFIG_ANT_A	rConfig_AntA
+#define REG_CONFIG_ANT_B	rConfig_AntB
+#define REG_CONFIG_PMPD_ANT_A	rConfig_Pmpd_AntA
+#define REG_CONFIG_PMPD_ANT_B	rConfig_Pmpd_AntB
+#define REG_DPDT_CONTROL	rDPDT_control
+/*#define REG_D_BBSWING	rD_BBSWING*/
+/*#define REG_D_TX_AGC	rD_TXAGC*/
+#define REG_D_TX_SCALE_JAGUAR2	rD_TxScale_Jaguar2
+#define REG_FPGA0_ANALOG_PARAMETER4	rFPGA0_AnalogParameter4
+#define REG_FPGA0_IQK	rFPGA0_IQK
+#define REG_FPGA0_PSD_FUNCTION	rFPGA0_PSDFunction
+#define REG_FPGA0_PSD_REPORT	rFPGA0_PSDReport
+#define REG_FPGA0_RFMOD	rFPGA0_RFMOD
+#define REG_FPGA0_TX_GAIN_STAGE	rFPGA0_TxGainStage
+#define REG_FPGA0_XAB_RF_INTERFACE_SW	rFPGA0_XAB_RFInterfaceSW
+#define REG_FPGA0_XAB_RF_PARAMETER	rFPGA0_XAB_RFParameter
+#define REG_FPGA0_XA_HSSI_PARAMETER1	rFPGA0_XA_HSSIParameter1
+#define REG_FPGA0_XA_LSSI_PARAMETER	rFPGA0_XA_LSSIParameter
+#define REG_FPGA0_XA_RF_INTERFACE_OE	rFPGA0_XA_RFInterfaceOE
+#define REG_FPGA0_XB_HSSI_PARAMETER1	rFPGA0_XB_HSSIParameter1
+#define REG_FPGA0_XB_LSSI_PARAMETER	rFPGA0_XB_LSSIParameter
+#define REG_FPGA0_XB_LSSI_READ_BACK	rFPGA0_XB_LSSIReadBack
+#define REG_FPGA0_XB_RF_INTERFACE_OE	rFPGA0_XB_RFInterfaceOE
+#define REG_FPGA0_XCD_RF_INTERFACE_SW	rFPGA0_XCD_RFInterfaceSW
+#define REG_FPGA0_XCD_SWITCH_CONTROL	rFPGA0_XCD_SwitchControl
+#define REG_FPGA1_TX_BLOCK	rFPGA1_TxBlock
+#define REG_FPGA1_TX_INFO	rFPGA1_TxInfo
+#define REG_IQK_AGC_CONT	rIQK_AGC_Cont
+#define REG_IQK_AGC_PTS	rIQK_AGC_Pts
+#define REG_IQK_AGC_RSP	rIQK_AGC_Rsp
+#define REG_OFDM_0_AGC_RSSI_TABLE	rOFDM0_AGCRSSITable
+#define REG_OFDM_0_ECCA_THRESHOLD	rOFDM0_ECCAThreshold
+#define REG_OFDM_0_RX_IQ_EXT_ANTA	rOFDM0_RxIQExtAnta
+#define REG_OFDM_0_TR_MUX_PAR	rOFDM0_TRMuxPar
+#define REG_OFDM_0_TRX_PATH_ENABLE	rOFDM0_TRxPathEnable
+#define REG_OFDM_0_XA_AGC_CORE1	rOFDM0_XAAGCCore1
+#define REG_OFDM_0_XA_RX_IQ_IMBALANCE	rOFDM0_XARxIQImbalance
+#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
+#define REG_OFDM_0_XB_AGC_CORE1	rOFDM0_XBAGCCore1
+#define REG_OFDM_0_XB_RX_IQ_IMBALANCE	rOFDM0_XBRxIQImbalance
+#define REG_OFDM_0_XB_TX_IQ_IMBALANCE	rOFDM0_XBTxIQImbalance
+#define REG_OFDM_0_XC_TX_AFE	rOFDM0_XCTxAFE
+#define REG_OFDM_0_XD_TX_AFE	rOFDM0_XDTxAFE
+#define REG_PMPD_ANAEN	rPMPD_ANAEN
+#define REG_PDP_ANT_A	rPdp_AntA
+#define REG_PDP_ANT_A_4	rPdp_AntA_4
+#define REG_PDP_ANT_B	rPdp_AntB
+#define REG_PDP_ANT_B_4	rPdp_AntB_4
+#define REG_PWED_TH_JAGUAR	rPwed_TH_Jaguar
+#define REG_RX_CCK	rRx_CCK
+#define REG_RX_IQK	rRx_IQK
+#define REG_RX_IQK_PI_A	rRx_IQK_PI_A
+#define REG_RX_IQK_PI_B	rRx_IQK_PI_B
+#define REG_RX_IQK_TONE_A	rRx_IQK_Tone_A
+#define REG_RX_IQK_TONE_B	rRx_IQK_Tone_B
+#define REG_RX_OFDM	rRx_OFDM
+#define REG_RX_POWER_AFTER_IQK_A_2	rRx_Power_After_IQK_A_2
+#define REG_RX_POWER_AFTER_IQK_B_2	rRx_Power_After_IQK_B_2
+#define REG_RX_POWER_BEFORE_IQK_A_2	rRx_Power_Before_IQK_A_2
+#define REG_RX_POWER_BEFORE_IQK_B_2	rRx_Power_Before_IQK_B_2
+#define REG_RX_TO_RX	rRx_TO_Rx
+#define REG_RX_WAIT_CCA	rRx_Wait_CCA
+#define REG_RX_WAIT_RIFS	rRx_Wait_RIFS
+#define REG_S0_S1_PATH_SWITCH	rS0S1_PathSwitch
+/*#define REG_S1_RXEVM_DUMP_92E	rS1_RXevmDump_92E*/
+#define REG_S1_RXEVM_DUMP_JAGUAR	rS1_RXevmDump_Jaguar
+/*#define REG_S2_RXEVM_DUMP_92E	rS2_RXevmDump_92E*/
+#define REG_S2_RXEVM_DUMP_JAGUAR	rS2_RXevmDump_Jaguar
+#define REG_SYM_WLBT_PAPE_SEL	rSYM_WLBT_PAPE_SEL
+#define REG_SINGLE_TONE_CONT_TX_JAGUAR	rSingleTone_ContTx_Jaguar
+#define REG_SLEEP	rSleep
+#define REG_STANDBY	rStandby
+#define REG_TX_AGC_A_CCK_11_CCK_1_JAGUAR	rTxAGC_A_CCK11_CCK1_JAguar
+#define REG_TX_AGC_A_CCK_1_MCS32	rTxAGC_A_CCK1_Mcs32
+#define REG_TX_AGC_A_MCS11_MCS8_JAGUAR	rTxAGC_A_MCS11_MCS8_JAguar
+#define REG_TX_AGC_A_MCS15_MCS12_JAGUAR	rTxAGC_A_MCS15_MCS12_JAguar
+#define REG_TX_AGC_A_MCS19_MCS16_JAGUAR	rTxAGC_A_MCS19_MCS16_JAguar
+#define REG_TX_AGC_A_MCS23_MCS20_JAGUAR	rTxAGC_A_MCS23_MCS20_JAguar
+#define REG_TX_AGC_A_MCS3_MCS0_JAGUAR	rTxAGC_A_MCS3_MCS0_JAguar
+#define REG_TX_AGC_A_MCS7_MCS4_JAGUAR	rTxAGC_A_MCS7_MCS4_JAguar
+#define REG_TX_AGC_A_MCS03_MCS00	rTxAGC_A_Mcs03_Mcs00
+#define REG_TX_AGC_A_MCS07_MCS04	rTxAGC_A_Mcs07_Mcs04
+#define REG_TX_AGC_A_MCS11_MCS08	rTxAGC_A_Mcs11_Mcs08
+#define REG_TX_AGC_A_MCS15_MCS12	rTxAGC_A_Mcs15_Mcs12
+#define REG_TX_AGC_A_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_A_Nss1Index3_Nss1Index0_JAguar
+#define REG_TX_AGC_A_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_A_Nss1Index7_Nss1Index4_JAguar
+#define REG_TX_AGC_A_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_A_Nss2Index1_Nss1Index8_JAguar
+#define REG_TX_AGC_A_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_A_Nss2Index5_Nss2Index2_JAguar
+#define REG_TX_AGC_A_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_A_Nss2Index9_Nss2Index6_JAguar
+#define REG_TX_AGC_A_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_A_Nss3Index3_Nss3Index0_JAguar
+#define REG_TX_AGC_A_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_A_Nss3Index7_Nss3Index4_JAguar
+#define REG_TX_AGC_A_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_A_Nss3Index9_Nss3Index8_JAguar
+#define REG_TX_AGC_A_OFDM18_OFDM6_JAGUAR	rTxAGC_A_Ofdm18_Ofdm6_JAguar
+#define REG_TX_AGC_A_OFDM54_OFDM24_JAGUAR	rTxAGC_A_Ofdm54_Ofdm24_JAguar
+#define REG_TX_AGC_A_RATE18_06	rTxAGC_A_Rate18_06
+#define REG_TX_AGC_A_RATE54_24	rTxAGC_A_Rate54_24
+#define REG_TX_AGC_B_CCK_11_A_CCK_2_11	rTxAGC_B_CCK11_A_CCK2_11
+#define REG_TX_AGC_B_CCK_11_CCK_1_JAGUAR	rTxAGC_B_CCK11_CCK1_JAguar
+#define REG_TX_AGC_B_CCK_1_55_MCS32	rTxAGC_B_CCK1_55_Mcs32
+#define REG_TX_AGC_B_MCS11_MCS8_JAGUAR	rTxAGC_B_MCS11_MCS8_JAguar
+#define REG_TX_AGC_B_MCS15_MCS12_JAGUAR	rTxAGC_B_MCS15_MCS12_JAguar
+#define REG_TX_AGC_B_MCS19_MCS16_JAGUAR	rTxAGC_B_MCS19_MCS16_JAguar
+#define REG_TX_AGC_B_MCS23_MCS20_JAGUAR	rTxAGC_B_MCS23_MCS20_JAguar
+#define REG_TX_AGC_B_MCS3_MCS0_JAGUAR	rTxAGC_B_MCS3_MCS0_JAguar
+#define REG_TX_AGC_B_MCS7_MCS4_JAGUAR	rTxAGC_B_MCS7_MCS4_JAguar
+#define REG_TX_AGC_B_MCS03_MCS00	rTxAGC_B_Mcs03_Mcs00
+#define REG_TX_AGC_B_MCS07_MCS04	rTxAGC_B_Mcs07_Mcs04
+#define REG_TX_AGC_B_MCS11_MCS08	rTxAGC_B_Mcs11_Mcs08
+#define REG_TX_AGC_B_MCS15_MCS12	rTxAGC_B_Mcs15_Mcs12
+#define REG_TX_AGC_B_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_B_Nss1Index3_Nss1Index0_JAguar
+#define REG_TX_AGC_B_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_B_Nss1Index7_Nss1Index4_JAguar
+#define REG_TX_AGC_B_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_B_Nss2Index1_Nss1Index8_JAguar
+#define REG_TX_AGC_B_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_B_Nss2Index5_Nss2Index2_JAguar
+#define REG_TX_AGC_B_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_B_Nss2Index9_Nss2Index6_JAguar
+#define REG_TX_AGC_B_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_B_Nss3Index3_Nss3Index0_JAguar
+#define REG_TX_AGC_B_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_B_Nss3Index7_Nss3Index4_JAguar
+#define REG_TX_AGC_B_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_B_Nss3Index9_Nss3Index8_JAguar
+#define REG_TX_AGC_B_OFDM18_OFDM6_JAGUAR	rTxAGC_B_Ofdm18_Ofdm6_JAguar
+#define REG_TX_AGC_B_OFDM54_OFDM24_JAGUAR	rTxAGC_B_Ofdm54_Ofdm24_JAguar
+#define REG_TX_AGC_B_RATE18_06	rTxAGC_B_Rate18_06
+#define REG_TX_AGC_B_RATE54_24	rTxAGC_B_Rate54_24
+#define REG_TX_AGC_C_CCK_11_CCK_1_JAGUAR	rTxAGC_C_CCK11_CCK1_JAguar
+#define REG_TX_AGC_C_MCS11_MCS8_JAGUAR	rTxAGC_C_MCS11_MCS8_JAguar
+#define REG_TX_AGC_C_MCS15_MCS12_JAGUAR	rTxAGC_C_MCS15_MCS12_JAguar
+#define REG_TX_AGC_C_MCS19_MCS16_JAGUAR	rTxAGC_C_MCS19_MCS16_JAguar
+#define REG_TX_AGC_C_MCS23_MCS20_JAGUAR	rTxAGC_C_MCS23_MCS20_JAguar
+#define REG_TX_AGC_C_MCS3_MCS0_JAGUAR	rTxAGC_C_MCS3_MCS0_JAguar
+#define REG_TX_AGC_C_MCS7_MCS4_JAGUAR	rTxAGC_C_MCS7_MCS4_JAguar
+#define REG_TX_AGC_C_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_C_Nss1Index3_Nss1Index0_JAguar
+#define REG_TX_AGC_C_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_C_Nss1Index7_Nss1Index4_JAguar
+#define REG_TX_AGC_C_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_C_Nss2Index1_Nss1Index8_JAguar
+#define REG_TX_AGC_C_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_C_Nss2Index5_Nss2Index2_JAguar
+#define REG_TX_AGC_C_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_C_Nss2Index9_Nss2Index6_JAguar
+#define REG_TX_AGC_C_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_C_Nss3Index3_Nss3Index0_JAguar
+#define REG_TX_AGC_C_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_C_Nss3Index7_Nss3Index4_JAguar
+#define REG_TX_AGC_C_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_C_Nss3Index9_Nss3Index8_JAguar
+#define REG_TX_AGC_C_OFDM18_OFDM6_JAGUAR	rTxAGC_C_Ofdm18_Ofdm6_JAguar
+#define REG_TX_AGC_C_OFDM54_OFDM24_JAGUAR	rTxAGC_C_Ofdm54_Ofdm24_JAguar
+#define REG_TX_AGC_D_CCK_11_CCK_1_JAGUAR	rTxAGC_D_CCK11_CCK1_JAguar
+#define REG_TX_AGC_D_MCS11_MCS8_JAGUAR	rTxAGC_D_MCS11_MCS8_JAguar
+#define REG_TX_AGC_D_MCS15_MCS12_JAGUAR	rTxAGC_D_MCS15_MCS12_JAguar
+#define REG_TX_AGC_D_MCS19_MCS16_JAGUAR	rTxAGC_D_MCS19_MCS16_JAguar
+#define REG_TX_AGC_D_MCS23_MCS20_JAGUAR	rTxAGC_D_MCS23_MCS20_JAguar
+#define REG_TX_AGC_D_MCS3_MCS0_JAGUAR	rTxAGC_D_MCS3_MCS0_JAguar
+#define REG_TX_AGC_D_MCS7_MCS4_JAGUAR	rTxAGC_D_MCS7_MCS4_JAguar
+#define REG_TX_AGC_D_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_D_Nss1Index3_Nss1Index0_JAguar
+#define REG_TX_AGC_D_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_D_Nss1Index7_Nss1Index4_JAguar
+#define REG_TX_AGC_D_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_D_Nss2Index1_Nss1Index8_JAguar
+#define REG_TX_AGC_D_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_D_Nss2Index5_Nss2Index2_JAguar
+#define REG_TX_AGC_D_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_D_Nss2Index9_Nss2Index6_JAguar
+#define REG_TX_AGC_D_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_D_Nss3Index3_Nss3Index0_JAguar
+#define REG_TX_AGC_D_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_D_Nss3Index7_Nss3Index4_JAguar
+#define REG_TX_AGC_D_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_D_Nss3Index9_Nss3Index8_JAguar
+#define REG_TX_AGC_D_OFDM18_OFDM6_JAGUAR	rTxAGC_D_Ofdm18_Ofdm6_JAguar
+#define REG_TX_AGC_D_OFDM54_OFDM24_JAGUAR	rTxAGC_D_Ofdm54_Ofdm24_JAguar
+#define REG_TX_PATH_JAGUAR	rTxPath_Jaguar
+#define REG_TX_CCK_BBON	rTx_CCK_BBON
+#define REG_TX_CCK_RFON	rTx_CCK_RFON
+#define REG_TX_IQK	rTx_IQK
+#define REG_TX_IQK_PI_A	rTx_IQK_PI_A
+#define REG_TX_IQK_PI_B	rTx_IQK_PI_B
+#define REG_TX_IQK_TONE_A	rTx_IQK_Tone_A
+#define REG_TX_IQK_TONE_B	rTx_IQK_Tone_B
+#define REG_TX_OFDM_BBON	rTx_OFDM_BBON
+#define REG_TX_OFDM_RFON	rTx_OFDM_RFON
+#define REG_TX_POWER_AFTER_IQK_A	rTx_Power_After_IQK_A
+#define REG_TX_POWER_AFTER_IQK_B	rTx_Power_After_IQK_B
+#define REG_TX_POWER_BEFORE_IQK_A	rTx_Power_Before_IQK_A
+#define REG_TX_POWER_BEFORE_IQK_B	rTx_Power_Before_IQK_B
+#define REG_TX_TO_RX	rTx_To_Rx
+#define REG_TX_TO_TX	rTx_To_Tx
+#define REG_APK	rAPK
+#define REG_ANTSEL_SW_JAGUAR	r_ANTSEL_SW_Jaguar
+
+
+
+#define rf_welut_jaguar	RF_WeLut_Jaguar
+#define rf_mode_table_addr	RF_ModeTableAddr
+#define rf_mode_table_data0	RF_ModeTableData0
+#define rf_mode_table_data1	RF_ModeTableData1
+
+#define RX_SMOOTH_FACTOR	Rx_Smooth_Factor
+
+extern int new_bcn_max;
+extern u8 REALTEK_96B_IE[];
+extern unsigned char WPA_TKIP_CIPHER[4];
+extern unsigned char RSN_TKIP_CIPHER[4];
+extern char *rtw_initmac;
+#ifdef CONFIG_TX_MCAST2UNI
+extern int rtw_mc2u_disable;
+#endif
+extern int rtw_ht_enable;
+extern int rtw_bw_mode;
+extern int rtw_ampdu_enable;/* for enable tx_ampdu */
+
+int pm_netdev_open(struct net_device *pnetdev, u8 bnormal);
+void netdev_br_init(struct net_device *netdev);
+
+#endif /* __HAL_DATA_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_ic_cfg.h b/drivers/staging/rtl8188eu/include/hal_ic_cfg.h
new file mode 100644
index 000000000000..847caefe6b2b
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_ic_cfg.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_IC_CFG_H__
+#define __HAL_IC_CFG_H__
+
+#define RTL8188E_SUPPORT				0
+#define RTL8812A_SUPPORT				0
+#define RTL8821A_SUPPORT				0
+#define RTL8723B_SUPPORT				0
+#define RTL8723D_SUPPORT				0
+#define RTL8192E_SUPPORT				0
+#define RTL8814A_SUPPORT				0
+#define RTL8195A_SUPPORT				0
+#define RTL8197F_SUPPORT				0
+#define RTL8703B_SUPPORT				0
+#define RTL8188F_SUPPORT				1
+#define RTL8822B_SUPPORT				0
+#define RTL8821B_SUPPORT				0
+#define RTL8821C_SUPPORT				0
+
+/*#if (RTL8188E_SUPPORT==1)*/
+#define RATE_ADAPTIVE_SUPPORT			0
+#define POWER_TRAINING_ACTIVE			0
+
+#ifdef CONFIG_MULTIDRV
+#endif
+
+#undef RTL8188E_SUPPORT
+#undef RATE_ADAPTIVE_SUPPORT
+#undef POWER_TRAINING_ACTIVE
+
+#define RTL8188E_SUPPORT				1
+#define RATE_ADAPTIVE_SUPPORT			1
+#define POWER_TRAINING_ACTIVE			1
+#define CONFIG_GET_RAID_BY_DRV
+
+#endif /*__HAL_IC_CFG_H__*/
diff --git a/drivers/staging/rtl8188eu/include/hal_intf.h b/drivers/staging/rtl8188eu/include/hal_intf.h
new file mode 100644
index 000000000000..3975e3600913
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_intf.h
@@ -0,0 +1,644 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_INTF_H__
+#define __HAL_INTF_H__
+
+
+enum RTL871X_HCI_TYPE {
+	RTW_PCIE	= BIT0,
+	RTW_USB	= BIT1,
+	RTW_SDIO	= BIT2,
+	RTW_GSPI	= BIT3,
+};
+
+enum _CHIP_TYPE {
+
+	NULL_CHIP_TYPE,
+	RTL8188E,
+	RTL8192E,
+	RTL8812,
+	RTL8821, /* RTL8811 */
+	RTL8723B,
+	RTL8814A,
+	RTL8703B,
+	RTL8188F,
+	RTL8822B,
+	RTL8723D,
+	RTL8821C,
+	MAX_CHIP_TYPE
+};
+
+extern const u32 _chip_type_to_odm_ic_type[];
+#define chip_type_to_odm_ic_type(chip_type) (((chip_type) >= MAX_CHIP_TYPE) ? _chip_type_to_odm_ic_type[MAX_CHIP_TYPE] : _chip_type_to_odm_ic_type[(chip_type)])
+
+typedef enum _HAL_HW_TIMER_TYPE {
+	HAL_TIMER_NONE = 0,
+	HAL_TIMER_TXBF = 1,
+	HAL_TIMER_EARLYMODE = 2,
+} HAL_HW_TIMER_TYPE, *PHAL_HW_TIMER_TYPE;
+
+
+typedef enum _HW_VARIABLES {
+	HW_VAR_MEDIA_STATUS,
+	HW_VAR_SET_OPMODE,
+	HW_VAR_MAC_ADDR,
+	HW_VAR_BSSID,
+	HW_VAR_INIT_RTS_RATE,
+	HW_VAR_BASIC_RATE,
+	HW_VAR_TXPAUSE,
+	HW_VAR_BCN_FUNC,
+	HW_VAR_CORRECT_TSF,
+	HW_VAR_CHECK_BSSID,
+	HW_VAR_MLME_DISCONNECT,
+	HW_VAR_MLME_SITESURVEY,
+	HW_VAR_MLME_JOIN,
+	HW_VAR_ON_RCR_AM,
+	HW_VAR_OFF_RCR_AM,
+	HW_VAR_BEACON_INTERVAL,
+	HW_VAR_SLOT_TIME,
+	HW_VAR_RESP_SIFS,
+	HW_VAR_ACK_PREAMBLE,
+	HW_VAR_SEC_CFG,
+	HW_VAR_SEC_DK_CFG,
+	HW_VAR_BCN_VALID,
+	HW_VAR_RF_TYPE,
+	/* PHYDM odm->SupportAbility */
+	HW_VAR_CAM_EMPTY_ENTRY,
+	HW_VAR_CAM_INVALID_ALL,
+	HW_VAR_AC_PARAM_VO,
+	HW_VAR_AC_PARAM_VI,
+	HW_VAR_AC_PARAM_BE,
+	HW_VAR_AC_PARAM_BK,
+	HW_VAR_ACM_CTRL,
+#ifdef CONFIG_WMMPS
+	HW_VAR_UAPSD_TID,
+#endif
+	HW_VAR_AMPDU_MIN_SPACE,
+	HW_VAR_AMPDU_FACTOR,
+	HW_VAR_RXDMA_AGG_PG_TH,
+	HW_VAR_SET_RPWM,
+	HW_VAR_CPWM,
+	HW_VAR_H2C_FW_PWRMODE,
+	HW_VAR_H2C_PS_TUNE_PARAM,
+	HW_VAR_H2C_FW_JOINBSSRPT,
+	HW_VAR_FWLPS_RF_ON,
+	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+#ifdef CONFIG_LPS_POFF
+	HW_VAR_LPS_POFF_INIT,
+	HW_VAR_LPS_POFF_DEINIT,
+	HW_VAR_LPS_POFF_SET_MODE,
+	HW_VAR_LPS_POFF_WOW_EN,
+#endif
+#ifdef CONFIG_LPS_PG
+	HW_VAR_LPS_PG_HANDLE,
+#endif
+	HW_VAR_TRIGGER_GPIO_0,
+	HW_VAR_BT_SET_COEXIST,
+	HW_VAR_BT_ISSUE_DELBA,
+	HW_VAR_SWITCH_EPHY_WoWLAN,
+	HW_VAR_EFUSE_USAGE,
+	HW_VAR_EFUSE_BYTES,
+	HW_VAR_EFUSE_BT_USAGE,
+	HW_VAR_EFUSE_BT_BYTES,
+	HW_VAR_FIFO_CLEARN_UP,
+	HW_VAR_RESTORE_HW_SEQ,
+	HW_VAR_CHECK_TXBUF,
+	HW_VAR_PCIE_STOP_TX_DMA,
+	HW_VAR_APFM_ON_MAC, /* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
+	HW_VAR_HCI_SUS_STATE,
+	/* The valid upper nav range for the HW updating, if the true value is larger than the upper range, the HW won't update it. */
+	/* Unit in microsecond. 0 means disable this function. */
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	HW_VAR_WOWLAN,
+	HW_VAR_WAKEUP_REASON,
+#endif
+	HW_VAR_RPWM_TOG,
+#ifdef CONFIG_GPIO_WAKEUP
+	HW_SET_GPIO_WL_CTRL,
+#endif
+	HW_VAR_SYS_CLKR,
+	HW_VAR_NAV_UPPER,
+	HW_VAR_RPT_TIMER_SETTING,
+	HW_VAR_TX_RPT_MAX_MACID,
+	HW_VAR_CHK_HI_QUEUE_EMPTY,
+	HW_VAR_DL_BCN_SEL,
+	HW_VAR_AMPDU_MAX_TIME,
+	HW_VAR_WIRELESS_MODE,
+	HW_VAR_USB_MODE,
+	HW_VAR_PORT_SWITCH,
+	HW_VAR_DO_IQK,
+	HW_VAR_DM_IN_LPS,
+	HW_VAR_SET_REQ_FW_PS,
+	HW_VAR_FW_PS_STATE,
+	HW_VAR_SOUNDING_ENTER,
+	HW_VAR_SOUNDING_LEAVE,
+	HW_VAR_SOUNDING_RATE,
+	HW_VAR_SOUNDING_STATUS,
+	HW_VAR_SOUNDING_FW_NDPA,
+	HW_VAR_SOUNDING_CLK,
+	HW_VAR_SOUNDING_SET_GID_TABLE,
+	HW_VAR_SOUNDING_CSI_REPORT,
+	/*Add by YuChen for TXBF HW timer*/
+	HW_VAR_HW_REG_TIMER_INIT,
+	HW_VAR_HW_REG_TIMER_RESTART,
+	HW_VAR_HW_REG_TIMER_START,
+	HW_VAR_HW_REG_TIMER_STOP,
+	/*Add by YuChen for TXBF HW timer*/
+	HW_VAR_DL_RSVD_PAGE,
+	HW_VAR_MACID_LINK,
+	HW_VAR_MACID_NOLINK,
+	HW_VAR_MACID_SLEEP,
+	HW_VAR_MACID_WAKEUP,
+	HW_VAR_DUMP_MAC_QUEUE_INFO,
+	HW_VAR_ASIX_IOT,
+#ifdef CONFIG_MBSSID_CAM
+	HW_VAR_MBSSID_CAM_WRITE,
+	HW_VAR_MBSSID_CAM_CLEAR,
+	HW_VAR_RCR_MBSSID_EN,
+#endif
+	HW_VAR_EN_HW_UPDATE_TSF,
+	HW_VAR_CH_SW_NEED_TO_TAKE_CARE_IQK_INFO,
+	HW_VAR_CH_SW_IQK_INFO_BACKUP,
+	HW_VAR_CH_SW_IQK_INFO_RESTORE,
+#ifdef CONFIG_TDLS
+	HW_VAR_TDLS_WRCR,
+	HW_VAR_TDLS_RS_RCR,
+#ifdef CONFIG_TDLS_CH_SW
+	HW_VAR_TDLS_BCN_EARLY_C2H_RPT
+#endif
+#endif
+} HW_VARIABLES;
+
+typedef enum _HAL_DEF_VARIABLE {
+	HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
+	HAL_DEF_IS_SUPPORT_ANT_DIV,
+	HAL_DEF_DRVINFO_SZ,
+	HAL_DEF_MAX_RECVBUF_SZ,
+	HAL_DEF_RX_PACKET_OFFSET,
+	HAL_DEF_RX_DMA_SZ_WOW,
+	HAL_DEF_RX_DMA_SZ,
+	HAL_DEF_RX_PAGE_SIZE,
+	HAL_DEF_DBG_DUMP_RXPKT,/* for dbg */
+	HAL_DEF_RA_DECISION_RATE,
+	HAL_DEF_RA_SGI,
+	HAL_DEF_PT_PWR_STATUS,
+	HAL_DEF_TX_LDPC,				/* LDPC support */
+	HAL_DEF_RX_LDPC,				/* LDPC support */
+	HAL_DEF_TX_STBC,				/* TX STBC support */
+	HAL_DEF_RX_STBC,				/* RX STBC support */
+	HAL_DEF_EXPLICIT_BEAMFORMER,/* Explicit  Compressed Steering Capable */
+	HAL_DEF_EXPLICIT_BEAMFORMEE,/* Explicit Compressed Beamforming Feedback Capable */
+	HAL_DEF_VHT_MU_BEAMFORMER,	/* VHT MU Beamformer support */
+	HAL_DEF_VHT_MU_BEAMFORMEE,	/* VHT MU Beamformee support */
+	HAL_DEF_BEAMFORMER_CAP,
+	HAL_DEF_BEAMFORMEE_CAP,
+	HW_VAR_MAX_RX_AMPDU_FACTOR,
+	HW_DEF_RA_INFO_DUMP,
+	HAL_DEF_DBG_DUMP_TXPKT,
+
+	HAL_DEF_TX_PAGE_SIZE,
+	HAL_DEF_TX_PAGE_BOUNDARY,
+	HAL_DEF_TX_PAGE_BOUNDARY_WOWLAN,
+	HAL_DEF_ANT_DETECT,/* to do for 8723a */
+	HAL_DEF_PCI_SUUPORT_L1_BACKDOOR, /* Determine if the L1 Backdoor setting is turned on. */
+	HAL_DEF_PCI_AMD_L1_SUPPORT,
+	HAL_DEF_PCI_ASPM_OSC, /* Support for ASPM OSC, added by Roger, 2013.03.27. */
+	HAL_DEF_MACID_SLEEP, /* Support for MACID sleep */
+	HAL_DEF_DBG_DIS_PWT, /* disable Tx power training or not. */
+	HAL_DEF_EFUSE_USAGE,	/* Get current EFUSE utilization. 2008.12.19. Added by Roger. */
+	HAL_DEF_EFUSE_BYTES,
+	HW_VAR_BEST_AMPDU_DENSITY,
+} HAL_DEF_VARIABLE;
+
+typedef enum _HAL_ODM_VARIABLE {
+	HAL_ODM_STA_INFO,
+	HAL_ODM_P2P_STATE,
+	HAL_ODM_WIFI_DISPLAY_STATE,
+	HAL_ODM_NOISE_MONITOR,
+	HAL_ODM_REGULATION,
+	HAL_ODM_INITIAL_GAIN,
+	HAL_ODM_FA_CNT_DUMP,
+	HAL_ODM_DBG_FLAG,
+	HAL_ODM_DBG_LEVEL,
+	HAL_ODM_RX_INFO_DUMP,
+	HAL_ODM_RX_Dframe_INFO,
+#ifdef CONFIG_AUTO_CHNL_SEL_NHM
+	HAL_ODM_AUTO_CHNL_SEL,
+#endif
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	HAL_ODM_ANTDIV_SELECT
+#endif
+} HAL_ODM_VARIABLE;
+
+typedef enum _HAL_INTF_PS_FUNC {
+	HAL_USB_SELECT_SUSPEND,
+	HAL_MAX_ID,
+} HAL_INTF_PS_FUNC;
+
+typedef s32(*c2h_id_filter)(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
+
+struct txpwr_idx_comp;
+
+struct macid_cfg {
+	u8 mac_id;
+	u8 rate_id;
+	u8 bandwidth;
+	u8 short_gi;
+	u8 ignore_bw;
+	u8 rsvd;
+	u16 rsvd1;
+	u64 ra_mask;
+};
+
+struct hal_ops {
+	/*** initialize section ***/
+	void	(*read_chip_version)(_adapter *padapter);
+	void	(*init_default_value)(_adapter *padapter);
+	void	(*intf_chip_configure)(_adapter *padapter);
+	u8	(*read_adapter_info)(_adapter *padapter);
+	u32(*hal_power_on)(_adapter *padapter);
+	void	(*hal_power_off)(_adapter *padapter);
+	u32(*hal_init)(_adapter *padapter);
+	u32(*hal_deinit)(_adapter *padapter);
+	void	(*dm_init)(_adapter *padapter);
+	void	(*dm_deinit)(_adapter *padapter);
+
+	/*** xmit section ***/
+	s32(*init_xmit_priv)(_adapter *padapter);
+	void	(*free_xmit_priv)(_adapter *padapter);
+	s32(*hal_xmit)(_adapter *padapter, struct xmit_frame *pxmitframe);
+	/*
+	 * mgnt_xmit should be implemented to run in interrupt context
+	 */
+	s32(*mgnt_xmit)(_adapter *padapter, struct xmit_frame *pmgntframe);
+	s32(*hal_xmitframe_enqueue)(_adapter *padapter, struct xmit_frame *pxmitframe);
+#ifdef CONFIG_XMIT_THREAD_MODE
+	s32(*xmit_thread_handler)(_adapter *padapter);
+#endif
+	void	(*run_thread)(_adapter *padapter);
+	void	(*cancel_thread)(_adapter *padapter);
+
+	/*** recv section ***/
+	s32(*init_recv_priv)(_adapter *padapter);
+	void	(*free_recv_priv)(_adapter *padapter);
+#ifdef CONFIG_RECV_THREAD_MODE
+	s32 (*recv_hdl)(_adapter *adapter);
+#endif
+	u32(*inirp_init)(_adapter *padapter);
+	u32(*inirp_deinit)(_adapter *padapter);
+	/*** interrupt hdl section ***/
+	void	(*enable_interrupt)(_adapter *padapter);
+	void	(*disable_interrupt)(_adapter *padapter);
+	u8(*check_ips_status)(_adapter *padapter);
+
+#if defined(CONFIG_SUPPORT_USB_INT)
+	void	(*interrupt_handler)(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+	/*** DM section ***/
+
+	void	(*InitSwLeds)(_adapter *padapter);
+	void	(*DeInitSwLeds)(_adapter *padapter);
+
+	void	(*set_chnl_bw_handler)(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80);
+
+	void	(*set_tx_power_level_handler)(_adapter *padapter, u8 channel);
+	void	(*get_tx_power_level_handler)(_adapter *padapter, s32 *powerlevel);
+
+	void (*set_tx_power_index_handler)(_adapter *padapter, u32 powerindex, u8 rfpath, u8 rate);
+	u8(*get_tx_power_index_handler)(_adapter *padapter, u8 rfpath, u8 rate, u8 bandwidth, u8 channel, struct txpwr_idx_comp *tic);
+
+	void	(*hal_dm_watchdog)(_adapter *padapter);
+#ifdef CONFIG_LPS_LCLK_WD_TIMER
+	void	(*hal_dm_watchdog_in_lps)(_adapter *padapter);
+#endif
+
+
+	void	(*set_hw_reg_handler)(_adapter *padapter, u8	variable, u8 *val);
+
+	void	(*GetHwRegHandler)(_adapter *padapter, u8	variable, u8 *val);
+
+
+
+	u8 (*get_hal_def_var_handler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void * pValue);
+
+	u8(*SetHalDefVarHandler)(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void * pValue);
+
+	void	(*GetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void * pValue1, void * pValue2);
+	void	(*SetHalODMVarHandler)(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void * pValue1, bool bSet);
+
+	void	(*update_ra_mask_handler)(_adapter *padapter, struct sta_info *psta, struct macid_cfg *h2c_macid_cfg);
+	void	(*SetBeaconRelatedRegistersHandler)(_adapter *padapter);
+
+	u8(*interface_ps_func)(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);
+
+	u32(*read_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask);
+	void	(*write_bbreg)(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
+	u32(*read_rfreg)(_adapter *padapter, u8 eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*write_rfreg)(_adapter *padapter, u8 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+#ifdef CONFIG_HOSTAPD_MLME
+	s32(*hostap_mgnt_xmit_entry)(_adapter *padapter, _pkt *pkt);
+#endif
+
+	void (*EfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
+	void (*BTEfusePowerSwitch)(_adapter *padapter, u8 bWrite, u8 PwrState);
+	void (*ReadEFuse)(_adapter *padapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, bool bPseudoTest);
+	void (*EFUSEGetEfuseDefinition)(_adapter *padapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
+	u16(*EfuseGetCurrentSize)(_adapter *padapter, u8 efuseType, bool bPseudoTest);
+	int	(*Efuse_PgPacketRead)(_adapter *padapter, u8 offset, u8 *data, bool bPseudoTest);
+	int	(*Efuse_PgPacketWrite)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+	u8(*Efuse_WordEnableDataWrite)(_adapter *padapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+	bool(*Efuse_PgPacketWrite_BT)(_adapter *padapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	void (*sreset_init_value)(_adapter *padapter);
+	void (*sreset_reset_value)(_adapter *padapter);
+	void (*silentreset)(_adapter *padapter);
+	void (*sreset_xmit_status_check)(_adapter *padapter);
+	void (*sreset_linked_status_check)(_adapter *padapter);
+	u8(*sreset_get_wifi_status)(_adapter *padapter);
+	bool (*sreset_inprogress)(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_IOL
+	int (*IOL_exec_cmds_sync)(_adapter *padapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+#endif
+
+	void (*hal_notch_filter)(_adapter *adapter, bool enable);
+#ifdef RTW_HALMAC
+	void (*hal_mac_c2h_handler)(_adapter *adapter, u8 *pbuf, u16 length);
+#else
+	s32(*c2h_handler)(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
+#endif
+	void (*reqtxrpt)(_adapter *padapter, u8 macid);
+	s32(*fill_h2c_cmd)(PADAPTER, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+	void (*fill_fake_txdesc)(PADAPTER, u8 *pDesc, u32 BufferLen,
+				 u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+	s32(*fw_dl)(_adapter *adapter, bool wowlan);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	void (*clear_interrupt)(_adapter *padapter);
+#endif
+	u8(*hal_get_tx_buff_rsvd_page_num)(_adapter *adapter, bool wowlan);
+#ifdef CONFIG_GPIO_API
+	void (*update_hisr_hsisr_ind)(PADAPTER padapter, u32 flag);
+	int (*hal_gpio_func_check)(_adapter *padapter, u8 gpio_num);
+	void (*hal_gpio_multi_func_reset)(_adapter *padapter, u8 gpio_num);
+#endif
+	void (*fw_correct_bcn)(PADAPTER padapter);
+
+#ifdef RTW_HALMAC
+	u8(*init_mac_register)(PADAPTER);
+	u8(*init_phy)(PADAPTER);
+#endif /* RTW_HALMAC */
+#ifdef CONFIG_RFKILL_POLL
+	bool (*hal_radio_onoff_check)(_adapter *adapter, u8 *valid);
+#endif
+
+};
+
+typedef	enum _RT_EEPROM_TYPE {
+	EEPROM_93C46,
+	EEPROM_93C56,
+	EEPROM_BOOT_EFUSE,
+} RT_EEPROM_TYPE, *PRT_EEPROM_TYPE;
+
+
+
+#define RF_CHANGE_BY_INIT	0
+#define RF_CHANGE_BY_IPS	BIT28
+#define RF_CHANGE_BY_PS	BIT29
+#define RF_CHANGE_BY_HW	BIT30
+#define RF_CHANGE_BY_SW	BIT31
+
+typedef enum _HARDWARE_TYPE {
+	HARDWARE_TYPE_RTL8188EE,
+	HARDWARE_TYPE_RTL8188EU,
+	HARDWARE_TYPE_RTL8188ES,
+	/*	NEW_GENERATION_IC */
+	HARDWARE_TYPE_RTL8192EE,
+	HARDWARE_TYPE_RTL8192EU,
+	HARDWARE_TYPE_RTL8192ES,
+	HARDWARE_TYPE_RTL8812E,
+	HARDWARE_TYPE_RTL8812AU,
+	HARDWARE_TYPE_RTL8811AU,
+	HARDWARE_TYPE_RTL8821E,
+	HARDWARE_TYPE_RTL8821U,
+	HARDWARE_TYPE_RTL8821S,
+	HARDWARE_TYPE_RTL8723BE,
+	HARDWARE_TYPE_RTL8723BU,
+	HARDWARE_TYPE_RTL8723BS,
+	HARDWARE_TYPE_RTL8814AE,
+	HARDWARE_TYPE_RTL8814AU,
+	HARDWARE_TYPE_RTL8814AS,
+	HARDWARE_TYPE_RTL8821BE,
+	HARDWARE_TYPE_RTL8821BU,
+	HARDWARE_TYPE_RTL8821BS,
+	HARDWARE_TYPE_RTL8822BE,
+	HARDWARE_TYPE_RTL8822BU,
+	HARDWARE_TYPE_RTL8822BS,
+	HARDWARE_TYPE_RTL8703BE,
+	HARDWARE_TYPE_RTL8703BU,
+	HARDWARE_TYPE_RTL8703BS,
+	HARDWARE_TYPE_RTL8188FE,
+	HARDWARE_TYPE_RTL8188FU,
+	HARDWARE_TYPE_RTL8188FS,
+	HARDWARE_TYPE_RTL8723DE,
+	HARDWARE_TYPE_RTL8723DU,
+	HARDWARE_TYPE_RTL8723DS,
+	HARDWARE_TYPE_RTL8821CE,
+	HARDWARE_TYPE_RTL8821CU,
+	HARDWARE_TYPE_RTL8821CS,
+	HARDWARE_TYPE_MAX,
+} HARDWARE_TYPE;
+
+#define IS_NEW_GENERATION_IC(_Adapter)	(rtw_get_hw_type(_Adapter) >= HARDWARE_TYPE_RTL8192EE)
+/*
+ * RTL8188E Series
+ *   */
+#define IS_HARDWARE_TYPE_8188EU(_Adapter)	(rtw_get_hw_type(_Adapter) == HARDWARE_TYPE_RTL8188EU)
+#define	IS_HARDWARE_TYPE_8188E(_Adapter) IS_HARDWARE_TYPE_8188EU(_Adapter)
+
+typedef enum _wowlan_subcode {
+	WOWLAN_ENABLE			= 0,
+	WOWLAN_DISABLE			= 1,
+	WOWLAN_AP_ENABLE		= 2,
+	WOWLAN_AP_DISABLE		= 3,
+	WOWLAN_PATTERN_CLEAN		= 4
+} wowlan_subcode;
+
+struct wowlan_ioctl_param {
+	unsigned int subcode;
+	unsigned int subcode_value;
+	unsigned int wakeup_reason;
+};
+
+u8 rtw_hal_data_init(_adapter *padapter);
+void rtw_hal_data_deinit(_adapter *padapter);
+
+void rtw_hal_def_value_init(_adapter *padapter);
+
+void	rtw_hal_free_data(_adapter *padapter);
+
+void rtw_hal_dm_init(_adapter *padapter);
+void rtw_hal_dm_deinit(_adapter *padapter);
+void rtw_hal_sw_led_init(_adapter *padapter);
+void rtw_hal_sw_led_deinit(_adapter *padapter);
+
+u32 rtw_hal_power_on(_adapter *padapter);
+void rtw_hal_power_off(_adapter *padapter);
+
+uint rtw_hal_init(_adapter *padapter);
+uint rtw_hal_deinit(_adapter *padapter);
+void rtw_hal_stop(_adapter *padapter);
+void rtw_hal_set_hwreg(PADAPTER padapter, u8 variable, u8 *val);
+void rtw_hal_get_hwreg(PADAPTER padapter, u8 variable, u8 *val);
+
+void rtw_hal_chip_configure(_adapter *padapter);
+u8 rtw_hal_read_chip_info(_adapter *padapter);
+void rtw_hal_read_chip_version(_adapter *padapter);
+
+u8 rtw_hal_set_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void * pValue);
+u8 rtw_hal_get_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, void * pValue);
+
+void rtw_hal_set_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void * pValue1, bool bSet);
+void	rtw_hal_get_odm_var(_adapter *padapter, HAL_ODM_VARIABLE eVariable, void * pValue1, void * pValue2);
+
+void rtw_hal_enable_interrupt(_adapter *padapter);
+void rtw_hal_disable_interrupt(_adapter *padapter);
+
+u8 rtw_hal_check_ips_status(_adapter *padapter);
+
+	u32	rtw_hal_inirp_init(_adapter *padapter);
+	u32	rtw_hal_inirp_deinit(_adapter *padapter);
+
+u8	rtw_hal_intf_ps_func(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);
+
+s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32	rtw_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe);
+
+s32	rtw_hal_init_xmit_priv(_adapter *padapter);
+void	rtw_hal_free_xmit_priv(_adapter *padapter);
+
+s32	rtw_hal_init_recv_priv(_adapter *padapter);
+void	rtw_hal_free_recv_priv(_adapter *padapter);
+
+void rtw_hal_update_ra_mask(struct sta_info *psta, u8 rssi_level, u8 is_update_bw);
+void rtw_update_ramask(_adapter *padapter, struct sta_info *psta, u32 mac_id, u8 rssi_level, u8 is_update_bw);
+
+void	rtw_hal_start_thread(_adapter *padapter);
+void	rtw_hal_stop_thread(_adapter *padapter);
+
+void rtw_hal_bcn_related_reg_setting(_adapter *padapter);
+
+u32	rtw_hal_read_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask);
+void	rtw_hal_write_bbreg(_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
+u32	rtw_hal_read_rfreg(_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask);
+void	rtw_hal_write_rfreg(_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+
+#define phy_query_bb_reg(Adapter, RegAddr, BitMask) rtw_hal_read_bbreg((Adapter), (RegAddr), (BitMask))
+#define phy_set_bb_reg(Adapter, RegAddr, BitMask, Data) rtw_hal_write_bbreg((Adapter), (RegAddr), (BitMask), (Data))
+#define phy_query_rf_reg(Adapter, eRFPath, RegAddr, BitMask) rtw_hal_read_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask))
+#define phy_set_rf_reg(Adapter, eRFPath, RegAddr, BitMask, Data) rtw_hal_write_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask), (Data))
+
+#define phy_set_mac_reg	phy_set_bb_reg
+#define phy_query_mac_reg phy_query_bb_reg
+
+
+#if  defined(CONFIG_SUPPORT_USB_INT)
+	void	rtw_hal_interrupt_handler(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+void	rtw_hal_set_chnl_bw(_adapter *padapter, u8 channel, CHANNEL_WIDTH Bandwidth, u8 Offset40, u8 Offset80);
+void	rtw_hal_dm_watchdog(_adapter *padapter);
+void	rtw_hal_dm_watchdog_in_lps(_adapter *padapter);
+
+void	rtw_hal_set_tx_power_level(_adapter *padapter, u8 channel);
+void	rtw_hal_get_tx_power_level(_adapter *padapter, s32 *powerlevel);
+
+#ifdef CONFIG_HOSTAPD_MLME
+	s32	rtw_hal_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt);
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+void rtw_hal_sreset_init(_adapter *padapter);
+void rtw_hal_sreset_reset(_adapter *padapter);
+void rtw_hal_sreset_reset_value(_adapter *padapter);
+void rtw_hal_sreset_xmit_status_check(_adapter *padapter);
+void rtw_hal_sreset_linked_status_check(_adapter *padapter);
+u8   rtw_hal_sreset_get_wifi_status(_adapter *padapter);
+bool rtw_hal_sreset_inprogress(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_IOL
+int rtw_hal_iol_cmd(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+#endif
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+s32 rtw_hal_xmit_thread_handler(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_RECV_THREAD_MODE
+s32 rtw_hal_recv_hdl(_adapter *adapter);
+#endif
+
+void rtw_hal_notch_filter(_adapter *adapter, bool enable);
+
+#ifdef CONFIG_FW_C2H_REG
+bool rtw_hal_c2h_reg_hdr_parse(_adapter *adapter, u8 *buf, u8 *id, u8 *seq, u8 *plen, u8 **payload);
+bool rtw_hal_c2h_valid(_adapter *adapter, u8 *buf);
+s32 rtw_hal_c2h_evt_read(_adapter *adapter, u8 *buf);
+#endif
+
+#ifdef CONFIG_FW_C2H_PKT
+bool rtw_hal_c2h_pkt_hdr_parse(_adapter *adapter, u8 *buf, u16 len, u8 *id, u8 *seq, u8 *plen, u8 **payload);
+#endif
+
+s32 c2h_handler(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
+#ifndef RTW_HALMAC
+s32 rtw_hal_c2h_handler(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
+s32 rtw_hal_c2h_id_handle_directly(_adapter *adapter, u8 id, u8 seq, u8 plen, u8 *payload);
+#endif
+
+s32 rtw_hal_is_disable_sw_channel_plan(PADAPTER padapter);
+
+s32 rtw_hal_macid_sleep(PADAPTER padapter, u8 macid);
+s32 rtw_hal_macid_wakeup(PADAPTER padapter, u8 macid);
+
+s32 rtw_hal_fill_h2c_cmd(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+void rtw_hal_fill_fake_txdesc(_adapter *padapter, u8 *pDesc, u32 BufferLen,
+			      u8 IsPsPoll, u8 IsBTQosNull, u8 bDataFrame);
+u8 rtw_hal_get_txbuff_rsvd_page_num(_adapter *adapter, bool wowlan);
+
+#ifdef CONFIG_GPIO_API
+void rtw_hal_update_hisr_hsisr_ind(_adapter *padapter, u32 flag);
+int rtw_hal_gpio_func_check(_adapter *padapter, u8 gpio_num);
+void rtw_hal_gpio_multi_func_reset(_adapter *padapter, u8 gpio_num);
+#endif
+
+void rtw_hal_fw_correct_bcn(_adapter *padapter);
+s32 rtw_hal_fw_dl(_adapter *padapter, u8 wowlan);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	void rtw_hal_clear_interrupt(_adapter *padapter);
+#endif
+
+void rtw_hal_set_tx_power_index(PADAPTER, u32 powerindex, u8 rfpath, u8 rate);
+u8 rtw_hal_get_tx_power_index(PADAPTER, u8 rfpath, u8 rate, u8 bandwidth, u8 channel,struct txpwr_idx_comp *tic);
+
+u8 rtw_hal_ops_check(_adapter *padapter);
+
+#ifdef RTW_HALMAC
+	u8 rtw_hal_init_mac_register(PADAPTER);
+	u8 rtw_hal_init_phy(PADAPTER);
+#endif /* RTW_HALMAC */
+
+#ifdef CONFIG_RFKILL_POLL
+bool rtw_hal_rfkill_poll(_adapter *adapter, u8 *valid);
+#endif
+
+#endif /* __HAL_INTF_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_pg.h b/drivers/staging/rtl8188eu/include/hal_pg.h
new file mode 100644
index 000000000000..7df93fa289be
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_pg.h
@@ -0,0 +1,785 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef __HAL_PG_H__
+#define __HAL_PG_H__
+
+#define PPG_BB_GAIN_2G_TX_OFFSET_MASK	0x0F
+#define PPG_BB_GAIN_2G_TXB_OFFSET_MASK	0xF0
+
+#define PPG_BB_GAIN_5G_TX_OFFSET_MASK	0x1F
+#define PPG_THERMAL_OFFSET_MASK			0x1F
+#define KFREE_BB_GAIN_2G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+#define KFREE_BB_GAIN_2G_TXB_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TXB_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x10) ? ((_ppg_v) >> 5) : (-((_ppg_v) >> 5))))
+#define KFREE_BB_GAIN_5G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_5G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+#define KFREE_THERMAL_OFFSET(_ppg_v) (((_ppg_v) == PPG_THERMAL_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 88EE/88EU/88ES
+ * **************************************************** */
+#define EEPROM_TX_PWR_INX_88E					0x10
+
+#define EEPROM_ChannelPlan_88E					0xB8
+#define EEPROM_XTAL_88E						0xB9
+#define EEPROM_THERMAL_METER_88E				0xBA
+#define EEPROM_IQK_LCK_88E						0xBB
+
+#define EEPROM_RF_BOARD_OPTION_88E			0xC1
+#define EEPROM_RF_FEATURE_OPTION_88E			0xC2
+#define EEPROM_RF_BT_SETTING_88E				0xC3
+#define EEPROM_VERSION_88E						0xC4
+#define EEPROM_CustomID_88E					0xC5
+#define EEPROM_RF_ANTENNA_OPT_88E			0xC9
+#define EEPROM_COUNTRY_CODE_88E				0xCB
+
+/* RTL88EE */
+#define EEPROM_MAC_ADDR_88EE					0xD0
+#define EEPROM_VID_88EE						0xD6
+#define EEPROM_DID_88EE						0xD8
+#define EEPROM_SVID_88EE						0xDA
+#define EEPROM_SMID_88EE						0xDC
+
+/* RTL88EU */
+#define EEPROM_MAC_ADDR_88EU					0xD7
+#define EEPROM_VID_88EU						0xD0
+#define EEPROM_PID_88EU						0xD2
+#define EEPROM_USB_OPTIONAL_FUNCTION0		0xD4 /* 8188EU, 8192EU, 8812AU is the same */
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8811AU 0x104
+
+/* RTL88ES */
+#define EEPROM_MAC_ADDR_88ES					0x11A
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8192EE/8192EU/8192ES
+ * **************************************************** */
+#define GET_PG_KFREE_ON_8192E(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8192E(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8192E	0x1F6
+#define PPG_THERMAL_OFFSET_8192E		0x1F5
+
+/* 0x10 ~ 0x63 = TX power area. */
+#define	EEPROM_TX_PWR_INX_8192E				0x10
+
+#define	EEPROM_ChannelPlan_8192E				0xB8
+#define	EEPROM_XTAL_8192E						0xB9
+#define	EEPROM_THERMAL_METER_8192E			0xBA
+#define	EEPROM_IQK_LCK_8192E					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8192E			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8192E	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8192E	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8192E		0xC1
+#define	EEPROM_RF_FEATURE_OPTION_8192E		0xC2
+#define	EEPROM_RF_BT_SETTING_8192E			0xC3
+#define	EEPROM_VERSION_8192E					0xC4
+#define	EEPROM_CustomID_8192E				0xC5
+#define	EEPROM_TX_BBSWING_2G_8192E			0xC6
+#define	EEPROM_TX_BBSWING_5G_8192E			0xC7
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8192E	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8192E			0xC9
+#define	EEPROM_RFE_OPTION_8192E				0xCA
+#define	EEPROM_RFE_OPTION_8188E				0xCA
+#define EEPROM_COUNTRY_CODE_8192E			0xCB
+
+/* RTL8192EE */
+#define	EEPROM_MAC_ADDR_8192EE				0xD0
+#define	EEPROM_VID_8192EE						0xD6
+#define	EEPROM_DID_8192EE						0xD8
+#define	EEPROM_SVID_8192EE					0xDA
+#define	EEPROM_SMID_8192EE					0xDC
+
+/* RTL8192EU */
+#define	EEPROM_MAC_ADDR_8192EU				0xD7
+#define	EEPROM_VID_8192EU						0xD0
+#define	EEPROM_PID_8192EU						0xD2
+#define	EEPROM_PA_TYPE_8192EU		0xBC
+#define	EEPROM_LNA_TYPE_2G_8192EU	0xBD
+#define	EEPROM_LNA_TYPE_5G_8192EU	0xBF
+
+/* RTL8192ES */
+#define	EEPROM_MAC_ADDR_8192ES				0x11A
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8812AE/8812AU/8812AS
+ * ****************************************************
+ * 0x10 ~ 0x63 = TX power area. */
+#define EEPROM_USB_MODE_8812					0x08
+#define EEPROM_TX_PWR_INX_8812				0x10
+
+#define EEPROM_ChannelPlan_8812				0xB8
+#define EEPROM_XTAL_8812						0xB9
+#define EEPROM_THERMAL_METER_8812			0xBA
+#define EEPROM_IQK_LCK_8812					0xBB
+#define EEPROM_2G_5G_PA_TYPE_8812			0xBC
+#define EEPROM_2G_LNA_TYPE_GAIN_SEL_8812	0xBD
+#define EEPROM_5G_LNA_TYPE_GAIN_SEL_8812	0xBF
+
+#define EEPROM_RF_BOARD_OPTION_8812			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8812		0xC2
+#define EEPROM_RF_BT_SETTING_8812				0xC3
+#define EEPROM_VERSION_8812					0xC4
+#define EEPROM_CustomID_8812					0xC5
+#define EEPROM_TX_BBSWING_2G_8812			0xC6
+#define EEPROM_TX_BBSWING_5G_8812			0xC7
+#define EEPROM_TX_PWR_CALIBRATE_RATE_8812	0xC8
+#define EEPROM_RF_ANTENNA_OPT_8812			0xC9
+#define EEPROM_RFE_OPTION_8812				0xCA
+#define EEPROM_COUNTRY_CODE_8812			0xCB
+
+/* RTL8812AE */
+#define EEPROM_MAC_ADDR_8812AE				0xD0
+#define EEPROM_VID_8812AE						0xD6
+#define EEPROM_DID_8812AE						0xD8
+#define EEPROM_SVID_8812AE						0xDA
+#define EEPROM_SMID_8812AE					0xDC
+
+/* RTL8812AU */
+#define EEPROM_MAC_ADDR_8812AU				0xD7
+#define EEPROM_VID_8812AU						0xD0
+#define EEPROM_PID_8812AU						0xD2
+#define EEPROM_PA_TYPE_8812AU					0xBC
+#define EEPROM_LNA_TYPE_2G_8812AU			0xBD
+#define EEPROM_LNA_TYPE_5G_8812AU			0xBF
+
+/* RTL8814AU */
+#define	EEPROM_MAC_ADDR_8814AU				0xD8
+#define	EEPROM_VID_8814AU						0xD0
+#define	EEPROM_PID_8814AU						0xD2
+#define	EEPROM_PA_TYPE_8814AU				0xBC
+#define	EEPROM_LNA_TYPE_2G_8814AU			0xBD
+#define	EEPROM_LNA_TYPE_5G_8814AU			0xBF
+
+/* RTL8814AE */
+#define EEPROM_MAC_ADDR_8814AE				0xD0
+#define EEPROM_VID_8814AE						0xD6
+#define EEPROM_DID_8814AE						0xD8
+#define EEPROM_SVID_8814AE						0xDA
+#define EEPROM_SMID_8814AE					0xDC
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8814AU
+ * **************************************************** */
+#define GET_PG_KFREE_ON_8814A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8814A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+#define GET_PG_TX_POWER_TRACKING_MODE_8814A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 6, 2)
+
+#define KFREE_GAIN_DATA_LENGTH_8814A	22
+
+#define PPG_BB_GAIN_2G_TXBA_OFFSET_8814A	0x3EE
+
+#define PPG_THERMAL_OFFSET_8814A		0x3EF
+
+#define EEPROM_TX_PWR_INX_8814				0x10
+#define EEPROM_USB_MODE_8814A				0x0E
+#define EEPROM_ChannelPlan_8814				0xB8
+#define EEPROM_XTAL_8814					0xB9
+#define EEPROM_THERMAL_METER_8814			0xBA
+#define	EEPROM_IQK_LCK_8814					0xBB
+
+
+#define EEPROM_PA_TYPE_8814					0xBC
+#define EEPROM_LNA_TYPE_AB_2G_8814			0xBD
+#define	EEPROM_LNA_TYPE_CD_2G_8814			0xBE
+#define EEPROM_LNA_TYPE_AB_5G_8814			0xBF
+#define EEPROM_LNA_TYPE_CD_5G_8814			0xC0
+#define	EEPROM_RF_BOARD_OPTION_8814			0xC1
+#define	EEPROM_RF_BT_SETTING_8814			0xC3
+#define	EEPROM_VERSION_8814					0xC4
+#define	EEPROM_CustomID_8814				0xC5
+#define	EEPROM_TX_BBSWING_2G_8814			0xC6
+#define	EEPROM_TX_BBSWING_5G_8814			0xC7
+#define EEPROM_TRX_ANTENNA_OPTION_8814		0xC9
+#define	EEPROM_RFE_OPTION_8814				0xCA
+#define EEPROM_COUNTRY_CODE_8814			0xCB
+
+/*Extra Info for 8814A Initial Gain Fine Tune  suggested by Willis, JIRA: MP123*/
+#define	EEPROM_IG_OFFSET_4_AB_2G_8814A				0x120
+#define	EEPROM_IG_OFFSET_4_CD_2G_8814A				0x121
+#define	EEPROM_IG_OFFSET_4_AB_5GL_8814A				0x122
+#define	EEPROM_IG_OFFSET_4_CD_5GL_8814A				0x123
+#define	EEPROM_IG_OFFSET_4_AB_5GM_8814A				0x124
+#define	EEPROM_IG_OFFSET_4_CD_5GM_8814A				0x125
+#define	EEPROM_IG_OFFSET_4_AB_5GH_8814A				0x126
+#define	EEPROM_IG_OFFSET_4_CD_5GH_8814A				0x127
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8821AE/8821AU/8821AS
+ * **************************************************** */
+
+#define GET_PG_KFREE_ON_8821A(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8821A(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8821A		0x1F6
+#define PPG_THERMAL_OFFSET_8821A			0x1F5
+#define PPG_BB_GAIN_5GLB1_TXA_OFFSET_8821A	0x1F4
+#define PPG_BB_GAIN_5GLB2_TXA_OFFSET_8821A	0x1F3
+#define PPG_BB_GAIN_5GMB1_TXA_OFFSET_8821A	0x1F2
+#define PPG_BB_GAIN_5GMB2_TXA_OFFSET_8821A	0x1F1
+#define PPG_BB_GAIN_5GHB_TXA_OFFSET_8821A	0x1F0
+
+#define EEPROM_TX_PWR_INX_8821				0x10
+
+#define EEPROM_ChannelPlan_8821				0xB8
+#define EEPROM_XTAL_8821						0xB9
+#define EEPROM_THERMAL_METER_8821			0xBA
+#define EEPROM_IQK_LCK_8821					0xBB
+
+
+#define EEPROM_RF_BOARD_OPTION_8821			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8821		0xC2
+#define EEPROM_RF_BT_SETTING_8821				0xC3
+#define EEPROM_VERSION_8821					0xC4
+#define EEPROM_CustomID_8821					0xC5
+#define EEPROM_RF_ANTENNA_OPT_8821			0xC9
+
+/* RTL8821AE */
+#define EEPROM_MAC_ADDR_8821AE				0xD0
+#define EEPROM_VID_8821AE						0xD6
+#define EEPROM_DID_8821AE						0xD8
+#define EEPROM_SVID_8821AE						0xDA
+#define EEPROM_SMID_8821AE					0xDC
+
+/* RTL8821AU */
+#define EEPROM_PA_TYPE_8821AU					0xBC
+#define EEPROM_LNA_TYPE_8821AU				0xBF
+
+/* RTL8821AS */
+#define EEPROM_MAC_ADDR_8821AS				0x11A
+
+/* RTL8821AU */
+#define EEPROM_MAC_ADDR_8821AU				0x107
+#define EEPROM_VID_8821AU						0x100
+#define EEPROM_PID_8821AU						0x102
+
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8192 SE/SU
+ * **************************************************** */
+#define EEPROM_VID_92SE						0x0A
+#define EEPROM_DID_92SE						0x0C
+#define EEPROM_SVID_92SE						0x0E
+#define EEPROM_SMID_92SE						0x10
+
+#define EEPROM_MAC_ADDR_92S					0x12
+
+#define EEPROM_TSSI_A_92SE						0x74
+#define EEPROM_TSSI_B_92SE						0x75
+
+#define EEPROM_Version_92SE					0x7C
+
+
+#define EEPROM_VID_92SU						0x08
+#define EEPROM_PID_92SU						0x0A
+
+#define EEPROM_Version_92SU					0x50
+#define EEPROM_TSSI_A_92SU						0x6b
+#define EEPROM_TSSI_B_92SU						0x6c
+
+/* ====================================================
+	EEPROM/Efuse PG Offset for 8188FE/8188FU/8188FS
+   ====================================================
+ */
+
+#define GET_PG_KFREE_ON_8188F(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8188F(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8188F	0xEE
+#define PPG_THERMAL_OFFSET_8188F		0xEF
+
+/* 0x10 ~ 0x63 = TX power area. */
+#define	EEPROM_TX_PWR_INX_8188F				0x10
+
+#define	EEPROM_ChannelPlan_8188F			0xB8
+#define	EEPROM_XTAL_8188F					0xB9
+#define	EEPROM_THERMAL_METER_8188F			0xBA
+#define	EEPROM_IQK_LCK_8188F				0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8188F			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8188F	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8188F	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8188F		0xC1
+#define	EEPROM_FEATURE_OPTION_8188F			0xC2
+#define	EEPROM_RF_BT_SETTING_8188F			0xC3
+#define	EEPROM_VERSION_8188F				0xC4
+#define	EEPROM_CustomID_8188F				0xC5
+#define	EEPROM_TX_BBSWING_2G_8188F			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8188F	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8188F			0xC9
+#define	EEPROM_RFE_OPTION_8188F				0xCA
+#define EEPROM_COUNTRY_CODE_8188F			0xCB
+#define EEPROM_CUSTOMER_ID_8188F			0x7F
+#define EEPROM_SUBCUSTOMER_ID_8188F			0x59
+
+/* RTL8188FU */
+#define EEPROM_MAC_ADDR_8188FU				0xD7
+#define EEPROM_VID_8188FU					0xD0
+#define EEPROM_PID_8188FU					0xD2
+#define EEPROM_PA_TYPE_8188FU				0xBC
+#define EEPROM_LNA_TYPE_2G_8188FU			0xBD
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8188FU 0xD4
+
+/* RTL8188FS */
+#define	EEPROM_MAC_ADDR_8188FS				0x11A
+#define EEPROM_Voltage_ADDR_8188F			0x8
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8723BE/8723BU/8723BS
+ * ****************************************************
+ * 0x10 ~ 0x63 = TX power area. */
+#define	EEPROM_TX_PWR_INX_8723B				0x10
+
+#define	EEPROM_ChannelPlan_8723B				0xB8
+#define	EEPROM_XTAL_8723B						0xB9
+#define	EEPROM_THERMAL_METER_8723B			0xBA
+#define	EEPROM_IQK_LCK_8723B					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8723B			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8723B	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8723B	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8723B		0xC1
+#define	EEPROM_FEATURE_OPTION_8723B			0xC2
+#define	EEPROM_RF_BT_SETTING_8723B			0xC3
+#define	EEPROM_VERSION_8723B					0xC4
+#define	EEPROM_CustomID_8723B				0xC5
+#define	EEPROM_TX_BBSWING_2G_8723B			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8723B	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8723B		0xC9
+#define	EEPROM_RFE_OPTION_8723B				0xCA
+#define EEPROM_COUNTRY_CODE_8723B			0xCB
+
+/* RTL8723BE */
+#define EEPROM_MAC_ADDR_8723BE				0xD0
+#define EEPROM_VID_8723BE						0xD6
+#define EEPROM_DID_8723BE						0xD8
+#define EEPROM_SVID_8723BE						0xDA
+#define EEPROM_SMID_8723BE						0xDC
+
+/* RTL8723BU */
+#define EEPROM_MAC_ADDR_8723BU				0x107
+#define EEPROM_VID_8723BU						0x100
+#define EEPROM_PID_8723BU						0x102
+#define EEPROM_PA_TYPE_8723BU					0xBC
+#define EEPROM_LNA_TYPE_2G_8723BU				0xBD
+
+
+/* RTL8723BS */
+#define	EEPROM_MAC_ADDR_8723BS				0x11A
+#define EEPROM_Voltage_ADDR_8723B			0x8
+
+/* ****************************************************
+ *			EEPROM/Efuse PG Offset for 8703B
+ * **************************************************** */
+#define GET_PG_KFREE_ON_8703B(_pg_m)			LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8703B(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8703B	0xEE
+#define PPG_THERMAL_OFFSET_8703B		0xEF
+
+#define	EEPROM_TX_PWR_INX_8703B				0x10
+
+#define	EEPROM_ChannelPlan_8703B				0xB8
+#define	EEPROM_XTAL_8703B					0xB9
+#define	EEPROM_THERMAL_METER_8703B			0xBA
+#define	EEPROM_IQK_LCK_8703B					0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8703B			0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8703B	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8703B	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8703B		0xC1
+#define	EEPROM_FEATURE_OPTION_8703B			0xC2
+#define	EEPROM_RF_BT_SETTING_8703B			0xC3
+#define	EEPROM_VERSION_8703B					0xC4
+#define	EEPROM_CustomID_8703B					0xC5
+#define	EEPROM_TX_BBSWING_2G_8703B			0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8703B	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8703B		0xC9
+#define	EEPROM_RFE_OPTION_8703B				0xCA
+#define EEPROM_COUNTRY_CODE_8703B			0xCB
+
+/* RTL8703BU */
+#define EEPROM_MAC_ADDR_8703BU                          0x107
+#define EEPROM_VID_8703BU                               0x100
+#define EEPROM_PID_8703BU                               0x102
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8703BU            0x104
+#define EEPROM_PA_TYPE_8703BU                           0xBC
+#define EEPROM_LNA_TYPE_2G_8703BU                       0xBD
+
+/* RTL8703BS */
+#define	EEPROM_MAC_ADDR_8703BS				0x11A
+#define	EEPROM_Voltage_ADDR_8703B			0x8
+
+/*
+ * ====================================================
+ *	EEPROM/Efuse PG Offset for 8822B
+ * ====================================================
+ */
+#define GET_PG_KFREE_ON_8822B(_pg_m)		LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8822B(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8822B		0xEE
+#define PPG_THERMAL_OFFSET_8822B		0xEF
+
+#define	EEPROM_TX_PWR_INX_8822B			0x10
+
+#define	EEPROM_ChannelPlan_8822B		0xB8
+#define	EEPROM_XTAL_8822B			0xB9
+#define	EEPROM_THERMAL_METER_8822B		0xBA
+#define	EEPROM_IQK_LCK_8822B			0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8822B		0xBC
+/* PATH A & PATH B */
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_AB_8822B	0xBD
+/* PATH C & PATH D */
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_CD_8822B	0xBE
+/* PATH A & PATH B */
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_AB_8822B	0xBF
+/* PATH C & PATH D */
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_CD_8822B	0xC0
+
+#define	EEPROM_RF_BOARD_OPTION_8822B		0xC1
+#define	EEPROM_FEATURE_OPTION_8822B		0xC2
+#define	EEPROM_RF_BT_SETTING_8822B		0xC3
+#define	EEPROM_VERSION_8822B			0xC4
+#define	EEPROM_CustomID_8822B			0xC5
+#define	EEPROM_TX_BBSWING_2G_8822B		0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8822B	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8822B		0xC9
+#define	EEPROM_RFE_OPTION_8822B			0xCA
+#define EEPROM_COUNTRY_CODE_8822B		0xCB
+
+/* RTL8822BU */
+#define EEPROM_MAC_ADDR_8822BU			0x107
+#define EEPROM_VID_8822BU			0x100
+#define EEPROM_PID_8822BU			0x102
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8822BU	0x104
+#define EEPROM_USB_MODE_8822BU			0x06
+
+/* RTL8822BS */
+#define	EEPROM_MAC_ADDR_8822BS			0x11A
+
+/* RTL8822BE */
+#define	EEPROM_MAC_ADDR_8822BE			0xD0
+/*
+ * ====================================================
+ *	EEPROM/Efuse PG Offset for 8821C
+ * ====================================================
+ */
+#define GET_PG_KFREE_ON_8821C(_pg_m)		LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8821C(_pg_m)	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8821C		0xEE
+#define PPG_THERMAL_OFFSET_8821C		0xEF
+
+#define	EEPROM_TX_PWR_INX_8821C			0x10
+
+#define	EEPROM_CHANNEL_PLAN_8821C		0xB8
+#define	EEPROM_XTAL_8821C			0xB9
+#define	EEPROM_THERMAL_METER_8821C		0xBA
+#define	EEPROM_IQK_LCK_8821C			0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8821C		0xBC
+/* PATH A & PATH B */
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_AB_8821C	0xBD
+/* PATH C & PATH D */
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_CD_8821C	0xBE
+/* PATH A & PATH B */
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_AB_8821C	0xBF
+/* PATH C & PATH D */
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_CD_8821C	0xC0
+
+#define	EEPROM_RF_BOARD_OPTION_8821C		0xC1
+#define	EEPROM_FEATURE_OPTION_8821C		0xC2
+#define	EEPROM_RF_BT_SETTING_8821C		0xC3
+#define	EEPROM_VERSION_8821C			0xC4
+#define	EEPROM_CUSTOMER_ID_8821C			0xC5
+#define	EEPROM_TX_BBSWING_2G_8821C		0xC6
+#define	EEPROM_TX_BBSWING_5G_8821C		0xC7
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8821C	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8821C		0xC9
+#define	EEPROM_RFE_OPTION_8821C			0xCA
+#define EEPROM_COUNTRY_CODE_8821C		0xCB
+
+/* RTL8821CU */
+#define EEPROM_MAC_ADDR_8821CU			0x107
+#define EEPROM_VID_8821CU					0x100
+#define EEPROM_PID_8821CU					0x102
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8821CU	0x104
+#define EEPROM_USB_MODE_8821CU			0x06
+
+/* RTL8821CS */
+#define	EEPROM_MAC_ADDR_8821CS			0x11A
+
+/* RTL8821CE */
+#define	EEPROM_MAC_ADDR_8821CE			0xD0
+/* ****************************************************
+ *	EEPROM/Efuse PG Offset for 8723D
+ * **************************************************** */
+#define GET_PG_KFREE_ON_8723D(_pg_m)	\
+	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC1, 4, 1)
+#define GET_PG_KFREE_THERMAL_K_ON_8723D(_pg_m)	\
+	LE_BITS_TO_1BYTE(((u8 *)(_pg_m)) + 0xC8, 5, 1)
+
+#define PPG_8723D_S1	0
+#define PPG_8723D_S0	1
+
+#define PPG_BB_GAIN_2G_TXA_OFFSET_8723D		0xEE
+#define PPG_BB_GAIN_2G_TX_OFFSET_8723D		0x1EE
+#define PPG_THERMAL_OFFSET_8723D		0xEF
+
+#define	EEPROM_TX_PWR_INX_8723D			0x10
+
+#define	EEPROM_ChannelPlan_8723D		0xB8
+#define	EEPROM_XTAL_8723D			0xB9
+#define	EEPROM_THERMAL_METER_8723D		0xBA
+#define	EEPROM_IQK_LCK_8723D			0xBB
+#define	EEPROM_2G_5G_PA_TYPE_8723D		0xBC
+#define	EEPROM_2G_LNA_TYPE_GAIN_SEL_8723D	0xBD
+#define	EEPROM_5G_LNA_TYPE_GAIN_SEL_8723D	0xBF
+
+#define	EEPROM_RF_BOARD_OPTION_8723D		0xC1
+#define	EEPROM_FEATURE_OPTION_8723D		0xC2
+#define	EEPROM_RF_BT_SETTING_8723D		0xC3
+#define	EEPROM_VERSION_8723D			0xC4
+#define	EEPROM_CustomID_8723D			0xC5
+#define	EEPROM_TX_BBSWING_2G_8723D		0xC6
+#define	EEPROM_TX_PWR_CALIBRATE_RATE_8723D	0xC8
+#define	EEPROM_RF_ANTENNA_OPT_8723D		0xC9
+#define	EEPROM_RFE_OPTION_8723D			0xCA
+#define EEPROM_COUNTRY_CODE_8723D		0xCB
+
+/* RTL8723DE */
+#define EEPROM_MAC_ADDR_8723DE              0xD0
+#define EEPROM_VID_8723DE                   0xD6
+#define EEPROM_DID_8723DE                   0xD8
+#define EEPROM_SVID_8723DE                  0xDA
+#define EEPROM_SMID_8723DE                  0xDC
+
+/* RTL8723DU */
+#define EEPROM_MAC_ADDR_8723DU                  0x107
+#define EEPROM_VID_8723DU                       0x100
+#define EEPROM_PID_8723DU                       0x102
+#define EEPROM_USB_OPTIONAL_FUNCTION0_8723DU    0x104
+
+/* RTL8723BS */
+#define	EEPROM_MAC_ADDR_8723DS			0x11A
+#define	EEPROM_Voltage_ADDR_8723D		0x8
+
+/* ****************************************************
+ *			EEPROM/Efuse Value Type
+ * **************************************************** */
+#define EETYPE_TX_PWR							0x0
+/* ****************************************************
+ *			EEPROM/Efuse Default Value
+ * **************************************************** */
+#define EEPROM_CID_DEFAULT					0x0
+#define EEPROM_CID_DEFAULT_EXT				0xFF /* Reserved for Realtek */
+#define EEPROM_CID_TOSHIBA						0x4
+#define EEPROM_CID_CCX							0x10
+#define EEPROM_CID_QMI							0x0D
+#define EEPROM_CID_WHQL						0xFE
+
+#define EEPROM_CHANNEL_PLAN_FCC				0x0
+#define EEPROM_CHANNEL_PLAN_IC				0x1
+#define EEPROM_CHANNEL_PLAN_ETSI				0x2
+#define EEPROM_CHANNEL_PLAN_SPAIN			0x3
+#define EEPROM_CHANNEL_PLAN_FRANCE			0x4
+#define EEPROM_CHANNEL_PLAN_MKK				0x5
+#define EEPROM_CHANNEL_PLAN_MKK1				0x6
+#define EEPROM_CHANNEL_PLAN_ISRAEL			0x7
+#define EEPROM_CHANNEL_PLAN_TELEC			0x8
+#define EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
+#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
+#define EEPROM_CHANNEL_PLAN_NCC_TAIWAN		0xB
+#define EEPROM_CHANNEL_PLAN_CHIAN			0XC
+#define EEPROM_CHANNEL_PLAN_SINGAPORE_INDIA_MEXICO  0XD
+#define EEPROM_CHANNEL_PLAN_KOREA			0xE
+#define EEPROM_CHANNEL_PLAN_TURKEY	0xF
+#define EEPROM_CHANNEL_PLAN_JAPAN	0x10
+#define EEPROM_CHANNEL_PLAN_FCC_NO_DFS		0x11
+#define EEPROM_CHANNEL_PLAN_JAPAN_NO_DFS	0x12
+#define EEPROM_CHANNEL_PLAN_WORLD_WIDE_5G	0x13
+#define EEPROM_CHANNEL_PLAN_TAIWAN_NO_DFS	0x14
+
+#define EEPROM_USB_OPTIONAL1					0xE
+#define EEPROM_CHANNEL_PLAN_BY_HW_MASK		0x80
+
+#define RTL_EEPROM_ID							0x8129
+#define EEPROM_Default_TSSI						0x0
+#define EEPROM_Default_BoardType				0x02
+#define EEPROM_Default_ThermalMeter			0x12
+#define EEPROM_Default_ThermalMeter_92SU		0x7
+#define EEPROM_Default_ThermalMeter_88E		0x18
+#define EEPROM_Default_ThermalMeter_8812		0x18
+#define	EEPROM_Default_ThermalMeter_8192E			0x1A
+#define	EEPROM_Default_ThermalMeter_8723B		0x18
+#define	EEPROM_Default_ThermalMeter_8703B		0x18
+#define	EEPROM_Default_ThermalMeter_8723D		0x18
+#define	EEPROM_Default_ThermalMeter_8188F		0x18
+#define EEPROM_Default_ThermalMeter_8814A		0x18
+
+
+#define EEPROM_Default_CrystalCap				0x0
+#define EEPROM_Default_CrystalCap_8723A		0x20
+#define EEPROM_Default_CrystalCap_88E			0x20
+#define EEPROM_Default_CrystalCap_8812			0x20
+#define EEPROM_Default_CrystalCap_8814			0x20
+#define EEPROM_Default_CrystalCap_8192E			0x20
+#define EEPROM_Default_CrystalCap_8723B			0x20
+#define EEPROM_Default_CrystalCap_8703B			0x20
+#define EEPROM_Default_CrystalCap_8723D			0x20
+#define EEPROM_Default_CrystalCap_8188F			0x20
+#define EEPROM_Default_CrystalFreq				0x0
+#define EEPROM_Default_TxPowerLevel_92C		0x22
+#define EEPROM_Default_TxPowerLevel_2G			0x2C
+#define EEPROM_Default_TxPowerLevel_5G			0x22
+#define EEPROM_Default_TxPowerLevel			0x22
+#define EEPROM_Default_HT40_2SDiff				0x0
+#define EEPROM_Default_HT20_Diff				2
+#define EEPROM_Default_LegacyHTTxPowerDiff		0x3
+#define EEPROM_Default_LegacyHTTxPowerDiff_92C	0x3
+#define EEPROM_Default_LegacyHTTxPowerDiff_92D	0x4
+#define EEPROM_Default_HT40_PwrMaxOffset		0
+#define EEPROM_Default_HT20_PwrMaxOffset		0
+
+#define EEPROM_Default_PID						0x1234
+#define EEPROM_Default_VID						0x5678
+#define EEPROM_Default_CustomerID				0xAB
+#define EEPROM_Default_CustomerID_8188E		0x00
+#define EEPROM_Default_SubCustomerID			0xCD
+#define EEPROM_Default_Version					0
+
+#define EEPROM_Default_externalPA_C9		0x00
+#define EEPROM_Default_externalPA_CC		0xFF
+#define EEPROM_Default_internalPA_SP3T_C9	0xAA
+#define EEPROM_Default_internalPA_SP3T_CC	0xAF
+#define EEPROM_Default_internalPA_SPDT_C9	0xAA
+#ifdef CONFIG_PCI_HCI
+	#define EEPROM_Default_internalPA_SPDT_CC	0xA0
+#else
+	#define EEPROM_Default_internalPA_SPDT_CC	0xFA
+#endif
+#define EEPROM_Default_PAType						0
+#define EEPROM_Default_LNAType						0
+
+/* New EFUSE default value */
+#define EEPROM_DEFAULT_CHANNEL_PLAN		0x7F
+#define EEPROM_DEFAULT_BOARD_OPTION		0x00
+#define EEPROM_DEFAULT_RFE_OPTION_8192E 0xFF
+#define EEPROM_DEFAULT_RFE_OPTION_8188E 0xFF
+#define EEPROM_DEFAULT_RFE_OPTION		0x04
+#define EEPROM_DEFAULT_FEATURE_OPTION	0x00
+#define EEPROM_DEFAULT_BT_OPTION			0x10
+
+
+#define EEPROM_DEFAULT_TX_CALIBRATE_RATE	0x00
+
+/* PCIe related */
+#define	EEPROM_PCIE_DEV_CAP_01				0xE0 /* Express device capability in PCIe configuration space, i.e., map to offset 0x74 */
+#define	EEPROM_PCIE_DEV_CAP_02				0xE1 /* Express device capability in PCIe configuration space, i.e., map to offset 0x75 */
+
+
+/*
+ * For VHT series TX power by rate table.
+ * VHT TX power by rate off setArray =
+ * Band:-2G&5G = 0 / 1
+ * RF: at most 4*4 = ABCD=0/1/2/3
+ * CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
+ *   */
+#define TX_PWR_BY_RATE_NUM_BAND			2
+#define TX_PWR_BY_RATE_NUM_RF			4
+#define TX_PWR_BY_RATE_NUM_RATE			84
+
+#define TXPWR_LMT_MAX_RF				4
+
+/* ----------------------------------------------------------------------------
+ * EEPROM/EFUSE data structure definition.
+ * ---------------------------------------------------------------------------- */
+
+/* For 88E new structure */
+
+/*
+2.4G:
+{
+{1,2},
+{3,4,5},
+{6,7,8},
+{9,10,11},
+{12,13},
+{14}
+}
+
+5G:
+{
+{36,38,40},
+{44,46,48},
+{52,54,56},
+{60,62,64},
+{100,102,104},
+{108,110,112},
+{116,118,120},
+{124,126,128},
+{132,134,136},
+{140,142,144},
+{149,151,153},
+{157,159,161},
+{173,175,177},
+}
+*/
+#define	MAX_RF_PATH				4
+#define RF_PATH_MAX				MAX_RF_PATH
+#define	MAX_CHNL_GROUP_24G		6
+#define	MAX_CHNL_GROUP_5G		14
+
+/* It must always set to 4, otherwise read efuse table sequence will be wrong. */
+#define	MAX_TX_COUNT				4
+
+typedef struct _TxPowerInfo24G {
+	u8 IndexCCK_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	/* If only one tx, only BW20 and OFDM are used. */
+	s8 CCK_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+} TxPowerInfo24G, *PTxPowerInfo24G;
+
+typedef struct _TxPowerInfo5G {
+	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_5G];
+	/* If only one tx, only BW20, OFDM, BW80 and BW160 are used. */
+	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW80_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW160_Diff[MAX_RF_PATH][MAX_TX_COUNT];
+} TxPowerInfo5G, *PTxPowerInfo5G;
+
+
+typedef	enum _BT_Ant_NUM {
+	Ant_x2	= 0,
+	Ant_x1	= 1
+} BT_Ant_NUM, *PBT_Ant_NUM;
+
+typedef	enum _BT_CoType {
+	BT_2WIRE		= 0,
+	BT_ISSC_3WIRE	= 1,
+	BT_ACCEL		= 2,
+	BT_CSR_BC4		= 3,
+	BT_CSR_BC8		= 4,
+	BT_RTL8756		= 5,
+	BT_RTL8723A		= 6,
+	BT_RTL8821		= 7,
+	BT_RTL8723B		= 8,
+	BT_RTL8192E		= 9,
+	BT_RTL8814A		= 10,
+	BT_RTL8812A		= 11,
+	BT_RTL8703B		= 12,
+	BT_RTL8822B		= 13,
+	BT_RTL8723D		= 14,
+	BT_RTL8821C		= 15
+} BT_CoType, *PBT_CoType;
+
+typedef	enum _BT_RadioShared {
+	BT_Radio_Shared	= 0,
+	BT_Radio_Individual	= 1,
+} BT_RadioShared, *PBT_RadioShared;
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/hal_phy.h b/drivers/staging/rtl8188eu/include/hal_phy.h
new file mode 100644
index 000000000000..277f508e8bfc
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_phy.h
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_PHY_H__
+#define __HAL_PHY_H__
+
+
+#if DISABLE_BB_RF
+	#define	HAL_FW_ENABLE				0
+	#define	HAL_MAC_ENABLE			0
+	#define	HAL_BB_ENABLE				0
+	#define	HAL_RF_ENABLE				0
+#else /* FPGA_PHY and ASIC */
+	#define	HAL_FW_ENABLE				1
+	#define	HAL_MAC_ENABLE			1
+	#define	HAL_BB_ENABLE				1
+	#define	HAL_RF_ENABLE				1
+#endif
+
+#define	RF6052_MAX_TX_PWR			0x3F
+#define	RF6052_MAX_REG_88E			0xFF
+#define	RF6052_MAX_REG_92C			0x7F
+
+#define	RF6052_MAX_REG	\
+	((RF6052_MAX_REG_88E > RF6052_MAX_REG_92C) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C)
+
+#define GET_RF6052_REAL_MAX_REG(_Adapter)	\
+	(IS_HARDWARE_TYPE_8188E(_Adapter) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C)
+
+#define	RF6052_MAX_PATH				2
+
+/*
+ * Antenna detection method, i.e., using single tone detection or RSSI reported from each antenna detected.
+ * Added by Roger, 2013.05.22.
+ *   */
+#define ANT_DETECT_BY_SINGLE_TONE	BIT0
+#define ANT_DETECT_BY_RSSI				BIT1
+#define IS_ANT_DETECT_SUPPORT_SINGLE_TONE(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_SINGLE_TONE)
+#define IS_ANT_DETECT_SUPPORT_RSSI(__Adapter)		((GET_HAL_DATA(__Adapter)->AntDetection) & ANT_DETECT_BY_RSSI)
+
+
+/*--------------------------Define Parameters-------------------------------*/
+typedef	enum _RF_TYPE {
+	RF_TYPE_MIN = 0,	/* 0 */
+	RF_8225 = 1,			/* 1 11b/g RF for verification only */
+	RF_8256 = 2,			/* 2 11b/g/n */
+	RF_8258 = 3,			/* 3 11a/b/g/n RF */
+	RF_6052 = 4,			/* 4 11b/g/n RF */
+	RF_PSEUDO_11N = 5,	/* 5, It is a temporality RF. */
+	RF_TYPE_MAX
+} RF_TYPE_E, *PRF_TYPE_E;
+
+#define	TX_1S			0
+#define	TX_2S			1
+#define	TX_3S			2
+#define	TX_4S			3
+
+typedef enum _ANTENNA_PATH {
+	ANTENNA_NONE	= 0,
+	ANTENNA_D		= 1,
+	ANTENNA_C		= 2,
+	ANTENNA_CD	= 3,
+	ANTENNA_B		= 4,
+	ANTENNA_BD	= 5,
+	ANTENNA_BC	= 6,
+	ANTENNA_BCD	= 7,
+	ANTENNA_A		= 8,
+	ANTENNA_AD	= 9,
+	ANTENNA_AC	= 10,
+	ANTENNA_ACD	= 11,
+	ANTENNA_AB	= 12,
+	ANTENNA_ABD	= 13,
+	ANTENNA_ABC	= 14,
+	ANTENNA_ABCD	= 15
+} ANTENNA_PATH;
+
+typedef enum _RF_CONTENT {
+	radioa_txt = 0x1000,
+	radiob_txt = 0x1001,
+	radioc_txt = 0x1002,
+	radiod_txt = 0x1003
+} RF_CONTENT;
+
+typedef enum _BaseBand_Config_Type {
+	BaseBand_Config_PHY_REG = 0,			/* Radio Path A */
+	BaseBand_Config_AGC_TAB = 1,			/* Radio Path B */
+	BaseBand_Config_AGC_TAB_2G = 2,
+	BaseBand_Config_AGC_TAB_5G = 3,
+	BaseBand_Config_PHY_REG_PG
+} BaseBand_Config_Type, *PBaseBand_Config_Type;
+
+typedef enum _HW_BLOCK {
+	HW_BLOCK_MAC = 0,
+	HW_BLOCK_PHY0 = 1,
+	HW_BLOCK_PHY1 = 2,
+	HW_BLOCK_RF = 3,
+	HW_BLOCK_MAXIMUM = 4, /* Never use this */
+} HW_BLOCK_E, *PHW_BLOCK_E;
+
+typedef enum _WIRELESS_MODE {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20,
+	WIRELESS_MODE_AC_5G = 0x40,
+	WIRELESS_MODE_AC_24G  = 0x80,
+	WIRELESS_MODE_AC_ONLY  = 0x100,
+} WIRELESS_MODE;
+
+typedef enum _SwChnlCmdID {
+	CmdID_End,
+	CmdID_SetTxPowerLevel,
+	CmdID_BBRegWrite10,
+	CmdID_WritePortUlong,
+	CmdID_WritePortUshort,
+	CmdID_WritePortUchar,
+	CmdID_RF_WriteReg,
+} SwChnlCmdID;
+
+typedef struct _SwChnlCmd {
+	SwChnlCmdID	CmdID;
+	u32				Para1;
+	u32				Para2;
+	u32				msDelay;
+} SwChnlCmd;
+
+typedef struct _R_ANTENNA_SELECT_OFDM {
+	u32			r_tx_antenna:4;
+	u32			r_ant_l:4;
+	u32			r_ant_non_ht:4;
+	u32			r_ant_ht1:4;
+	u32			r_ant_ht2:4;
+	u32			r_ant_ht_s1:4;
+	u32			r_ant_non_ht_s1:4;
+	u32			OFDM_TXSC:2;
+	u32			Reserved:2;
+} R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK {
+	u8			r_cckrx_enable_2:2;
+	u8			r_cckrx_enable:2;
+	u8			r_ccktx_enable:4;
+} R_ANTENNA_SELECT_CCK;
+
+typedef struct RF_Shadow_Compare_Map {
+	/* Shadow register value */
+	u32		Value;
+	/* Compare or not flag */
+	u8		Compare;
+	/* Record If it had ever modified unpredicted */
+	u8		ErrorOrNot;
+	/* Recorver Flag */
+	u8		Recorver;
+	/*  */
+	u8		Driver_Write;
+} RF_SHADOW_T;
+
+/*--------------------------Exported Function prototype---------------------*/
+
+u32
+PHY_CalculateBitShift(
+	u32 BitMask
+);
+
+u32
+PHY_RFShadowRead(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset);
+
+void
+PHY_RFShadowWrite(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset,
+	u32				Data);
+
+bool
+PHY_RFShadowCompare(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset);
+
+void
+PHY_RFShadowRecorver(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset);
+
+void
+PHY_RFShadowCompareAll(
+	PADAPTER		Adapter);
+
+void
+PHY_RFShadowRecorverAll(
+	PADAPTER		Adapter);
+
+void
+PHY_RFShadowCompareFlagSet(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset,
+	u8				Type);
+
+void
+PHY_RFShadowRecorverFlagSet(
+	PADAPTER		Adapter,
+	u8				eRFPath,
+	u32				Offset,
+	u8				Type);
+
+void
+PHY_RFShadowCompareFlagSetAll(
+	PADAPTER		Adapter);
+
+void
+PHY_RFShadowRecorverFlagSetAll(
+	PADAPTER		Adapter);
+
+void
+PHY_RFShadowRefresh(
+	PADAPTER		Adapter);
+
+#endif /* __HAL_COMMON_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_phy_reg.h b/drivers/staging/rtl8188eu/include/hal_phy_reg.h
new file mode 100644
index 000000000000..234b791655ee
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_phy_reg.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_PHY_REG_H__
+#define __HAL_PHY_REG_H__
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask
+ * #if (RTL92SE_FPGA_VERIFY == 1)
+ * #define		bRFRegOffsetMask	0xfff
+ * #else */
+#define		bRFRegOffsetMask	0xfffff
+/* #endif */
+
+#endif /* __HAL_PHY_REG_H__ */
diff --git a/drivers/staging/rtl8188eu/include/hal_sdio.h b/drivers/staging/rtl8188eu/include/hal_sdio.h
new file mode 100644
index 000000000000..66878fa8f86a
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/hal_sdio.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __HAL_SDIO_H_
+#define __HAL_SDIO_H_
+
+#define ffaddr2deviceId(pdvobj, addr)	(pdvobj->Queue2Pipe[addr])
+
+u8 rtw_hal_sdio_max_txoqt_free_space(_adapter *padapter);
+u8 rtw_hal_sdio_query_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_sdio_update_tx_freepage(_adapter *padapter, u8 PageIdx, u8 RequiredPageNum);
+void rtw_hal_set_sdio_tx_max_length(PADAPTER padapter, u8 numHQ, u8 numNQ, u8 numLQ, u8 numPubQ);
+u32 rtw_hal_get_sdio_tx_max_length(PADAPTER padapter, u8 queue_idx);
+bool sdio_power_on_check(PADAPTER padapter);
+
+#ifdef CONFIG_FW_C2H_REG
+void sd_c2h_hisr_hdl(_adapter *adapter);
+#endif
+
+#endif /* __HAL_SDIO_H_ */
diff --git a/drivers/staging/rtl8188eu/include/ieee80211.h b/drivers/staging/rtl8188eu/include/ieee80211.h
new file mode 100644
index 000000000000..47bb5684d932
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/ieee80211.h
@@ -0,0 +1,1668 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+#define ETH_TYPE_LEN		2
+#define PAYLOAD_TYPE_LEN	1
+
+#define NET80211_TU_TO_US	1024		/* unit:us */
+#define DEFAULT_BCN_INTERVAL 100 /* 100 ms */
+
+#ifdef CONFIG_AP_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON = 16,
+	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
+	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
+	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
+	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
+	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
+	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
+	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_VHT BIT(14)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE	BIT(0)
+#define WPA_CIPHER_WEP40	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP	BIT(3)
+#define WPA_CIPHER_CCMP	BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+extern u8 RTW_WPA_OUI_TYPE[] ;
+extern u16 RTW_WPA_VERSION ;
+extern u8 WPA_AUTH_KEY_MGMT_NONE[];
+extern u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 WPA_CIPHER_SUITE_NONE[];
+extern u8 WPA_CIPHER_SUITE_WEP40[];
+extern u8 WPA_CIPHER_SUITE_TKIP[];
+extern u8 WPA_CIPHER_SUITE_WRAP[];
+extern u8 WPA_CIPHER_SUITE_CCMP[];
+extern u8 WPA_CIPHER_SUITE_WEP104[];
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+
+extern u16 RSN_VERSION_BSD;
+extern u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 RSN_CIPHER_SUITE_NONE[];
+extern u8 RSN_CIPHER_SUITE_WEP40[];
+extern u8 RSN_CIPHER_SUITE_TKIP[];
+extern u8 RSN_CIPHER_SUITE_WRAP[];
+extern u8 RSN_CIPHER_SUITE_CCMP[];
+extern u8 RSN_CIPHER_SUITE_WEP104[];
+
+
+typedef enum _RATEID_IDX_ {
+	RATEID_IDX_BGN_40M_2SS = 0,
+	RATEID_IDX_BGN_40M_1SS = 1,
+	RATEID_IDX_BGN_20M_2SS_BN = 2,
+	RATEID_IDX_BGN_20M_1SS_BN = 3,
+	RATEID_IDX_GN_N2SS = 4,
+	RATEID_IDX_GN_N1SS = 5,
+	RATEID_IDX_BG = 6,
+	RATEID_IDX_G = 7,
+	RATEID_IDX_B = 8,
+	RATEID_IDX_VHT_2SS = 9,
+	RATEID_IDX_VHT_1SS = 10,
+	RATEID_IDX_MIX1 = 11,
+	RATEID_IDX_MIX2 = 12,
+	RATEID_IDX_VHT_3SS = 13,
+	RATEID_IDX_BGN_3SS = 14,
+} RATEID_IDX, *PRATEID_IDX;
+
+typedef enum _RATR_TABLE_MODE {
+	RATR_INX_WIRELESS_NGB = 0,	/* BGN 40 Mhz 2SS 1SS */
+	RATR_INX_WIRELESS_NG = 1,		/* GN or N */
+	RATR_INX_WIRELESS_NB = 2,		/* BGN 20 Mhz 2SS 1SS  or BN */
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_AC_N = 8,
+} RATR_TABLE_MODE, *PRATR_TABLE_MODE;
+
+
+enum NETWORK_TYPE {
+	WIRELESS_INVALID = 0,
+	/* Sub-Element */
+	WIRELESS_11B = BIT(0), /* tx: cck only , rx: cck only, hw: cck */
+	WIRELESS_11G = BIT(1), /* tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm */
+	WIRELESS_11A = BIT(2), /* tx: ofdm only, rx: ofdm only, hw: ofdm only */
+	WIRELESS_11_24N = BIT(3), /* tx: MCS only, rx: MCS & cck, hw: MCS & cck */
+	WIRELESS_11_5N = BIT(4), /* tx: MCS only, rx: MCS & ofdm, hw: ofdm only */
+	WIRELESS_AUTO = BIT(5),
+	WIRELESS_11AC = BIT(6),
+
+	/* Combination */
+	/* Type for current wireless mode */
+	WIRELESS_11BG = (WIRELESS_11B | WIRELESS_11G), /* tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm */
+	WIRELESS_11G_24N = (WIRELESS_11G | WIRELESS_11_24N), /* tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm */
+	WIRELESS_11A_5N = (WIRELESS_11A | WIRELESS_11_5N), /* tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
+	WIRELESS_11B_24N = (WIRELESS_11B | WIRELESS_11_24N), /* tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
+	WIRELESS_11BG_24N = (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N), /* tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
+	WIRELESS_11_24AC = (WIRELESS_11G | WIRELESS_11AC),
+	WIRELESS_11_5AC = (WIRELESS_11A | WIRELESS_11AC),
+
+
+	/* Type for registry default wireless mode */
+	WIRELESS_11AGN = (WIRELESS_11A | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N), /* tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
+	WIRELESS_11ABGN = (WIRELESS_11A | WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N),
+	WIRELESS_MODE_24G = (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N),
+	WIRELESS_MODE_5G = (WIRELESS_11A | WIRELESS_11_5N | WIRELESS_11AC),
+	WIRELESS_MODE_MAX = (WIRELESS_11A | WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N | WIRELESS_11_5N | WIRELESS_11AC),
+};
+
+#define SUPPORTED_24G_NETTYPE_MSK WIRELESS_MODE_24G
+#define SUPPORTED_5G_NETTYPE_MSK WIRELESS_MODE_5G
+
+#define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WIRELESS_11BG | WIRELESS_11A)))
+
+#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? true : false)
+#define is_supported_5g(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? true : false)
+
+#define IsEnableHWCCK(NetType) IsSupported24G(NetType)
+#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G | WIRELESS_11_24N | SUPPORTED_5G_NETTYPE_MSK) ? true : false)
+
+#define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
+#define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
+#define IsSupportedRxHT(NetType) IsEnableHWOFDM(NetType)
+
+#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? true : false)
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G | WIRELESS_11A) ? true : false)
+#define is_supported_ht(NetType) ((NetType) & (WIRELESS_11_24N | WIRELESS_11_5N) ? true : false)
+
+#define is_supported_vht(NetType) ((NetType) & (WIRELESS_11AC) ? true : false)
+
+
+
+
+
+typedef struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+		struct {
+			int command;
+			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+#ifdef CONFIG_AP_MODE
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			u8 tx_supp_rates[16];
+			struct rtw_ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			u8	reserved[2];/* for set max_num_sta */
+			u8	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;
+} ieee_param;
+
+#ifdef CONFIG_AP_MODE
+typedef struct ieee_param_ex {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	u8 data[0];
+} ieee_param_ex;
+
+struct sta_data {
+	u16 aid;
+	u16 capability;
+	int flags;
+	u32 sta_set;
+	u8 tx_supp_rates[16];
+	u32 tx_supp_rates_len;
+	struct rtw_ieee80211_ht_cap ht_cap;
+	u64	rx_pkts;
+	u64	rx_bytes;
+	u64	rx_drops;
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64	tx_drops;
+};
+#endif
+
+
+#if WIRELESS_EXT < 17
+	#define IW_QUAL_QUAL_INVALID   0x10
+	#define IW_QUAL_LEVEL_INVALID  0x20
+	#define IW_QUAL_NOISE_INVALID  0x40
+	#define IW_QUAL_QUAL_UPDATED   0x1
+	#define IW_QUAL_LEVEL_UPDATED  0x2
+	#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	_list	list;
+};
+
+struct rtw_ieee80211_hdr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __attribute__((packed));
+
+struct rtw_ieee80211_hdr_3addr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+} __attribute__((packed));
+
+
+struct rtw_ieee80211_hdr_qos {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	__le16	qc;
+}  __attribute__((packed));
+
+struct rtw_ieee80211_hdr_3addr_qos {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	__le16     qc;
+}  __attribute__((packed));
+
+struct eapol {
+	u8 snap[6];
+	__le16 ethertype;
+	u8 version;
+	u8 type;
+	__le16 length;
+} __attribute__((packed));
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0003
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS	0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_PROTECTED	0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+#define RTW_IEEE80211_FCTL_CTL_EXT	0x0f00
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+#define RTW_IEEE80211_FTYPE_EXT		0x000c
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+#define RTW_IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define RTW_IEEE80211_STYPE_CTL_EXT		0x0060
+#define RTW_IEEE80211_STYPE_BACK_REQ		0x0080
+#define RTW_IEEE80211_STYPE_BACK		0x0090
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK		0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_STYPE_QOS_DATA		0x0080
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
+#define RTW_IEEE80211_STYPE_QOS_NULLFUNC	0x00C0
+#define RTW_IEEE80211_STYPE_QOS_CFACK		0x00D0
+#define RTW_IEEE80211_STYPE_QOS_CFPOLL		0x00E0
+#define RTW_IEEE80211_STYPE_QOS_CFACKPOLL	0x00F0
+
+/* sequence control field */
+#define RTW_IEEE80211_SCTL_FRAG	0x000F
+#define RTW_IEEE80211_SCTL_SEQ	0xFFF0
+
+
+#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
+#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+	#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+	#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+struct ieee80211_snap_hdr {
+
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__((packed));
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_ACTIVE_ROAM 65533
+#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
+#define WLAN_REASON_EXPIRATION_CHK 65535
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+/* EIDs defined by IEEE 802.11h - START */
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUITE 40
+#define WLAN_EID_IBSS_DFS 41
+/* EIDs defined by IEEE 802.11h - END */
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
+#define WLAN_EID_VHT_CAPABILITY 191
+#define WLAN_EID_VHT_OPERATION 192
+#define WLAN_EID_VHT_OP_MODE_NOTIFY 199
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+		IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+		IEEE80211_CCK_RATE_5MB_MASK | \
+		IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+		IEEE80211_OFDM_RATE_12MB_MASK | \
+		IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+		IEEE80211_OFDM_RATE_9MB_MASK  | \
+		IEEE80211_OFDM_RATE_18MB_MASK | \
+		IEEE80211_OFDM_RATE_36MB_MASK | \
+		IEEE80211_OFDM_RATE_48MB_MASK | \
+		IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+				      IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+enum MGN_RATE {
+	MGN_1M		= 0x02,
+	MGN_2M		= 0x04,
+	MGN_5_5M	= 0x0B,
+	MGN_6M		= 0x0C,
+	MGN_9M		= 0x12,
+	MGN_11M	= 0x16,
+	MGN_12M	= 0x18,
+	MGN_18M	= 0x24,
+	MGN_24M	= 0x30,
+	MGN_36M	= 0x48,
+	MGN_48M	= 0x60,
+	MGN_54M	= 0x6C,
+	MGN_MCS32	= 0x7F,
+	MGN_MCS0,
+	MGN_MCS1,
+	MGN_MCS2,
+	MGN_MCS3,
+	MGN_MCS4,
+	MGN_MCS5,
+	MGN_MCS6,
+	MGN_MCS7,
+	MGN_MCS8,
+	MGN_MCS9,
+	MGN_MCS10,
+	MGN_MCS11,
+	MGN_MCS12,
+	MGN_MCS13,
+	MGN_MCS14,
+	MGN_MCS15,
+	MGN_MCS16,
+	MGN_MCS17,
+	MGN_MCS18,
+	MGN_MCS19,
+	MGN_MCS20,
+	MGN_MCS21,
+	MGN_MCS22,
+	MGN_MCS23,
+	MGN_MCS24,
+	MGN_MCS25,
+	MGN_MCS26,
+	MGN_MCS27,
+	MGN_MCS28,
+	MGN_MCS29,
+	MGN_MCS30,
+	MGN_MCS31,
+	MGN_VHT1SS_MCS0,
+	MGN_VHT1SS_MCS1,
+	MGN_VHT1SS_MCS2,
+	MGN_VHT1SS_MCS3,
+	MGN_VHT1SS_MCS4,
+	MGN_VHT1SS_MCS5,
+	MGN_VHT1SS_MCS6,
+	MGN_VHT1SS_MCS7,
+	MGN_VHT1SS_MCS8,
+	MGN_VHT1SS_MCS9,
+	MGN_VHT2SS_MCS0,
+	MGN_VHT2SS_MCS1,
+	MGN_VHT2SS_MCS2,
+	MGN_VHT2SS_MCS3,
+	MGN_VHT2SS_MCS4,
+	MGN_VHT2SS_MCS5,
+	MGN_VHT2SS_MCS6,
+	MGN_VHT2SS_MCS7,
+	MGN_VHT2SS_MCS8,
+	MGN_VHT2SS_MCS9,
+	MGN_VHT3SS_MCS0,
+	MGN_VHT3SS_MCS1,
+	MGN_VHT3SS_MCS2,
+	MGN_VHT3SS_MCS3,
+	MGN_VHT3SS_MCS4,
+	MGN_VHT3SS_MCS5,
+	MGN_VHT3SS_MCS6,
+	MGN_VHT3SS_MCS7,
+	MGN_VHT3SS_MCS8,
+	MGN_VHT3SS_MCS9,
+	MGN_VHT4SS_MCS0,
+	MGN_VHT4SS_MCS1,
+	MGN_VHT4SS_MCS2,
+	MGN_VHT4SS_MCS3,
+	MGN_VHT4SS_MCS4,
+	MGN_VHT4SS_MCS5,
+	MGN_VHT4SS_MCS6,
+	MGN_VHT4SS_MCS7,
+	MGN_VHT4SS_MCS8,
+	MGN_VHT4SS_MCS9,
+	MGN_UNKNOWN
+};
+
+#define IS_HT_RATE(_rate)	((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS31)
+#define IS_VHT_RATE(_rate)	((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)
+#define IS_CCK_RATE(_rate)	((_rate) == MGN_1M || (_rate) == MGN_2M || (_rate) == MGN_5_5M || (_rate) == MGN_11M)
+#define IS_OFDM_RATE(_rate)	((_rate) >= MGN_6M && (_rate) <= MGN_54M  && (_rate) != MGN_11M)
+
+#define IS_HT1SS_RATE(_rate) ((_rate) >= MGN_MCS0 && (_rate) <= MGN_MCS7)
+#define IS_HT2SS_RATE(_rate) ((_rate) >= MGN_MCS8 && (_rate) <= MGN_MCS15)
+#define IS_HT3SS_RATE(_rate) ((_rate) >= MGN_MCS16 && (_rate) <= MGN_MCS23)
+#define IS_HT4SS_RATE(_rate) ((_rate) >= MGN_MCS24 && (_rate) <= MGN_MCS31)
+
+#define IS_VHT1SS_RATE(_rate) ((_rate) >= MGN_VHT1SS_MCS0 && (_rate) <= MGN_VHT1SS_MCS9)
+#define IS_VHT2SS_RATE(_rate) ((_rate) >= MGN_VHT2SS_MCS0 && (_rate) <= MGN_VHT2SS_MCS9)
+#define IS_VHT3SS_RATE(_rate) ((_rate) >= MGN_VHT3SS_MCS0 && (_rate) <= MGN_VHT3SS_MCS9)
+#define IS_VHT4SS_RATE(_rate) ((_rate) >= MGN_VHT4SS_MCS0 && (_rate) <= MGN_VHT4SS_MCS9)
+
+#define IS_1T_RATE(_rate)	(IS_CCK_RATE((_rate)) || IS_OFDM_RATE((_rate)) || IS_HT1SS_RATE((_rate)) || IS_VHT1SS_RATE((_rate)))
+#define IS_2T_RATE(_rate)	(IS_HT2SS_RATE((_rate)) || IS_VHT2SS_RATE((_rate)))
+#define IS_3T_RATE(_rate)	(IS_HT3SS_RATE((_rate)) || IS_VHT3SS_RATE((_rate)))
+#define IS_4T_RATE(_rate)	(IS_HT4SS_RATE((_rate)) || IS_VHT4SS_RATE((_rate)))
+
+#define MGN_RATE_STR(_rate) \
+	(_rate == MGN_1M) ? "CCK_1M" : \
+	(_rate == MGN_2M) ? "CCK_2M" : \
+	(_rate == MGN_5_5M) ? "CCK_5.5M" : \
+	(_rate == MGN_11M) ? "CCK_11M" : \
+	(_rate == MGN_6M) ? "OFDM_6M" : \
+	(_rate == MGN_9M) ? "OFDM_9M" : \
+	(_rate == MGN_12M) ? "OFDM_12M" : \
+	(_rate == MGN_18M) ? "OFDM_18M" : \
+	(_rate == MGN_24M) ? "OFDM_24M" : \
+	(_rate == MGN_36M) ? "OFDM_36M" : \
+	(_rate == MGN_48M) ? "OFDM_48M" : \
+	(_rate == MGN_54M) ? "OFDM_54M" : \
+	(_rate == MGN_MCS32) ? "MCS32" : \
+	(_rate == MGN_MCS0) ? "MCS0" : \
+	(_rate == MGN_MCS1) ? "MCS1" : \
+	(_rate == MGN_MCS2) ? "MCS2" : \
+	(_rate == MGN_MCS3) ? "MCS3" : \
+	(_rate == MGN_MCS4) ? "MCS4" : \
+	(_rate == MGN_MCS5) ? "MCS5" : \
+	(_rate == MGN_MCS6) ? "MCS6" : \
+	(_rate == MGN_MCS7) ? "MCS7" : \
+	(_rate == MGN_MCS8) ? "MCS8" : \
+	(_rate == MGN_MCS9) ? "MCS9" : \
+	(_rate == MGN_MCS10) ? "MCS10" : \
+	(_rate == MGN_MCS11) ? "MCS11" : \
+	(_rate == MGN_MCS12) ? "MCS12" : \
+	(_rate == MGN_MCS13) ? "MCS13" : \
+	(_rate == MGN_MCS14) ? "MCS14" : \
+	(_rate == MGN_MCS15) ? "MCS15" : \
+	(_rate == MGN_MCS16) ? "MCS16" : \
+	(_rate == MGN_MCS17) ? "MCS17" : \
+	(_rate == MGN_MCS18) ? "MCS18" : \
+	(_rate == MGN_MCS19) ? "MCS19" : \
+	(_rate == MGN_MCS20) ? "MCS20" : \
+	(_rate == MGN_MCS21) ? "MCS21" : \
+	(_rate == MGN_MCS22) ? "MCS22" : \
+	(_rate == MGN_MCS23) ? "MCS23" : \
+	(_rate == MGN_MCS24) ? "MCS24" : \
+	(_rate == MGN_MCS25) ? "MCS25" : \
+	(_rate == MGN_MCS26) ? "MCS26" : \
+	(_rate == MGN_MCS27) ? "MCS27" : \
+	(_rate == MGN_MCS28) ? "MCS28" : \
+	(_rate == MGN_MCS29) ? "MCS29" : \
+	(_rate == MGN_MCS30) ? "MCS30" : \
+	(_rate == MGN_MCS31) ? "MCS31" : \
+	(_rate == MGN_VHT1SS_MCS0) ? "VHT1SMCS0" : \
+	(_rate == MGN_VHT1SS_MCS1) ? "VHT1SMCS1" : \
+	(_rate == MGN_VHT1SS_MCS2) ? "VHT1SMCS2" : \
+	(_rate == MGN_VHT1SS_MCS3) ? "VHT1SMCS3" : \
+	(_rate == MGN_VHT1SS_MCS4) ? "VHT1SMCS4" : \
+	(_rate == MGN_VHT1SS_MCS5) ? "VHT1SMCS5" : \
+	(_rate == MGN_VHT1SS_MCS6) ? "VHT1SMCS6" : \
+	(_rate == MGN_VHT1SS_MCS7) ? "VHT1SMCS7" : \
+	(_rate == MGN_VHT1SS_MCS8) ? "VHT1SMCS8" : \
+	(_rate == MGN_VHT1SS_MCS9) ? "VHT1SMCS9" : \
+	(_rate == MGN_VHT2SS_MCS0) ? "VHT2SMCS0" : \
+	(_rate == MGN_VHT2SS_MCS1) ? "VHT2SMCS1" : \
+	(_rate == MGN_VHT2SS_MCS2) ? "VHT2SMCS2" : \
+	(_rate == MGN_VHT2SS_MCS3) ? "VHT2SMCS3" : \
+	(_rate == MGN_VHT2SS_MCS4) ? "VHT2SMCS4" : \
+	(_rate == MGN_VHT2SS_MCS5) ? "VHT2SMCS5" : \
+	(_rate == MGN_VHT2SS_MCS6) ? "VHT2SMCS6" : \
+	(_rate == MGN_VHT2SS_MCS7) ? "VHT2SMCS7" : \
+	(_rate == MGN_VHT2SS_MCS8) ? "VHT2SMCS8" : \
+	(_rate == MGN_VHT2SS_MCS9) ? "VHT2SMCS9" : \
+	(_rate == MGN_VHT3SS_MCS0) ? "VHT3SMCS0" : \
+	(_rate == MGN_VHT3SS_MCS1) ? "VHT3SMCS1" : \
+	(_rate == MGN_VHT3SS_MCS2) ? "VHT3SMCS2" : \
+	(_rate == MGN_VHT3SS_MCS3) ? "VHT3SMCS3" : \
+	(_rate == MGN_VHT3SS_MCS4) ? "VHT3SMCS4" : \
+	(_rate == MGN_VHT3SS_MCS5) ? "VHT3SMCS5" : \
+	(_rate == MGN_VHT3SS_MCS6) ? "VHT3SMCS6" : \
+	(_rate == MGN_VHT3SS_MCS7) ? "VHT3SMCS7" : \
+	(_rate == MGN_VHT3SS_MCS8) ? "VHT3SMCS8" : \
+	(_rate == MGN_VHT3SS_MCS9) ? "VHT3SMCS9" : \
+	(_rate == MGN_VHT4SS_MCS0) ? "VHT4SMCS0" : \
+	(_rate == MGN_VHT4SS_MCS1) ? "VHT4SMCS1" : \
+	(_rate == MGN_VHT4SS_MCS2) ? "VHT4SMCS2" : \
+	(_rate == MGN_VHT4SS_MCS3) ? "VHT4SMCS3" : \
+	(_rate == MGN_VHT4SS_MCS4) ? "VHT4SMCS4" : \
+	(_rate == MGN_VHT4SS_MCS5) ? "VHT4SMCS5" : \
+	(_rate == MGN_VHT4SS_MCS6) ? "VHT4SMCS6" : \
+	(_rate == MGN_VHT4SS_MCS7) ? "VHT4SMCS7" : \
+	(_rate == MGN_VHT4SS_MCS8) ? "VHT4SMCS8" : \
+	(_rate == MGN_VHT4SS_MCS9) ? "VHT4SMCS9" : "UNKNOWN"
+
+typedef enum _RATE_SECTION {
+	CCK = 0,
+	OFDM = 1,
+	HT_MCS0_MCS7 = 2,
+	HT_MCS8_MCS15 = 3,
+	HT_MCS16_MCS23 = 4,
+	HT_MCS24_MCS31 = 5,
+	HT_1SS = HT_MCS0_MCS7,
+	HT_2SS = HT_MCS8_MCS15,
+	HT_3SS = HT_MCS16_MCS23,
+	HT_4SS = HT_MCS24_MCS31,
+	VHT_1SSMCS0_1SSMCS9 = 6,
+	VHT_2SSMCS0_2SSMCS9 = 7,
+	VHT_3SSMCS0_3SSMCS9 = 8,
+	VHT_4SSMCS0_4SSMCS9 = 9,
+	VHT_1SS = VHT_1SSMCS0_1SSMCS9,
+	VHT_2SS = VHT_2SSMCS0_2SSMCS9,
+	VHT_3SS = VHT_3SSMCS0_3SSMCS9,
+	VHT_4SS = VHT_4SSMCS0_4SSMCS9,
+	RATE_SECTION_NUM,
+} RATE_SECTION;
+
+const char *rate_section_str(u8 section);
+
+#define IS_CCK_RATE_SECTION(section) ((section) == CCK)
+#define IS_OFDM_RATE_SECTION(section) ((section) == OFDM)
+#define IS_HT_RATE_SECTION(section) ((section) >= HT_1SS && (section) <= HT_4SS)
+#define IS_VHT_RATE_SECTION(section) ((section) >= VHT_1SS && (section) <= VHT_4SS)
+
+#define IS_1T_RATE_SECTION(section) ((section) == CCK || (section) == OFDM || (section) == HT_1SS || (section) == VHT_1SS)
+#define IS_2T_RATE_SECTION(section) ((section) == HT_2SS || (section) == VHT_2SS)
+#define IS_3T_RATE_SECTION(section) ((section) == HT_3SS || (section) == VHT_3SS)
+#define IS_4T_RATE_SECTION(section) ((section) == HT_4SS || (section) == VHT_4SS)
+
+extern u8 mgn_rates_cck[];
+extern u8 mgn_rates_ofdm[];
+extern u8 mgn_rates_mcs0_7[];
+extern u8 mgn_rates_mcs8_15[];
+extern u8 mgn_rates_mcs16_23[];
+extern u8 mgn_rates_mcs24_31[];
+extern u8 mgn_rates_vht1ss[];
+extern u8 mgn_rates_vht2ss[];
+extern u8 mgn_rates_vht3ss[];
+extern u8 mgn_rates_vht4ss[];
+
+struct rate_section_ent {
+	u8 tx_num; /* value of RF_TX_NUM */
+	u8 rate_num;
+	u8 *rates;
+};
+
+extern struct rate_section_ent rates_by_sections[];
+
+#define rate_section_to_tx_num(section) (rates_by_sections[(section)].tx_num)
+#define rate_section_rate_num(section) (rates_by_sections[(section)].rate_num)
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	/* u32 mac_time[2]; */
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	/* u8 control; */
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   /* jackson */
+	uint tid;	/* jackson */
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats {
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+#ifdef CONFIG_IEEE80211W
+	#define BIP_MAX_KEYID 5
+	#define BIP_AAD_SIZE  20
+#endif /* CONFIG_IEEE80211W */
+
+struct ieee80211_security {
+	u16 active_key:2,
+	    enabled:1,
+	    auth_mode:2,
+	    auth_algo:4,
+	    unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __attribute__((packed));
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__((packed));
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __attribute__((packed));
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	/* struct ieee80211_info_element_hdr info_element; */
+} __attribute__((packed));
+
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __attribute__((packed));
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+	/*struct ieee80211_info_element info_element;*/
+} __attribute__((packed));
+
+struct ieee80211_assoc_request_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	/* u8 current_ap[ETH_ALEN]; */
+	struct ieee80211_info_element_hdr info_element;
+} __attribute__((packed));
+
+struct ieee80211_assoc_response_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+	/*	struct ieee80211_info_element info_element;  supported rates  */
+} __attribute__((packed));
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+/* (HZ / 2) */
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN (256)
+#define MAX_WPS_IE_LEN (512)
+#define MAX_P2P_IE_LEN (256)
+#define MAX_WFD_IE_LEN (128)
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+enum ieee80211_state {
+
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5]
+#define MAC_SFMT "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx"
+#define MAC_SARG(x) ((u8*)(x)),((u8*)(x)) + 1,((u8*)(x)) + 2,((u8*)(x)) + 3,((u8*)(x)) + 4,((u8*)(x)) + 5
+#define IP_FMT "%d.%d.%d.%d"
+#define IP_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3]
+#define PORT_FMT "%u"
+#define PORT_ARG(x) ntohs(*((__be16 *)(x)))
+
+extern __inline int is_multicast_mac_addr(const u8 *addr)
+{
+	return (addr[0] != 0xff) && (0x01 & addr[0]);
+}
+
+extern __inline int is_broadcast_mac_addr(const u8 *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+
+extern __inline int is_zero_mac_addr(const u8 *addr)
+{
+	return ((addr[0] == 0x00) && (addr[1] == 0x00) && (addr[2] == 0x00) &&   \
+		(addr[3] == 0x00) && (addr[4] == 0x00) && (addr[5] == 0x00));
+}
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+typedef struct tx_pending_t {
+	int frag;
+	struct ieee80211_txb *txb;
+} tx_pending_t;
+
+
+
+#define TID_NUM	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A | IEEE_B | IEEE_G)
+
+/* Baron move to ieee80211.c */
+int ieee80211_is_empty_essid(const char *essid, int essid_len);
+int ieee80211_get_hdrlen(u16 fc);
+
+/* Action category code */
+enum rtw_ieee80211_category {
+	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	RTW_WLAN_CATEGORY_QOS = 1,
+	RTW_WLAN_CATEGORY_DLS = 2,
+	RTW_WLAN_CATEGORY_BACK = 3,
+	RTW_WLAN_CATEGORY_PUBLIC = 4, /* IEEE 802.11 public action frames */
+	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	RTW_WLAN_CATEGORY_FT = 6,
+	RTW_WLAN_CATEGORY_HT = 7,
+	RTW_WLAN_CATEGORY_SA_QUERY = 8,
+	RTW_WLAN_CATEGORY_WNM = 10,
+	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	RTW_WLAN_CATEGORY_TDLS = 12,
+	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	RTW_WLAN_CATEGORY_WMM = 17,
+	RTW_WLAN_CATEGORY_VHT = 21,
+	RTW_WLAN_CATEGORY_P2P = 0x7f,/* P2P action frames */
+};
+
+/* SPECTRUM_MGMT action code */
+enum rtw_ieee80211_spectrum_mgmt_actioncode {
+	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
+	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
+	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION {
+	ACT_PUBLIC_BSSCOEXIST = 0, /* 20/40 BSS Coexistence */
+	ACT_PUBLIC_DSE_ENABLE = 1,
+	ACT_PUBLIC_DSE_DEENABLE = 2,
+	ACT_PUBLIC_DSE_REG_LOCATION = 3,
+	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
+	ACT_PUBLIC_DSE_MSR_REQ = 5,
+	ACT_PUBLIC_DSE_MSR_RPRT = 6,
+	ACT_PUBLIC_MP = 7, /* Measurement Pilot */
+	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
+	ACT_PUBLIC_VENDOR = 9, /* for WIFI_DIRECT */
+	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
+	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
+	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
+	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
+	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
+	ACT_PUBLIC_LOCATION_TRACK = 15,
+	ACT_PUBLIC_MAX
+};
+
+#ifdef CONFIG_TDLS
+enum TDLS_ACTION_FIELD {
+	TDLS_SETUP_REQUEST = 0,
+	TDLS_SETUP_RESPONSE = 1,
+	TDLS_SETUP_CONFIRM = 2,
+	TDLS_TEARDOWN = 3,
+	TDLS_PEER_TRAFFIC_INDICATION = 4,
+	TDLS_CHANNEL_SWITCH_REQUEST = 5,
+	TDLS_CHANNEL_SWITCH_RESPONSE = 6,
+	TDLS_PEER_PSM_REQUEST = 7,
+	TDLS_PEER_PSM_RESPONSE = 8,
+	TDLS_PEER_TRAFFIC_RESPONSE = 9,
+	TDLS_DISCOVERY_REQUEST = 10,
+	TDLS_DISCOVERY_RESPONSE = 14,	/* it's used in public action frame */
+};
+
+#define	TUNNELED_PROBE_REQ	15
+#define	TUNNELED_PROBE_RSP	16
+#endif /* CONFIG_TDLS */
+
+/* BACK action code */
+enum rtw_ieee80211_back_actioncode {
+	RTW_WLAN_ACTION_ADDBA_REQ = 0,
+	RTW_WLAN_ACTION_ADDBA_RESP = 1,
+	RTW_WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum rtw_ieee80211_ht_actioncode {
+	RTW_WLAN_ACTION_HT_NOTI_CHNL_WIDTH = 0,
+	RTW_WLAN_ACTION_HT_SM_PS = 1,
+	RTW_WLAN_ACTION_HT_PSMP = 2,
+	RTW_WLAN_ACTION_HT_SET_PCO_PHASE = 3,
+	RTW_WLAN_ACTION_HT_CSI = 4,
+	RTW_WLAN_ACTION_HT_NON_COMPRESS_BEAMFORMING = 5,
+	RTW_WLAN_ACTION_HT_COMPRESS_BEAMFORMING = 6,
+	RTW_WLAN_ACTION_HT_ASEL_FEEDBACK = 7,
+};
+
+/* BACK (block-ack) parties */
+enum rtw_ieee80211_back_parties {
+	RTW_WLAN_BACK_RECIPIENT = 0,
+	RTW_WLAN_BACK_INITIATOR = 1,
+	RTW_WLAN_BACK_TIMER = 2,
+};
+
+/*20/40 BSS Coexistence element */
+#define RTW_WLAN_20_40_BSS_COEX_INFO_REQ            BIT(0)
+#define RTW_WLAN_20_40_BSS_COEX_40MHZ_INTOL         BIT(1)
+#define RTW_WLAN_20_40_BSS_COEX_20MHZ_WIDTH_REQ     BIT(2)
+#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_REQ     BIT(3)
+#define RTW_WLAN_20_40_BSS_COEX_OBSS_EXEMPT_GRNT    BIT(4)
+
+/* VHT features action code */
+enum rtw_ieee80211_vht_actioncode {
+	RTW_WLAN_ACTION_VHT_COMPRESSED_BEAMFORMING = 0,
+	RTW_WLAN_ACTION_VHT_GROUPID_MANAGEMENT = 1,
+	RTW_WLAN_ACTION_VHT_OPMODE_NOTIFICATION = 2,
+};
+
+/*IEEE 802.11r action code*/
+#ifdef CONFIG_RTW_80211R
+enum rtw_ieee80211_ft_actioncode {
+	RTW_WLAN_ACTION_FT_RESV,
+	RTW_WLAN_ACTION_FT_REQUEST,
+	RTW_WLAN_ACTION_FT_RESPONSE,
+	RTW_WLAN_ACTION_FT_CONFIRM,
+	RTW_WLAN_ACTION_FT_ACK,
+	RTW_WLAN_ACTION_FT_MAX,
+};
+#endif
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+	#define WME_OUI_TYPE 2
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WME_VERSION 1
+
+#define WME_ACTION_CODE_SETUP_REQUEST 0
+#define WME_ACTION_CODE_SETUP_RESPONSE 1
+#define WME_ACTION_CODE_TEARDOWN 2
+
+#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
+#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
+#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
+
+#define WME_TSPEC_DIRECTION_UPLINK 0
+#define WME_TSPEC_DIRECTION_DOWNLINK 1
+#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+
+
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+/**
+ * enum rtw_ieee80211_channel_flags - channel flags
+ *
+ * Channel flags set by the regulatory control code.
+ *
+ * @RTW_IEEE80211_CHAN_DISABLED: This channel is disabled.
+ * @RTW_IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
+ *      on this channel.
+ * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
+ * @RTW_IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
+ * @RTW_IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
+ *      is not permitted.
+ * @RTW_IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
+ *      is not permitted.
+ */
+enum rtw_ieee80211_channel_flags {
+	RTW_IEEE80211_CHAN_DISABLED         = 1 << 0,
+	RTW_IEEE80211_CHAN_PASSIVE_SCAN     = 1 << 1,
+	RTW_IEEE80211_CHAN_NO_IBSS          = 1 << 2,
+	RTW_IEEE80211_CHAN_RADAR            = 1 << 3,
+	RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1 << 4,
+	RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1 << 5,
+};
+
+#define RTW_IEEE80211_CHAN_NO_HT40 \
+	(RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)
+
+/* Represent channel details, subset of ieee80211_channel */
+struct rtw_ieee80211_channel {
+	/* enum ieee80211_band band; */
+	/* u16 center_freq; */
+	u16 hw_value;
+	u32 flags;
+	/* int max_antenna_gain; */
+	/* int max_power; */
+	/* int max_reg_power; */
+	/* bool beacon_found; */
+	/* u32 orig_flags; */
+	/* int orig_mag; */
+	/* int orig_mpwr; */
+};
+
+#define CHAN_FMT \
+	/*"band:%d, "*/ \
+	/*"center_freq:%u, "*/ \
+	"hw_value:%u, " \
+	"flags:0x%08x" \
+	/*"max_antenna_gain:%d\n"*/ \
+	/*"max_power:%d\n"*/ \
+	/*"max_reg_power:%d\n"*/ \
+	/*"beacon_found:%u\n"*/ \
+	/*"orig_flags:0x%08x\n"*/ \
+	/*"orig_mag:%d\n"*/ \
+	/*"orig_mpwr:%d\n"*/
+
+#define CHAN_ARG(channel) \
+	/*(channel)->band*/ \
+	/*, (channel)->center_freq*/ \
+	(channel)->hw_value \
+	, (channel)->flags \
+	/*, (channel)->max_antenna_gain*/ \
+	/*, (channel)->max_power*/ \
+	/*, (channel)->max_reg_power*/ \
+	/*, (channel)->beacon_found*/ \
+	/*, (channel)->orig_flags*/ \
+	/*, (channel)->orig_mag*/ \
+	/*, (channel)->orig_mpwr*/ \
+
+/* Parsed Information Elements */
+struct rtw_ieee802_11_elems {
+	u8 *ssid;
+	u8 ssid_len;
+	u8 *supp_rates;
+	u8 supp_rates_len;
+	u8 *fh_params;
+	u8 fh_params_len;
+	u8 *ds_params;
+	u8 ds_params_len;
+	u8 *cf_params;
+	u8 cf_params_len;
+	u8 *tim;
+	u8 tim_len;
+	u8 *ibss_params;
+	u8 ibss_params_len;
+	u8 *challenge;
+	u8 challenge_len;
+	u8 *erp_info;
+	u8 erp_info_len;
+	u8 *ext_supp_rates;
+	u8 ext_supp_rates_len;
+	u8 *wpa_ie;
+	u8 wpa_ie_len;
+	u8 *rsn_ie;
+	u8 rsn_ie_len;
+	u8 *wme;
+	u8 wme_len;
+	u8 *wme_tspec;
+	u8 wme_tspec_len;
+	u8 *wps_ie;
+	u8 wps_ie_len;
+	u8 *power_cap;
+	u8 power_cap_len;
+	u8 *supp_channels;
+	u8 supp_channels_len;
+	u8 *mdie;
+	u8 mdie_len;
+	u8 *ftie;
+	u8 ftie_len;
+	u8 *timeout_int;
+	u8 timeout_int_len;
+	u8 *ht_capabilities;
+	u8 ht_capabilities_len;
+	u8 *ht_operation;
+	u8 ht_operation_len;
+	u8 *vendor_ht_cap;
+	u8 vendor_ht_cap_len;
+	u8 *vht_capabilities;
+	u8 vht_capabilities_len;
+	u8 *vht_operation;
+	u8 vht_operation_len;
+	u8 *vht_op_mode_notify;
+	u8 vht_op_mode_notify_len;
+};
+
+typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
+
+ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors);
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+u8 *rtw_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
+
+enum secondary_ch_offset {
+	SCN = 0, /* no secondary channel */
+	SCA = 1, /* secondary channel above */
+	SCB = 3,  /* secondary channel below */
+};
+u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset);
+u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset);
+u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode, u8 new_ch, u8 ch_switch_cnt);
+u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset);
+u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl, u8 flags, u16 reason, u16 precedence);
+
+u8 *rtw_get_ie(u8 *pbuf, sint index, sint *len, sint limit);
+u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
+int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len);
+
+void rtw_set_supported_rate(u8 *SupportedRates, uint mode) ;
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int rtw_get_wpa_cipher_suite(u8 *s);
+int rtw_get_wpa2_cipher_suite(u8 *s);
+int rtw_get_wapi_ie(u8 *in_ie, uint in_len, u8 *wapi_ie, u16 *wapi_len);
+int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+int rtw_parse_wpa2_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+
+int rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len);
+
+u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
+u8 *rtw_get_wps_ie_from_scan_queue(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen, u8 frame_type);
+u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id , u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id , u8 *buf_content, uint *len_content);
+
+/**
+ * for_each_ie - iterate over continuous IEs
+ * @ie:
+ * @buf:
+ * @buf_len:
+ */
+#define for_each_ie(ie, buf, buf_len) \
+	for (ie = (void *)buf; (((u8 *)ie) - ((u8 *)buf) + 1) < buf_len; ie = (void *)(((u8 *)ie) + *(((u8 *)ie)+1) + 2))
+
+void dump_ies(void *sel, u8 *buf, u32 buf_len);
+
+void dump_ht_cap_ie_content(void *sel, u8 *buf, u32 buf_len);
+
+void dump_wps_ie(void *sel, u8 *ie, u32 ie_len);
+
+void rtw_ies_get_chbw(u8 *ies, int ies_len, u8 *ch, u8 *bw, u8 *offset);
+
+void rtw_bss_get_chbw(WLAN_BSSID_EX *bss, u8 *ch, u8 *bw, u8 *offset);
+
+bool rtw_is_chbw_grouped(u8 ch_a, u8 bw_a, u8 offset_a
+	, u8 ch_b, u8 bw_b, u8 offset_b);
+void rtw_sync_chbw(u8 *req_ch, u8 *req_bw, u8 *req_offset
+	, u8 *g_ch, u8 *g_bw, u8 *g_offset);
+
+u32 rtw_get_p2p_merged_ies_len(u8 *in_ie, u32 in_len);
+int rtw_p2p_merge_ies(u8 *in_ie, u32 in_len, u8 *merge_ie);
+void dump_p2p_ie(void *sel, u8 *ie, u32 ie_len);
+u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
+u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content);
+u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr);
+uint rtw_del_p2p_ie(u8 *ies, uint ies_len_ori, const char *msg);
+uint rtw_del_p2p_attr(u8 *ie, uint ielen_ori, u8 attr_id);
+u8 *rtw_bss_ex_get_p2p_ie(WLAN_BSSID_EX *bss_ex, u8 *p2p_ie, uint *p2p_ielen);
+void rtw_bss_ex_del_p2p_ie(WLAN_BSSID_EX *bss_ex);
+void rtw_bss_ex_del_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
+
+void dump_wfd_ie(void *sel, u8 *ie, u32 ie_len);
+u8 *rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
+u8 *rtw_get_wfd_attr(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content);
+uint rtw_del_wfd_ie(u8 *ies, uint ies_len_ori, const char *msg);
+uint rtw_del_wfd_attr(u8 *ie, uint ielen_ori, u8 attr_id);
+u8 *rtw_bss_ex_get_wfd_ie(WLAN_BSSID_EX *bss_ex, u8 *wfd_ie, uint *wfd_ielen);
+void rtw_bss_ex_del_wfd_ie(WLAN_BSSID_EX *bss_ex);
+void rtw_bss_ex_del_wfd_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id);
+
+uint	rtw_get_rateset_len(u8	*rateset);
+
+struct registry_priv;
+int rtw_generate_ie(struct registry_priv *pregistrypriv);
+
+int rtw_get_bit_value_from_ieee_value(u8 val);
+
+uint	rtw_is_cckrates_included(u8 *rate);
+
+uint	rtw_is_cckratesonly_included(u8 *rate);
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
+
+void rtw_get_bcn_info(struct wlan_network *pnetwork);
+
+u8 rtw_check_invalid_mac_address(u8 *mac_addr, u8 check_local_bit);
+void rtw_macaddr_cfg(u8 *out, const u8 *hw_mac_addr);
+
+u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI, unsigned char *MCS_rate);
+u8	rtw_ht_mcsset_to_nss(u8 *supp_mcs_set);
+u32	rtw_ht_mcs_set_to_bitmap(u8 *mcs_set, u8 nss);
+
+int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8 *category, u8 *action);
+const char *action_public_str(u8 action);
+
+u8 key_2char2num(u8 hch, u8 lch);
+u8 str_2char2num(u8 hch, u8 lch);
+void macstr2num(u8 *dst, u8 *src);
+u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
+int wifirate2_ratetbl_inx(unsigned char rate);
+
+
+#endif /* IEEE80211_H */
diff --git a/drivers/staging/rtl8188eu/include/ieee80211_ext.h b/drivers/staging/rtl8188eu/include/ieee80211_ext.h
new file mode 100644
index 000000000000..f1824578c31d
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/ieee80211_ext.h
@@ -0,0 +1,277 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+
+#define PMKID_LEN 16
+
+
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+} __attribute__((packed));
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+} __attribute__((packed));
+
+struct wme_ac_parameter {
+#if defined(__LITTLE_ENDIAN)
+	/* byte 1 */
+	u8	aifsn:4,
+	     acm:1,
+	     aci:2,
+	     reserved:1;
+
+	/* byte 2 */
+	u8	eCWmin:4,
+	     eCWmax:4;
+#else
+	/* byte 1 */
+	u8	reserved:1,
+	     aci:2,
+	     acm:1,
+	     aifsn:4;
+
+	/* byte 2 */
+	u8	eCWmax:4,
+	     eCWmin:4;
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__((packed));
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
+/* #define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((u8 *) (a), (val)) */
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+	WLAN_ACTION_SM_PS = 1,
+	WLAN_ACTION_PSPM = 2,
+	WLAN_ACTION_PCO_PHASE = 3,
+	WLAN_ACTION_MIMO_CSI_MX = 4,
+	WLAN_ACTION_MIMO_NONCP_BF = 5,
+	WLAN_ACTION_MIMP_CP_BF = 6,
+	WLAN_ACTION_ASEL_INDICATES_FB = 7,
+	WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			__le16 auth_alg;
+			__le16 auth_transaction;
+			__le16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  __attribute__((packed)) auth;
+		struct {
+			__le16 reason_code;
+		}  __attribute__((packed)) deauth;
+		struct {
+			__le16 capab_info;
+			__le16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__((packed)) assoc_req;
+		struct {
+			__le16 capab_info;
+			__le16 status_code;
+			__le16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  __attribute__((packed)) assoc_resp, reassoc_resp;
+		struct {
+			__le16 capab_info;
+			__le16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__((packed)) reassoc_req;
+		struct {
+			__le16 reason_code;
+		}  __attribute__((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			__le16 beacon_int;
+			__le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  __attribute__((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  __attribute__((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			__le16 beacon_int;
+			__le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  __attribute__((packed)) probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  __attribute__((packed)) wme_action;
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					__le16 capab;
+					__le16 timeout;
+					__le16 start_seq_num;
+				}  __attribute__((packed)) addba_req;
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					__le16 status;
+					__le16 capab;
+					__le16 timeout;
+				}  __attribute__((packed)) addba_resp;
+				struct {
+					u8 action_code;
+					__le16 params;
+					__le16 reason_code;
+				}  __attribute__((packed)) delba;
+				struct {
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					___le16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  __attribute__((packed)) plink_action;
+				struct {
+					u8 action_code;
+					u8 variable[0];
+				}  __attribute__((packed)) mesh_action;
+			} __attribute__((packed)) u;
+		}  __attribute__((packed)) action;
+	} __attribute__((packed)) u;
+} __attribute__((packed));
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/if_ether.h b/drivers/staging/rtl8188eu/include/if_ether.h
new file mode 100644
index 000000000000..ace899bc5a13
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/if_ether.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto          */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load           */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console      */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing             */
+#define ETH_P_LAT       0x6004          /* DEC LAT                     */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics             */
+#define ETH_P_CUST      0x6006          /* DEC Customer use            */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch      */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages    */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25 */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only    */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+};
+
+struct _vlan {
+	unsigned short       h_vlan_TCI;                /* Encapsulates priority and VLAN ID */
+	unsigned short       h_vlan_encapsulated_proto;
+};
+
+
+
+#define get_vlan_id(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI))>>13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short)pvlan->h_vlan_encapsulated_proto))
+
+
+#endif	/* _LINUX_IF_ETHER_H */
diff --git a/drivers/staging/rtl8188eu/include/ip.h b/drivers/staging/rtl8188eu/include/ip.h
new file mode 100644
index 000000000000..8d33d4237601
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/ip.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _LINUX_IP_H
+#define _LINUX_IP_H
+
+/* SOL_IP socket options */
+
+#define IPTOS_TOS_MASK		0x1E
+#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_MINCOST		0x02
+
+#define IPTOS_PREC_MASK		0xE0
+#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
+
+#define IPOPT_END	(0 | IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 | IPOPT_CONTROL)
+#define IPOPT_SEC	(2 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_LSRR	(3 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 | IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 | IPOPT_CONTROL)
+#define IPOPT_SID	(8 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_SSRR	(9 | IPOPT_CONTROL | IPOPT_COPY)
+#define IPOPT_RA	(20 | IPOPT_CONTROL | IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+
+   REASONS: it is clear that nobody used them because:
+   - MAX_ROUTES value was wrong.
+   - "struct route" was wrong.
+   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+struct ip_options {
+	__u32		faddr;				/* Saved first hop address */
+	unsigned char	optlen;
+	unsigned char srr;
+	unsigned char rr;
+	unsigned char ts;
+	unsigned char is_setbyuser:1,			/* Set by setsockopt?			*/
+		 is_data:1,			/* Options in __data, rather than skb	*/
+		 is_strictroute:1,		/* Strict source route			*/
+		 srr_is_hit:1,			/* Packet destination addr was our one	*/
+		 is_changed:1,			/* IP checksum more not valid		*/
+		 rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
+		 ts_needtime:1,			/* Need to record timestamp		*/
+		 ts_needaddr:1;			/* Need to record addr of outgoing dev */
+	unsigned char router_alert;
+	unsigned char __pad1;
+	unsigned char __pad2;
+	unsigned char __data[0];
+};
+
+#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl:4,
+		version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version:4,
+		ihl:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+#endif	/* _LINUX_IP_H */
diff --git a/drivers/staging/rtl8188eu/include/linux/wireless.h b/drivers/staging/rtl8188eu/include/linux/wireless.h
new file mode 100644
index 000000000000..de76fe1251ba
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/linux/wireless.h
@@ -0,0 +1,70 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/***************************** INCLUDES *****************************/
+
+#define __user
+/* typedef uint16_t	__u16; */
+#include <sys/socket.h>			/* for "struct sockaddr" et al	*/
+#include <net/if.h>			/* for IFNAMSIZ and co... */
+
+/****************************** TYPES ******************************/
+#ifdef CONFIG_COMPAT
+struct compat_iw_point {
+	compat_caddr_t pointer;
+	__u16 length;
+	__u16 flags;
+};
+#endif
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point {
+	void __user	*pointer;	/* Pointer to the data  (in user space) */
+	__u16		length;		/* number of fields or size in bytes */
+	__u16		flags;		/* Optional params */
+};
+
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data {
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq {
+	union {
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+#endif	/* _LINUX_WIRELESS_H */
diff --git a/drivers/staging/rtl8188eu/include/mlme_osdep.h b/drivers/staging/rtl8188eu/include/mlme_osdep.h
new file mode 100644
index 000000000000..21a90bf8623c
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/mlme_osdep.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+
+#if defined(PLATFORM_MPIXEL)
+	extern int time_after(u32 now, u32 old);
+#endif
+
+extern void rtw_init_mlme_timer(_adapter *padapter);
+extern void rtw_os_indicate_disconnect(_adapter *adapter, u16 reason, u8 locally_generated);
+extern void rtw_os_indicate_connect(_adapter *adapter);
+void rtw_os_indicate_scan_done(_adapter *padapter, bool aborted);
+extern void rtw_report_sec_ie(_adapter *adapter, u8 authmode, u8 *sec_ie);
+
+void rtw_reset_securitypriv(_adapter *adapter);
+
+#endif /* _MLME_OSDEP_H_ */
diff --git a/drivers/staging/rtl8188eu/include/mp_custom_oid.h b/drivers/staging/rtl8188eu/include/mp_custom_oid.h
new file mode 100644
index 000000000000..c21591c64a07
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/mp_custom_oid.h
@@ -0,0 +1,337 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+/* by Owen
+ * 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
+ * 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
+ * 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility */
+
+/*  */
+
+/* by Owen for Production Kit
+ * For Production Kit with Agilent Equipments
+ * in order to make our custom oids hopefully somewhat unique
+ * we will use 0xFF (indicating implementation specific OID)
+ * 81(first byte of non zero Realtek unique identifier)
+ * 80 (second byte of non zero Realtek unique identifier)
+ * XX (the custom OID number - providing 255 possible custom oids) */
+
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST			0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+/* added by Owen on 04/08/03 for Cameo's request */
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+/*  */
+
+/* Sean		 */
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+
+/* ************************************************************************ */
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+/* ************************************************************************ */
+
+
+/* by Owen for RTL8185 Phy Status Report Utility */
+#define OID_RT_UTILITYfalse_ALARM_COUNTERS				0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS					0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
+/*  */
+
+/* by Owen on 03/09/19-03/09/22 for RTL8185 */
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+/*  */
+
+#define OID_RT_GET_CONNECT_STATE	0xFF030001
+#define OID_RT_RESCAN		0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE	0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY	0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A/* S */
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B/* S */
+
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+
+/* by Owen on 03/31/03 for Cameo's request */
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+/*  */
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+
+/* For Netgear request. 2005.01.13, by rcnjko. */
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+/* For Netgear request. 2005.02.17, by rcnjko. */
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+/* For AZ project. 2005.06.27, by rcnjko. */
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+
+/* Vincent 8185MP */
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+
+/* Andy TEST
+ * #define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1
+ * #define OID_RT_PRO_READ_REGISTRY			0xFF0111C2 */
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+
+
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+
+/* AP OID */
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304	/* Determine if driver supports AP mode. 2004.08.27, by rcnjko. */
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	/* Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko. */
+
+/* 8187MP. 2004.09.06, by rcnjko. */
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+
+/* Meeting House. added by Annie, 2005-07-20. */
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+
+/* 8711 MP OID added 20051230. */
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100/* S */
+
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 /* Q */
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 /* S */
+
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 /* Q		 */
+#define OID_RT_PRO_BURST_WRITE_REGISTER 		0xFF871104 /* S */
+
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 /* S */
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 /* Q */
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 /* S */
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 /* S */
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 /* Q */
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A /* Q */
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B /* Q */
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C/* Q */
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D/* S */
+
+
+/* Method 2 for H2C/C2H */
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 /* S */
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 /* Q */
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 /* S */
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 /* Q */
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114/* Q */
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 /* Q, S */
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 /* S */
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 /* Q, S */
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 /* Q */
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 /* Q */
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A /* S */
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B /* Q */
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C /* S */
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D /* Q */
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E /* S */
+#define OID_RT_POLL_RX_STATUS				0xFF87111F /* Q */
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 /* Q, S */
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121/* S */
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122/* S */
+#define OID_RT_PRO_READ_TSSI				0xFF871123/* S */
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124/* S */
+
+
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 /* Q */
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 /* S */
+
+/* Method 2 , using workitem */
+#define OID_RT_SET_READ_REG				0xFF871181 /* S */
+#define OID_RT_SET_WRITE_REG				0xFF871182 /* S */
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 /* S */
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 /* S */
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 /* S */
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 /* S */
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 /* S */
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 /* Q */
+
+/* For SDIO INTERFACE only */
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 /* Q, S */
+#define OID_RT_PRO_871X_DRV_EXT			0xFF8711A1
+
+/* For USB INTERFACE only */
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 /* Q, S */
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 /* S */
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 /* S */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 /* Q */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 /* Q */
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB /* S */
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC /* S */
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 /* Q, S */
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 /* S */
+#define OID_RT_PRO_DELE_STA_INFO    			0xFF871202 /* S */
+#define OID_RT_PRO_QUERY_DR_VARIABLE   			0xFF871203 /* Q */
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 /* Q, S */
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 /* Q */
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 /* S */
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 /* Q, S */
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 /* Q */
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209 /* S */
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A /* S */
+
+#define OID_RT_SET_RX_PACKET_TYPE    			0xFF87120B /* S */
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C /* Q */
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D /* S */
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E /* S */
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F /* S */
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 /* Q */
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 /* S */
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 /* Q */
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 /* Q */
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214 /* S */
+
+#define OID_RT_GET_POWER_MODE				0xFF871215 /* Q */
+
+#define OID_RT_PRO_EFUSE				0xFF871216 /* Q, S */
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 /* Q, S */
+
+#endif /* #ifndef	__CUSTOM_OID_H */
diff --git a/drivers/staging/rtl8188eu/include/nic_spec.h b/drivers/staging/rtl8188eu/include/nic_spec.h
new file mode 100644
index 000000000000..e535e428ae9c
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/nic_spec.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif /* __RTL8711_SPEC_H__ */
diff --git a/drivers/staging/rtl8188eu/include/osdep_intf.h b/drivers/staging/rtl8188eu/include/osdep_intf.h
new file mode 100644
index 000000000000..3d09e234fb58
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/osdep_intf.h
@@ -0,0 +1,121 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+
+struct intf_priv {
+
+	u8 *intf_dev;
+	u32	max_iosz;	/* USB2.0: 128, USB1.1: 64, SDIO:64 */
+	u32	max_xmitsz; /* USB2.0: unlimited, SDIO:512 */
+	u32	max_recvsz; /* USB2.0: unlimited, SDIO:512 */
+
+	volatile u8 *io_rwmem;
+	volatile u8 *allocated_io_rwmem;
+	u32	io_wsz; /* unit: 4bytes */
+	u32	io_rsz;/* unit: 4bytes */
+	u8 intf_status;
+
+	void (*_bus_io)(u8 *priv);
+
+	/*
+	Under Sync. IRP (SDIO/USB)
+	A protection mechanism is necessary for the io_rwmem(read/write protocol)
+
+	Under Async. IRP (SDIO/USB)
+	The protection mechanism is through the pending queue.
+	*/
+
+	_mutex ioctl_mutex;
+
+
+	/* when in USB, IO is through interrupt in/out endpoints */
+	struct usb_device	*udev;
+	PURB	piorw_urb;
+	u8 io_irp_cnt;
+	u8 bio_irp_pending;
+	_sema io_retevt;
+	struct timer_list io_timer;
+	u8 bio_irp_timeout;
+	u8 bio_timer_cancel;
+};
+
+#ifdef CONFIG_R871X_TEST
+	int rtw_start_pseudo_adhoc(_adapter *padapter);
+	int rtw_stop_pseudo_adhoc(_adapter *padapter);
+#endif
+
+struct dvobj_priv *devobj_init(void);
+void devobj_deinit(struct dvobj_priv *pdvobj);
+
+u8 rtw_init_drv_sw(_adapter *padapter);
+u8 rtw_free_drv_sw(_adapter *padapter);
+u8 rtw_reset_drv_sw(_adapter *padapter);
+void rtw_dev_unload(PADAPTER padapter);
+
+u32 rtw_start_drv_threads(_adapter *padapter);
+void rtw_stop_drv_threads(_adapter *padapter);
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+void rtw_cancel_dynamic_chk_timer(_adapter *padapter);
+#endif
+void rtw_cancel_all_timer(_adapter *padapter);
+
+uint loadparam(_adapter *adapter);
+
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname);
+struct net_device *rtw_init_netdev(_adapter *padapter);
+
+void rtw_os_ndev_free(_adapter *adapter);
+int rtw_os_ndev_init(_adapter *adapter, const char *name);
+void rtw_os_ndev_deinit(_adapter *adapter);
+void rtw_os_ndev_unregister(_adapter *adapter);
+void rtw_os_ndevs_unregister(struct dvobj_priv *dvobj);
+int rtw_os_ndevs_init(struct dvobj_priv *dvobj);
+void rtw_os_ndevs_deinit(struct dvobj_priv *dvobj);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+u16 rtw_recv_select_queue(struct sk_buff *skb);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35) */
+
+int rtw_ndev_notifier_register(void);
+void rtw_ndev_notifier_unregister(void);
+
+#include "../os_dep/rtw_proc.h"
+
+#ifdef CONFIG_IOCTL_CFG80211
+	#include "../os_dep/ioctl_cfg80211.h"
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+u8 rtw_rtnl_lock_needed(struct dvobj_priv *dvobj);
+void rtw_set_rtnl_lock_holder(struct dvobj_priv *dvobj, _thread_hdl_ thd_hdl);
+
+void rtw_ips_dev_unload(_adapter *padapter);
+
+#ifdef CONFIG_IPS
+int rtw_ips_pwr_up(_adapter *padapter);
+void rtw_ips_pwr_down(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+struct _io_ops;
+struct dvobj_priv;
+_adapter *rtw_drv_add_vir_if(_adapter *primary_padapter, void (*set_intf_ops)(_adapter *primary_padapter, struct _io_ops *pops));
+void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
+void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
+#endif
+
+void rtw_ndev_destructor(_nic_hdl ndev);
+
+#ifdef CONFIG_ARP_KEEP_ALIVE
+int	rtw_gw_addr_query(_adapter *padapter);
+#endif
+
+int rtw_suspend_common(_adapter *padapter);
+int rtw_resume_common(_adapter *padapter);
+
+#endif /* _OSDEP_INTF_H_ */
diff --git a/drivers/staging/rtl8188eu/include/osdep_service.h b/drivers/staging/rtl8188eu/include/osdep_service.h
new file mode 100644
index 000000000000..b972ff4fdf24
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/osdep_service.h
@@ -0,0 +1,567 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+
+#define _FAIL					0
+#define _SUCCESS				1
+#define RTW_RX_HANDLED			2
+#define RTW_RFRAME_UNAVAIL		3
+#define RTW_RFRAME_PKT_UNAVAIL	4
+#define RTW_RBUF_UNAVAIL		5
+#define RTW_RBUF_PKT_UNAVAIL	6
+
+#include <osdep_service_linux.h>
+
+#define RTW_TIMER_HDL_NAME(name) rtw_##name##_timer_hdl
+#define RTW_DECLARE_TIMER_HDL(name) void RTW_TIMER_HDL_NAME(name)(RTW_TIMER_HDL_ARGS)
+
+/* #include <rtw_byteorder.h> */
+
+#ifndef BIT
+	#define BIT(x)	(1 << (x))
+#endif
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+#define BIT4	0x00000010
+#define BIT5	0x00000020
+#define BIT6	0x00000040
+#define BIT7	0x00000080
+#define BIT8	0x00000100
+#define BIT9	0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+#define BIT32	0x0100000000
+#define BIT33	0x0200000000
+#define BIT34	0x0400000000
+#define BIT35	0x0800000000
+#define BIT36	0x1000000000
+
+extern int RTW_STATUS_CODE(int error_code);
+
+#ifndef RTK_DMP_PLATFORM
+	#define CONFIG_USE_VMALLOC
+#endif
+
+/* flags used for rtw_mstat_update() */
+enum mstat_f {
+	/* type: 0x00ff */
+	MSTAT_TYPE_VIR = 0x00,
+	MSTAT_TYPE_PHY = 0x01,
+	MSTAT_TYPE_SKB = 0x02,
+	MSTAT_TYPE_USB = 0x03,
+	MSTAT_TYPE_MAX = 0x04,
+
+	/* func: 0xff00 */
+	MSTAT_FUNC_UNSPECIFIED = 0x00 << 8,
+	MSTAT_FUNC_IO = 0x01 << 8,
+	MSTAT_FUNC_TX_IO = 0x02 << 8,
+	MSTAT_FUNC_RX_IO = 0x03 << 8,
+	MSTAT_FUNC_TX = 0x04 << 8,
+	MSTAT_FUNC_RX = 0x05 << 8,
+	MSTAT_FUNC_CFG_VENDOR = 0x06 << 8,
+	MSTAT_FUNC_MAX = 0x07 << 8,
+};
+
+#define mstat_tf_idx(flags) ((flags) & 0xff)
+#define mstat_ff_idx(flags) (((flags) & 0xff00) >> 8)
+
+typedef enum mstat_status {
+	MSTAT_ALLOC_SUCCESS = 0,
+	MSTAT_ALLOC_FAIL,
+	MSTAT_FREE
+} MSTAT_STATUS;
+
+#ifdef DBG_MEM_ALLOC
+void rtw_mstat_update(const enum mstat_f flags, const MSTAT_STATUS status, u32 sz);
+void rtw_mstat_dump(void *sel);
+u8 *dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+u8 *dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_vmfree(u8 *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
+u8 *dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+u8 *dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_mfree(u8 *pbuf, const enum mstat_f flags, u32 sz, const char *func, const int line);
+
+struct sk_buff *dbg_rtw_skb_alloc(unsigned int size, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+struct sk_buff *dbg_rtw_skb_clone(struct sk_buff *skb, const enum mstat_f flags, const char *func, const int line);
+int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
+#ifdef CONFIG_RTW_NAPI
+int dbg_rtw_netif_receive_skb(_nic_hdl ndev, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
+#ifdef CONFIG_RTW_GRO
+gro_result_t dbg_rtw_napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb, const enum mstat_f flags, const char *func, int line);
+#endif
+#endif /* CONFIG_RTW_NAPI */
+void dbg_rtw_skb_queue_purge(struct sk_buff_head *list, enum mstat_f flags, const char *func, int line);
+void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma, const enum mstat_f flags, const char *func, const int line);
+void dbg_rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma, const enum mstat_f flags, const char *func, const int line);
+
+#ifdef CONFIG_USE_VMALLOC
+#define rtw_vmalloc(sz)			dbg_rtw_vmalloc((sz), MSTAT_TYPE_VIR, __func__, __LINE__)
+#define rtw_zvmalloc(sz)			dbg_rtw_zvmalloc((sz), MSTAT_TYPE_VIR, __func__, __LINE__)
+#define rtw_vmfree(pbuf, sz)		dbg_rtw_vmfree((pbuf), (sz), MSTAT_TYPE_VIR, __func__, __LINE__)
+#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_vmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __func__, __LINE__)
+#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zvmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __func__, __LINE__)
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_vmfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_VIR, __func__, __LINE__)
+#else /* CONFIG_USE_VMALLOC */
+#define rtw_vmalloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_zvmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_vmfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_vmalloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_zvmalloc_f(sz, mstat_f)		dbg_rtw_zmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	dbg_rtw_mfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+#endif /* CONFIG_USE_VMALLOC */
+#define rtw_malloc(sz)			dbg_rtw_malloc((sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_zmalloc(sz)			dbg_rtw_zmalloc((sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_mfree(pbuf, sz)		dbg_rtw_mfree((pbuf), (sz), MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_malloc_f(sz, mstat_f)			dbg_rtw_malloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_zmalloc_f(sz, mstat_f)			dbg_rtw_zmalloc((sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+#define rtw_mfree_f(pbuf, sz, mstat_f)		dbg_rtw_mfree((pbuf), (sz), ((mstat_f) & 0xff00) | MSTAT_TYPE_PHY, __func__, __LINE__)
+
+#define rtw_skb_alloc(size)	dbg_rtw_skb_alloc((size), MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_free(skb)	dbg_rtw_skb_free((skb), MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_alloc_f(size, mstat_f)	dbg_rtw_skb_alloc((size), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_free_f(skb, mstat_f)	dbg_rtw_skb_free((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_copy(skb)	dbg_rtw_skb_copy((skb), MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_clone(skb)	dbg_rtw_skb_clone((skb), MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_copy_f(skb, mstat_f)	dbg_rtw_skb_copy((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_skb_clone_f(skb, mstat_f)	dbg_rtw_skb_clone((skb), ((mstat_f) & 0xff00) | MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_netif_rx(ndev, skb)	dbg_rtw_netif_rx(ndev, skb, MSTAT_TYPE_SKB, __func__, __LINE__)
+#ifdef CONFIG_RTW_NAPI
+#define rtw_netif_receive_skb(ndev, skb) dbg_rtw_netif_receive_skb(ndev, skb, MSTAT_TYPE_SKB, __func__, __LINE__)
+#ifdef CONFIG_RTW_GRO
+#define rtw_napi_gro_receive(napi, skb) dbg_rtw_napi_gro_receive(napi, skb, MSTAT_TYPE_SKB, __func__, __LINE__)
+#endif
+#endif /* CONFIG_RTW_NAPI */
+#define rtw_skb_queue_purge(sk_buff_head) dbg_rtw_skb_queue_purge(sk_buff_head, MSTAT_TYPE_SKB, __func__, __LINE__)
+#define rtw_usb_buffer_alloc(dev, size, dma)		dbg_rtw_usb_buffer_alloc((dev), (size), (dma), MSTAT_TYPE_USB, __func__, __LINE__)
+#define rtw_usb_buffer_free(dev, size, addr, dma)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), MSTAT_TYPE_USB, __func__, __LINE__)
+#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f)			dbg_rtw_usb_buffer_alloc((dev), (size), (dma), ((mstat_f) & 0xff00) | MSTAT_TYPE_USB, __func__, __LINE__)
+#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f)	dbg_rtw_usb_buffer_free((dev), (size), (addr), (dma), ((mstat_f) & 0xff00) | MSTAT_TYPE_USB, __func__, __LINE__)
+
+#else /* DBG_MEM_ALLOC */
+#define rtw_mstat_update(flag, status, sz) do {} while (0)
+#define rtw_mstat_dump(sel) do {} while (0)
+u8 *_rtw_zvmalloc(u32 sz);
+void	_rtw_vmfree(u8 *pbuf, u32 sz);
+u8 *_rtw_zmalloc(u32 sz);
+u8 *_rtw_malloc(u32 sz);
+void	_rtw_mfree(u8 *pbuf, u32 sz);
+
+struct sk_buff *_rtw_skb_alloc(u32 sz);
+void _rtw_skb_free(struct sk_buff *skb);
+struct sk_buff *_rtw_skb_copy(const struct sk_buff *skb);
+struct sk_buff *_rtw_skb_clone(struct sk_buff *skb);
+int _rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb);
+#ifdef CONFIG_RTW_NAPI
+int _rtw_netif_receive_skb(_nic_hdl ndev, struct sk_buff *skb);
+#ifdef CONFIG_RTW_GRO
+gro_result_t _rtw_napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb);
+#endif
+#endif /* CONFIG_RTW_NAPI */
+void _rtw_skb_queue_purge(struct sk_buff_head *list);
+
+void *_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr_t *dma);
+void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr, dma_addr_t dma);
+
+#ifdef CONFIG_USE_VMALLOC
+#define rtw_zvmalloc(sz)			_rtw_zvmalloc((sz))
+#define rtw_vmfree(pbuf, sz)		_rtw_vmfree((pbuf), (sz))
+#define rtw_vmalloc_f(sz, mstat_f)			_rtw_vmalloc((sz))
+#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zvmalloc((sz))
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_vmfree((pbuf), (sz))
+#else /* CONFIG_USE_VMALLOC */
+#define rtw_zvmalloc(sz)			_rtw_zmalloc((sz))
+#define rtw_vmfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
+#define rtw_vmalloc_f(sz, mstat_f)			_rtw_malloc((sz))
+#define rtw_zvmalloc_f(sz, mstat_f)		_rtw_zmalloc((sz))
+#define rtw_vmfree_f(pbuf, sz, mstat_f)	_rtw_mfree((pbuf), (sz))
+#endif /* CONFIG_USE_VMALLOC */
+#define rtw_malloc(sz)			_rtw_malloc((sz))
+#define rtw_zmalloc(sz)			_rtw_zmalloc((sz))
+#define rtw_mfree(pbuf, sz)		_rtw_mfree((pbuf), (sz))
+#define rtw_malloc_f(sz, mstat_f)			_rtw_malloc((sz))
+#define rtw_zmalloc_f(sz, mstat_f)			_rtw_zmalloc((sz))
+#define rtw_mfree_f(pbuf, sz, mstat_f)		_rtw_mfree((pbuf), (sz))
+
+#define rtw_skb_alloc(size) _rtw_skb_alloc((size))
+#define rtw_skb_free(skb) _rtw_skb_free((skb))
+#define rtw_skb_alloc_f(size, mstat_f)	_rtw_skb_alloc((size))
+#define rtw_skb_free_f(skb, mstat_f)	_rtw_skb_free((skb))
+#define rtw_skb_copy(skb)	_rtw_skb_copy((skb))
+#define rtw_skb_clone(skb)	_rtw_skb_clone((skb))
+#define rtw_skb_copy_f(skb, mstat_f)	_rtw_skb_copy((skb))
+#define rtw_skb_clone_f(skb, mstat_f)	_rtw_skb_clone((skb))
+#define rtw_netif_rx(ndev, skb) _rtw_netif_rx(ndev, skb)
+#ifdef CONFIG_RTW_NAPI
+#define rtw_netif_receive_skb(ndev, skb) _rtw_netif_receive_skb(ndev, skb)
+#ifdef CONFIG_RTW_GRO
+#define rtw_napi_gro_receive(napi, skb) _rtw_napi_gro_receive(napi, skb)
+#endif
+#endif /* CONFIG_RTW_NAPI */
+#define rtw_skb_queue_purge(sk_buff_head) _rtw_skb_queue_purge(sk_buff_head)
+#define rtw_usb_buffer_alloc(dev, size, dma) _rtw_usb_buffer_alloc((dev), (size), (dma))
+#define rtw_usb_buffer_free(dev, size, addr, dma) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
+#define rtw_usb_buffer_alloc_f(dev, size, dma, mstat_f) _rtw_usb_buffer_alloc((dev), (size), (dma))
+#define rtw_usb_buffer_free_f(dev, size, addr, dma, mstat_f) _rtw_usb_buffer_free((dev), (size), (addr), (dma))
+#endif /* DBG_MEM_ALLOC */
+
+extern void	*rtw_malloc2d(int h, int w, size_t size);
+extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);
+
+extern void	list_del_init(_list *plist);
+
+extern u32	_rtw_down_sema(_sema *sema);
+extern void	_rtw_mutex_init(_mutex *pmutex);
+extern void	_rtw_mutex_free(_mutex *pmutex);
+
+extern void	_rtw_init_queue(_queue *pqueue);
+extern u32	_rtw_queue_empty(_queue	*pqueue);
+extern u32	rtw_end_of_queue_search(_list *queue, _list *pelement);
+
+extern u32	rtw_systime_to_ms(u32 systime);
+extern u32	rtw_ms_to_systime(u32 ms);
+extern s32	rtw_get_passing_time_ms(u32 start);
+extern s32	rtw_get_time_interval_ms(u32 start, u32 end);
+
+extern void	rtw_sleep_schedulable(int ms);
+
+extern void	rtw_msleep_os(int ms);
+extern void	rtw_usleep_os(int us);
+
+extern u32	rtw_atoi(u8 *s);
+
+#ifdef DBG_DELAY_OS
+#define rtw_mdelay_os(ms) _rtw_mdelay_os((ms), __func__, __LINE__)
+#define rtw_udelay_os(ms) _rtw_udelay_os((ms), __func__, __LINE__)
+extern void _rtw_mdelay_os(int ms, const char *func, const int line);
+extern void _rtw_udelay_os(int us, const char *func, const int line);
+#else
+extern void	rtw_mdelay_os(int ms);
+extern void	rtw_udelay_os(int us);
+#endif
+
+extern void rtw_yield_os(void);
+
+
+extern void rtw_init_timer(struct timer_list *ptimer, void *padapter, void *pfunc);
+
+
+__inline static unsigned char _cancel_timer_ex(struct timer_list *ptimer)
+{
+	return del_timer_sync(ptimer);
+}
+
+static __inline void thread_enter(char *name)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
+	daemonize("%s", name);
+#endif
+	allow_signal(SIGTERM);
+}
+
+__inline static void flush_signals_thread(void)
+{
+	if (signal_pending(current))
+		flush_signals(current);
+}
+
+__inline static _OS_STATUS res_to_status(sint res)
+{
+	return res;
+}
+
+__inline static void rtw_dump_stack(void)
+{
+	dump_stack();
+}
+
+#define rtw_warn_on(condition) WARN_ON(condition)
+
+__inline static int rtw_bug_check(void *parg1, void *parg2, void *parg3, void *parg4)
+{
+	int ret = true;
+
+	return ret;
+}
+
+#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ? 0 : 1)) << 2)
+
+__inline static u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;
+
+	return val;
+
+}
+
+__inline static u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;
+
+	return val;
+
+}
+
+__inline static u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;
+
+	return val;
+
+}
+
+__inline static u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;
+
+	return val;
+
+}
+
+__inline static u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;
+
+	return val;
+
+}
+
+__inline static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask >> i) &  0x1) == 1)
+			break;
+
+	return i;
+}
+
+static inline int largest_bit(u32 bitmask)
+{
+	int i;
+
+	for (i = 31; i >= 0; i--)
+		if (bitmask & BIT(i))
+			break;
+
+	return i;
+}
+
+#define rtw_min(a, b) ((a > b) ? b : a)
+#define rtw_is_range_a_in_b(hi_a, lo_a, hi_b, lo_b) (((hi_a) <= (hi_b)) && ((lo_a) >= (lo_b)))
+#define rtw_is_range_overlap(hi_a, lo_a, hi_b, lo_b) (((hi_a) > (lo_b)) && ((lo_a) < (hi_b)))
+
+#ifndef MAC_FMT
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+#ifndef MAC_ARG
+#define MAC_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5]
+#endif
+
+
+extern void rtw_suspend_lock_init(void);
+extern void rtw_suspend_lock_uninit(void);
+extern void rtw_lock_suspend(void);
+extern void rtw_unlock_suspend(void);
+extern void rtw_lock_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_ext_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_rx_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_traffic_suspend_timeout(u32 timeout_ms);
+extern void rtw_lock_resume_scan_timeout(u32 timeout_ms);
+extern void rtw_resume_lock_suspend(void);
+extern void rtw_resume_unlock_suspend(void);
+#ifdef CONFIG_AP_WOWLAN
+extern void rtw_softap_lock_suspend(void);
+extern void rtw_softap_unlock_suspend(void);
+#endif
+
+extern void ATOMIC_SET(ATOMIC_T *v, int i);
+extern int ATOMIC_READ(ATOMIC_T *v);
+extern void ATOMIC_ADD(ATOMIC_T *v, int i);
+extern void ATOMIC_SUB(ATOMIC_T *v, int i);
+extern void ATOMIC_INC(ATOMIC_T *v);
+extern void ATOMIC_DEC(ATOMIC_T *v);
+extern int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
+extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
+
+/* File operation APIs, just for linux now */
+extern int rtw_is_file_readable(const char *path);
+extern int rtw_is_file_readable_with_size(const char *path, u32 *sz);
+extern int rtw_retrieve_from_file(const char *path, u8 *buf, u32 sz);
+extern int rtw_store_to_file(const char *path, u8 *buf, u32 sz);
+
+extern void rtw_free_netdev(struct net_device *netdev);
+
+extern u64 rtw_modular64(u64 x, u64 y);
+extern u64 rtw_division64(u64 x, u64 y);
+extern u32 rtw_random32(void);
+
+/* Macros for handling unaligned memory accesses */
+
+#define RTW_GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
+#define RTW_PUT_BE16(a, val)			\
+	do {					\
+		(a)[0] = ((u16) (val)) >> 8;	\
+		(a)[1] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_LE16(a) ((u16) (((a)[1] << 8) | (a)[0]))
+#define RTW_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
+			 ((u32) (a)[2]))
+#define RTW_PUT_BE24(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[2] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+#define RTW_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
+			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
+#define RTW_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
+			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
+			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
+			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
+#define RTW_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+#define RTW_GET_LE64(a) ((((u64) (a)[7]) << 56) | (((u64) (a)[6]) << 48) | \
+			 (((u64) (a)[5]) << 40) | (((u64) (a)[4]) << 32) | \
+			 (((u64) (a)[3]) << 24) | (((u64) (a)[2]) << 16) | \
+			 (((u64) (a)[1]) << 8) | ((u64) (a)[0]))
+
+void rtw_buf_free(u8 **buf, u32 *buf_len);
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len);
+
+struct rtw_cbuf {
+	u32 write;
+	u32 read;
+	u32 size;
+	void *bufs[0];
+};
+
+bool rtw_cbuf_full(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_empty(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf);
+void *rtw_cbuf_pop(struct rtw_cbuf *cbuf);
+struct rtw_cbuf *rtw_cbuf_alloc(u32 size);
+void rtw_cbuf_free(struct rtw_cbuf *cbuf);
+
+struct map_seg_t {
+	u16 sa;
+	u16 len;
+	u8 *c;
+};
+
+struct map_t {
+	u16 len;
+	u16 seg_num;
+	u8 init_value;
+	struct map_seg_t *segs;
+};
+
+#define MAPSEG_ARRAY_ENT(_sa, _len, _c, arg...) \
+	{ .sa = _sa, .len = _len, .c = (u8[_len]){ _c, ##arg}, }
+
+#define MAPSEG_PTR_ENT(_sa, _len, _p) \
+	{ .sa = _sa, .len = _len, .c = _p, }
+
+#define MAP_ENT(_len, _seg_num, _init_v, _seg, arg...) \
+	{ .len = _len, .seg_num = _seg_num, .init_value = _init_v, .segs = (struct map_seg_t[_seg_num]){ _seg, ##arg}, }
+
+int map_readN(const struct map_t *map, u16 offset, u16 len, u8 *buf);
+u8 map_read8(const struct map_t *map, u16 offset);
+
+/* String handler */
+
+bool is_null(char c);
+bool is_eol(char c);
+bool is_space(char c);
+bool IsHexDigit(char chTmp);
+bool is_alpha(char chTmp);
+char alpha_to_upper(char c);
+
+/*
+ * Write formatted output to sized buffer
+ */
+#define rtw_sprintf(buf, size, format, arg...)	snprintf(buf, size, format, ##arg)
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/osdep_service_linux.h b/drivers/staging/rtl8188eu/include/osdep_service_linux.h
new file mode 100644
index 000000000000..7826e7975bd7
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/osdep_service_linux.h
@@ -0,0 +1,442 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __OSDEP_LINUX_SERVICE_H_
+#define __OSDEP_LINUX_SERVICE_H_
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#include <linux/compiler.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 5))
+	#include <linux/kref.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
+/* #include <linux/smp_lock.h> */
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/circ_buf.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+	#include <asm/semaphore.h>
+#else
+	#include <linux/semaphore.h>
+#endif
+#include <linux/sem.h>
+#include <linux/sched.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>	/* for struct tasklet_struct */
+#include <linux/ip.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 5, 41))
+	#include <linux/tqueue.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
+	#include <uapi/linux/limits.h>
+#else
+	#include <linux/limits.h>
+#endif
+
+#ifdef RTK_DMP_PLATFORM
+	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 12))
+		#include <linux/pageremap.h>
+	#endif
+	#include <asm/io.h>
+#endif
+
+#ifdef CONFIG_NET_RADIO
+	#define CONFIG_WIRELESS_EXT
+#endif
+
+/* Monitor mode */
+#include <net/ieee80211_radiotap.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
+	#include <linux/ieee80211.h>
+#endif
+
+#ifdef CONFIG_IOCTL_CFG80211
+	/*	#include <linux/ieee80211.h> */
+	#include <net/cfg80211.h>
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	#include <linux/in.h>
+	#include <linux/udp.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	#include <linux/earlysuspend.h>
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+	#include <linux/fs.h>
+#endif
+
+	#include <linux/usb.h>
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 21))
+		#include <linux/usb_ch9.h>
+	#else
+		#include <linux/usb/ch9.h>
+	#endif
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+	#include <net/sock.h>
+	#include <net/tcp.h>
+	#include <linux/udp.h>
+	#include <linux/in.h>
+	#include <linux/netlink.h>
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+
+	typedef struct urb   *PURB;
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22))
+		#ifdef CONFIG_USB_SUSPEND
+			#define CONFIG_AUTOSUSPEND	1
+		#endif
+	#endif
+
+#if defined(CONFIG_RTW_GRO) && (!defined(CONFIG_RTW_NAPI))
+
+	#error "Enable NAPI before enable GRO\n"
+
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) && defined(CONFIG_RTW_NAPI))
+
+	#error "Linux Kernel version too old (should newer than 2.6.29)\n"
+
+#endif
+
+
+typedef struct	semaphore _sema;
+#ifdef CONFIG_PREEMPT_RT
+typedef	raw_spinlock_t	_lock;
+#else
+typedef	spinlock_t	_lock;
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+	typedef struct mutex		_mutex;
+#else
+	typedef struct semaphore	_mutex;
+#endif
+
+struct	__queue	{
+	struct	list_head	queue;
+	_lock	lock;
+};
+
+typedef	struct sk_buff	_pkt;
+typedef unsigned char	_buffer;
+
+typedef struct	__queue	_queue;
+typedef struct	list_head	_list;
+typedef	int	_OS_STATUS;
+typedef	struct	net_device *_nic_hdl;
+
+typedef void		*_thread_hdl_;
+typedef int		thread_return;
+typedef void	*thread_context;
+
+#define thread_exit() complete_and_exit(NULL, 0)
+
+typedef void timer_hdl_return;
+typedef void *timer_hdl_context;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+	typedef struct work_struct _workitem;
+#else
+	typedef struct tq_struct _workitem;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22))
+/* Porting from linux kernel, for compatible with old kernel. */
+static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
+{
+	return skb->tail;
+}
+
+static inline void skb_reset_tail_pointer(struct sk_buff *skb)
+{
+	skb->tail = skb->data;
+}
+
+static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
+{
+	skb->tail = skb->data + offset;
+}
+
+static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
+{
+	return skb->end;
+}
+#endif
+
+__inline static _list *get_next(_list	*list)
+{
+	return list->next;
+}
+
+__inline static _list	*get_list_head(_queue	*queue)
+{
+	return &(queue->queue);
+}
+
+
+#define LIST_CONTAINOR(ptr, type, member) \
+	((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+
+
+#ifdef CONFIG_PREEMPT_RT
+__inline static void _enter_critical(_lock *plock, unsigned long *pirqL)
+{
+	raw_spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical(_lock *plock, unsigned long *pirqL)
+{
+	raw_spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_ex(_lock *plock, unsigned long *pirqL)
+{
+	raw_spin_lock_irqsave(plock, *pirqL);
+}
+
+#else
+__inline static void _enter_critical(_lock *plock, unsigned long *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+__inline static void _exit_critical(_lock *plock, unsigned long *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_ex(_lock *plock, unsigned long *pirqL)
+{
+	spin_lock_irqsave(plock, *pirqL);
+}
+
+#endif
+__inline static void _exit_critical_ex(_lock *plock, unsigned long *pirqL)
+{
+	spin_unlock_irqrestore(plock, *pirqL);
+}
+
+__inline static void _enter_critical_bh(_lock *plock, unsigned long *pirqL)
+{
+	spin_lock_bh(plock);
+}
+
+__inline static void _exit_critical_bh(_lock *plock, unsigned long *pirqL)
+{
+	spin_unlock_bh(plock);
+}
+
+__inline static int _enter_critical_mutex(_mutex *pmutex, unsigned long *pirqL)
+{
+	int ret = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+	/* mutex_lock(pmutex); */
+	ret = mutex_lock_interruptible(pmutex);
+#else
+	ret = down_interruptible(pmutex);
+#endif
+	return ret;
+}
+
+
+__inline static void _exit_critical_mutex(_mutex *pmutex, unsigned long *pirqL)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
+	mutex_unlock(pmutex);
+#else
+	up(pmutex);
+#endif
+}
+
+#define RTW_TIMER_HDL_ARGS void *FunctionContext
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+__inline static void _init_timer(struct timer_list *ptimer,struct  net_device * nic_hdl,void *pfunc,void* cntx)
+{
+	ptimer->function = pfunc;
+	ptimer->data = (unsigned long)cntx;
+	init_timer(ptimer);
+}
+#endif
+
+__inline static void _set_timer(struct timer_list *ptimer, u32 delay_time)
+{
+	mod_timer(ptimer , (jiffies + (delay_time * HZ / 1000)));
+}
+
+__inline static void _cancel_timer(struct timer_list *ptimer, u8 *bcancelled)
+{
+	del_timer_sync(ptimer);
+	*bcancelled = 1;
+}
+
+
+static inline void _init_workitem(_workitem *pwork, void *pfunc, void *cntx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20))
+	INIT_WORK(pwork, pfunc);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+	INIT_WORK(pwork, pfunc, pwork);
+#else
+	INIT_TQUEUE(pwork, pfunc, pwork);
+#endif
+}
+
+__inline static void _set_workitem(_workitem *pwork)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+	schedule_work(pwork);
+#else
+	schedule_task(pwork);
+#endif
+}
+
+__inline static void _cancel_workitem_sync(_workitem *pwork)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22))
+	cancel_work_sync(pwork);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+	flush_scheduled_work();
+#else
+	flush_scheduled_tasks();
+#endif
+}
+/*
+ * Global Mutex: can only be used at PASSIVE level.
+ *   */
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+	{                                                               \
+		while (atomic_inc_return((atomic_t *)&(_MutexCounter)) != 1) { \
+			atomic_dec((atomic_t *)&(_MutexCounter));        \
+			msleep(10);                          \
+		}                                                           \
+	}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+	{                                                               \
+		atomic_dec((atomic_t *)&(_MutexCounter));        \
+	}
+
+static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));
+#else
+	return netif_queue_stopped(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_wake_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	netif_tx_wake_all_queues(pnetdev);
+#else
+	netif_wake_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_start_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	netif_tx_start_all_queues(pnetdev);
+#else
+	netif_start_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+	netif_tx_stop_all_queues(pnetdev);
+#else
+	netif_stop_queue(pnetdev);
+#endif
+}
+static inline void rtw_netif_carrier_on(struct net_device *pnetdev)
+{
+	netif_device_attach(pnetdev);
+	netif_carrier_on(pnetdev);
+}
+static inline int rtw_merge_string(char *dst, int dst_len, const char *src1, const char *src2)
+{
+	int	len = 0;
+	len += snprintf(dst + len, dst_len - len, "%s", src1);
+	len += snprintf(dst + len, dst_len - len, "%s", src2);
+
+	return len;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
+	#define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)), (sig), 1)
+#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+	#define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */
+
+
+/* Suspend lock prevent system from going suspend */
+#ifdef CONFIG_WAKELOCK
+	#include <linux/wakelock.h>
+#elif defined(CONFIG_ANDROID_POWER)
+	#include <linux/android_power.h>
+#endif
+
+/* limitation of path length */
+#define PATH_LENGTH_MAX PATH_MAX
+
+/* Atomic integer operations */
+#define ATOMIC_T atomic_t
+
+#define rtw_netdev_priv(netdev) (((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv)
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ndev->name
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) (adapter->pnetdev ? adapter->pnetdev->name : NULL)
+#define FUNC_NDEV_FMT "%s(%s)"
+#define FUNC_NDEV_ARG(ndev) __func__, ndev->name
+#define FUNC_ADPT_FMT "%s(%s)"
+#define FUNC_ADPT_ARG(adapter) __func__, (adapter->pnetdev ? adapter->pnetdev->name : NULL)
+
+struct rtw_netdev_priv_indicator {
+	void *priv;
+	u32 sizeof_priv;
+};
+struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
+extern struct net_device *rtw_alloc_etherdev(int sizeof_priv);
+
+#define STRUCT_PACKED __attribute__ ((packed))
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/recv_osdep.h b/drivers/staging/rtl8188eu/include/recv_osdep.h
new file mode 100644
index 000000000000..cd290d8187d4
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/recv_osdep.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+
+extern sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
+extern void _rtw_free_recv_priv(struct recv_priv *precvpriv);
+
+
+extern s32  rtw_recv_entry(union recv_frame *precv_frame);
+extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
+extern void rtw_recv_returnpacket(_nic_hdl cnxt, _pkt *preturnedpkt);
+
+extern int rtw_recv_monitor(_adapter *padapter, union recv_frame *precv_frame);
+
+extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
+
+struct sta_info;
+extern void rtw_handle_tkip_mic_err(_adapter *padapter, struct sta_info *sta, u8 bgroup);
+
+
+int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter);
+int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe);
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv);
+
+
+int rtw_os_alloc_recvframe(_adapter *padapter, union recv_frame *precvframe, u8 *pdata, _pkt *pskb);
+int rtw_os_recvframe_duplicate_skb(_adapter *padapter, union recv_frame *pcloneframe, _pkt *pskb);
+void rtw_os_free_recvframe(union recv_frame *precvframe);
+
+
+int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf);
+int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf);
+
+_pkt *rtw_os_alloc_msdu_pkt(union recv_frame *prframe, u16 nSubframe_Length, u8 *pdata);
+void rtw_os_recv_indicate_pkt(_adapter *padapter, _pkt *pkt, struct rx_pkt_attrib *pattrib);
+
+void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+#ifdef CONFIG_RTW_NAPI
+#include <linux/netdevice.h>	/* struct napi_struct */
+
+int rtw_recv_napi_poll(struct napi_struct *, int budget);
+#endif /* CONFIG_RTW_NAPI */
+
+#endif /*  */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_cmd.h b/drivers/staging/rtl8188eu/include/rtl8188e_cmd.h
new file mode 100644
index 000000000000..609c5be06d9e
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_cmd.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_CMD_H__
+#define __RTL8188E_CMD_H__
+
+typedef enum _RTL8188E_H2C_CMD_ID {
+	/* Class Common */
+	H2C_COM_RSVD_PAGE			= 0x00,
+	H2C_COM_MEDIA_STATUS_RPT	= 0x01,
+	H2C_COM_SCAN					= 0x02,
+	H2C_COM_KEEP_ALIVE			= 0x03,
+	H2C_COM_DISCNT_DECISION		= 0x04,
+#ifndef CONFIG_WOWLAN
+	H2C_COM_WWLAN				= 0x05,
+#endif
+	H2C_COM_INIT_OFFLOAD			= 0x06,
+	H2C_COM_REMOTE_WAKE_CTL	= 0x07,
+	H2C_COM_AP_OFFLOAD			= 0x08,
+	H2C_COM_BCN_RSVD_PAGE		= 0x09,
+	H2C_COM_PROB_RSP_RSVD_PAGE	= 0x0A,
+
+	/* Class PS */
+	H2C_PS_PWR_MODE				= 0x20,
+	H2C_PS_TUNE_PARA				= 0x21,
+	H2C_PS_TUNE_PARA_2			= 0x22,
+	H2C_PS_LPS_PARA				= 0x23,
+	H2C_PS_P2P_OFFLOAD			= 0x24,
+
+	/* Class DM */
+	H2C_DM_MACID_CFG				= 0x40,
+	H2C_DM_TXBF					= 0x41,
+	H2C_RSSI_REPORT				= 0x42,
+	/* Class BT */
+	H2C_BT_COEX_MASK				= 0x60,
+	H2C_BT_COEX_GPIO_MODE		= 0x61,
+	H2C_BT_DAC_SWING_VAL			= 0x62,
+	H2C_BT_PSD_RST				= 0x63,
+
+	/* Class Remote WakeUp */
+#ifdef CONFIG_WOWLAN
+	H2C_COM_WWLAN				= 0x80,
+	H2C_COM_REMOTE_WAKE_CTRL	= 0x81,
+	H2C_COM_AOAC_GLOBAL_INFO	= 0x82,
+	H2C_COM_AOAC_RSVD_PAGE		= 0x83,
+#endif
+
+	/* Class */
+	/* H2C_RESET_TSF				=0xc0, */
+} RTL8188E_H2C_CMD_ID;
+
+struct cmd_msg_parm {
+	u8 eid; /* element id */
+	u8 sz; /* sz */
+	u8 buf[6];
+};
+
+enum {
+	PWRS
+};
+
+typedef struct _SETPWRMODE_PARM {
+	u8 Mode;/* 0:Active,1:LPS,2:WMMPS */
+	/* u8 RLBM:4; */ /* 0:Min,1:Max,2: User define */
+	u8 SmartPS_RLBM;/* LPS=0:PS_Poll,1:PS_Poll,2:NullData,WMM=0:PS_Poll,1:NullData */
+	u8 AwakeInterval;	/* unit: beacon interval */
+	u8 bAllQueueUAPSD;
+	u8 PwrState;/* AllON(0x0c),RFON(0x04),RFOFF(0x00) */
+} SETPWRMODE_PARM, *PSETPWRMODE_PARM;
+
+struct H2C_SS_RFOFF_PARAM {
+	u8 ROFOn; /* 1: on, 0:off */
+	u16 gpio_period; /* unit: 1024 us */
+} __attribute__((packed));
+
+
+typedef struct JOINBSSRPT_PARM_88E {
+	u8 OpMode;	/* RT_MEDIA_STATUS */
+#ifdef CONFIG_WOWLAN
+	u8 MacID;       /* MACID */
+#endif /* CONFIG_WOWLAN */
+} JOINBSSRPT_PARM_88E, *PJOINBSSRPT_PARM_88E;
+
+/* host message to firmware cmd */
+void rtl8188e_set_FwPwrMode_cmd(PADAPTER padapter, u8 Mode);
+void rtl8188e_set_FwJoinBssReport_cmd(PADAPTER padapter, u8 mstatus);
+u8 rtl8188e_set_rssi_cmd(PADAPTER padapter, u8 *param);
+u8 rtl8188e_set_raid_cmd(_adapter *padapter, u32 bitmap, u8 *arg, u8 bw);
+s32 FillH2CCmd_88E(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer);
+/* u8 rtl8192c_set_FwSelectSuspend_cmd(PADAPTER padapter, u8 bfwpoll, u16 period); */
+u8 GetTxBufferRsvdPageNum8188E(_adapter *padapter, bool wowlan);
+
+
+#ifdef CONFIG_P2P
+	void rtl8188e_set_p2p_ps_offload_cmd(PADAPTER padapter, u8 p2p_ps_state);
+#endif /* CONFIG_P2P */
+
+void CheckFwRsvdPageContent(PADAPTER padapter);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+	/* u8 rtl8188e_reset_tsf(_adapter *padapter, u8 reset_port); */
+	int reset_tsf(PADAPTER Adapter, u8 reset_port);
+#endif /* CONFIG_TSF_RESET_OFFLOAD */
+
+/* #define H2C_8188E_RSVDPAGE_LOC_LEN      5 */
+/* #define H2C_8188E_AOAC_RSVDPAGE_LOC_LEN 7 */
+
+/* ---------------------------------------------------------------------------------------------------------
+ * ----------------------------------    H2C CMD CONTENT    --------------------------------------------------
+ * ---------------------------------------------------------------------------------------------------------
+ *   */
+#endif/* __RTL8188E_CMD_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_dm.h b/drivers/staging/rtl8188eu/include/rtl8188e_dm.h
new file mode 100644
index 000000000000..40f27bcfd77f
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_dm.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_DM_H__
+#define __RTL8188E_DM_H__
+
+void rtl8188e_init_dm_priv(PADAPTER Adapter);
+void rtl8188e_deinit_dm_priv(PADAPTER Adapter);
+void rtl8188e_InitHalDm(PADAPTER Adapter);
+void rtl8188e_HalDmWatchDog(PADAPTER Adapter);
+
+/* void rtl8192c_dm_CheckTXPowerTracking(IN PADAPTER Adapter); */
+
+/* void rtl8192c_dm_RF_Saving(IN PADAPTER pAdapter, IN u8 bForceInNormal); */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_hal.h b/drivers/staging/rtl8188eu/include/rtl8188e_hal.h
new file mode 100644
index 000000000000..65ee51f9aeb3
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_hal.h
@@ -0,0 +1,277 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_HAL_H__
+#define __RTL8188E_HAL_H__
+
+/* #include "hal_com.h" */
+#include "hal_data.h"
+
+/* include HAL Related header after HAL Related compiling flags */
+#include "rtl8188e_spec.h"
+#include "Hal8188EPhyReg.h"
+#include "Hal8188EPhyCfg.h"
+#include "rtl8188e_rf.h"
+#include "rtl8188e_dm.h"
+#include "rtl8188e_recv.h"
+#include "rtl8188e_xmit.h"
+#include "rtl8188e_cmd.h"
+#include "rtl8188e_led.h"
+#include "Hal8188EPwrSeq.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+	#include "rtl8188e_sreset.h"
+#endif
+
+/* --------------------------------------------------------------------- */
+/*		RTL8188E Power Configuration CMDs for USB/SDIO/PCIE interfaces */
+/* --------------------------------------------------------------------- */
+#define Rtl8188E_NIC_PWR_ON_FLOW				rtl8188E_power_on_flow
+#define Rtl8188E_NIC_RF_OFF_FLOW				rtl8188E_radio_off_flow
+#define Rtl8188E_NIC_DISABLE_FLOW				rtl8188E_card_disable_flow
+#define Rtl8188E_NIC_ENABLE_FLOW				rtl8188E_card_enable_flow
+#define Rtl8188E_NIC_SUSPEND_FLOW				rtl8188E_suspend_flow
+#define Rtl8188E_NIC_RESUME_FLOW				rtl8188E_resume_flow
+#define Rtl8188E_NIC_PDN_FLOW					rtl8188E_hwpdn_flow
+#define Rtl8188E_NIC_LPS_ENTER_FLOW			rtl8188E_enter_lps_flow
+#define Rtl8188E_NIC_LPS_LEAVE_FLOW			rtl8188E_leave_lps_flow
+
+#define MAX_FW_8188E_SIZE			0x8000 /* 32768, 32k / 16384, 16k */
+
+#define FW_8188E_SIZE				0x4000 /* 16384, 16k */
+#define FW_8188E_SIZE_2			0x8000 /* 32768, 32k */
+
+#define FW_8188E_START_ADDRESS	0x1000
+#define FW_8188E_END_ADDRESS		0x1FFF /* 0x5FFF */
+
+
+#define IS_FW_HEADER_EXIST_88E(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature) & 0xFFF0) == 0x88E0)
+
+typedef struct _RT_FIRMWARE_8188E {
+	FIRMWARE_SOURCE	eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8			*szFwBuffer;
+#else
+	u8			szFwBuffer[MAX_FW_8188E_SIZE];
+#endif
+	u32			ulFwLength;
+} RT_FIRMWARE_8188E, *PRT_FIRMWARE_8188E;
+
+/*
+ * This structure must be cared byte-ordering
+ *   */
+
+typedef struct _RT_8188E_FIRMWARE_HDR {
+	/* 8-byte alinment required */
+
+	/* --- LONG WORD 0 ---- */
+	__le16		Signature;	/* 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
+	u8		Category;	/* AP/NIC and USB/PCI */
+	u8		Function;	/* Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
+	__le16		Version;		/* FW Version */
+	u8		Subversion;	/* FW Subversion, default 0x00 */
+	__le16		Rsvd1;
+
+
+	/* --- LONG WORD 1 ---- */
+	u8		Month;	/* Release time Month field */
+	u8		Date;	/* Release time Date field */
+	u8		Hour;	/* Release time Hour field */
+	u8		Minute;	/* Release time Minute field */
+	__le16		RamCodeSize;	/* The size of RAM code */
+	u8		Foundry;
+	u8		Rsvd2;
+
+	/* --- LONG WORD 2 ---- */
+	__le32		SvnIdx;	/* The SVN entry index */
+	__le32		Rsvd3;
+
+	/* --- LONG WORD 3 ---- */
+	__le32		Rsvd4;
+	__le32		Rsvd5;
+} RT_8188E_FIRMWARE_HDR, *PRT_8188E_FIRMWARE_HDR;
+
+
+#define DRIVER_EARLY_INT_TIME_8188E			0x05
+#define BCN_DMA_ATIME_INT_TIME_8188E		0x02
+
+
+/* #define MAX_RX_DMA_BUFFER_SIZE_88E	      0x2400 */ /* 9k for 88E nornal chip , */ /* MaxRxBuff=10k-max(TxReportSize(64*8), WOLPattern(16*24)) */
+	#define RX_DMA_SIZE_88E(__Adapter) 0x2800
+
+#ifdef CONFIG_WOWLAN
+	#define RESV_FMWF	(WKFMCAM_SIZE * MAX_WKFM_CAM_NUM) /* 16 entries, for each is 24 bytes*/
+#else
+	#define RESV_FMWF	0
+#endif
+
+#define RX_DMA_RESERVD_FW_FEATURE	0x200 /* for tx report (64*8) */
+
+#define MAX_RX_DMA_BUFFER_SIZE_88E(__Adapter) (RX_DMA_SIZE_88E(__Adapter)-RX_DMA_RESERVD_FW_FEATURE)
+
+#define MAX_TX_REPORT_BUFFER_SIZE			0x0400 /* 1k */
+
+/* Note: We will divide number of page equally for each queue other than public queue!
+ * 22k = 22528 bytes = 176 pages (@page =  128 bytes)
+ * must reserved about 7 pages for LPS =>  176-7 = 169 (0xA9)
+ * 2*BCN / 1*ps-poll / 1*null-data /1*prob_rsp /1*QOS null-data /1*BT QOS null-data  */
+
+#define BCNQ_PAGE_NUM_88E		0x09
+
+/* For WoWLan , more reserved page */
+#ifdef CONFIG_WOWLAN
+	#define WOWLAN_PAGE_NUM_88E	0x00
+#else
+	#define WOWLAN_PAGE_NUM_88E	0x00
+#endif
+
+/* Note:
+Tx FIFO Size : previous CUT:22K /I_CUT after:32KB
+Tx page Size : 128B
+Total page numbers : 176(0xB0) / 256(0x100)
+*/
+	#define TOTAL_PAGE_NUMBER_88E(_Adapter) (0xB0 - 1)
+#define TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	(TOTAL_PAGE_NUMBER_88E(_Adapter) - BCNQ_PAGE_NUM_88E - WOWLAN_PAGE_NUM_88E)
+#define TX_PAGE_BOUNDARY_88E(_Adapter)		(TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1) /* beacon header start address */
+
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter)	TX_TOTAL_PAGE_NUMBER_88E(_Adapter)
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_88E(_Adapter)		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_88E(_Adapter) + 1)
+
+/* For Normal Chip Setting
+ * (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8723B */
+#define NORMAL_PAGE_NUM_HPQ_88E		0x0
+#define NORMAL_PAGE_NUM_LPQ_88E		0x09
+#define NORMAL_PAGE_NUM_NPQ_88E		0x0
+
+/* Note: For Normal Chip Setting, modify later */
+#define WMM_NORMAL_PAGE_NUM_HPQ_88E		0x29
+#define WMM_NORMAL_PAGE_NUM_LPQ_88E		0x1C
+#define WMM_NORMAL_PAGE_NUM_NPQ_88E		0x1C
+
+
+/* -------------------------------------------------------------------------
+ *	Chip specific
+ * ------------------------------------------------------------------------- */
+#define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22) & 0x3)
+#define CHIP_BONDING_92C_1T2R	0x1
+#define CHIP_BONDING_88C_USB_MCARD	0x2
+#define CHIP_BONDING_88C_USB_HP	0x1
+
+/* -------------------------------------------------------------------------
+ *	Channel Plan
+ * ------------------------------------------------------------------------- */
+
+
+#define EFUSE_REAL_CONTENT_LEN		512
+#define EFUSE_MAP_LEN				128
+#define EFUSE_MAX_SECTION			16
+#define EFUSE_IC_ID_OFFSET			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
+#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_REAL_CONTENT_LEN)
+/*
+ * <Roger_Notes>
+ * To prevent out of boundary programming case,
+ * leave 1byte and program full section
+ * 9bytes + 1byt + 5bytes and pre 1byte.
+ * For worst case:
+ * | 1byte|----8bytes----|1byte|--5bytes--|
+ * |         |            Reserved(14bytes)	      |
+ *   */
+#define EFUSE_OOB_PROTECT_BYTES 		15	/* PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte. */
+
+#define		EFUSE_REAL_CONTENT_LEN_88E	256
+#define		EFUSE_MAP_LEN_88E		512
+#define		EFUSE_MAX_SECTION_88E		64
+#define		EFUSE_MAX_WORD_UNIT_88E		4
+#define		EFUSE_IC_ID_OFFSET_88E			506	/* For some inferiority IC purpose. added by Roger, 2009.09.02. */
+#define		AVAILABLE_EFUSE_ADDR_88E(addr)	(addr < EFUSE_REAL_CONTENT_LEN_88E)
+/* <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+ * 9bytes + 1byt + 5bytes and pre 1byte.
+ * For worst case:
+ * | 2byte|----8bytes----|1byte|--7bytes--|  */ /* 92D */
+#define 		EFUSE_OOB_PROTECT_BYTES_88E	18	/* PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte. */
+#define		EFUSE_PROTECT_BYTES_BANK_88E	16
+
+
+/* ********************************************************
+ *			EFUSE for BT definition
+ * ******************************************************** */
+#define EFUSE_BT_REAL_CONTENT_LEN		1536	/* 512*3 */
+#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
+#define EFUSE_BT_MAX_SECTION			128		/* 1024/8 */
+
+#define EFUSE_PROTECT_BYTES_BANK		16
+
+#define INCLUDE_MULTI_FUNC_BT(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
+#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(GET_HAL_DATA(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
+
+/* #define IS_MULTI_FUNC_CHIP(_Adapter)	(((((PHAL_DATA_TYPE)(_Adapter->HalData))->MultiFunc) & (RT_MULTI_FUNC_BT|RT_MULTI_FUNC_GPS)) ? true : false) */
+
+/* #define RT_IS_FUNC_DISABLED(__pAdapter, __FuncBits) ( (__pAdapter)->DisabledFunctions & (__FuncBits) ) */
+
+/* rtl8188e_hal_init.c */
+
+s32 rtl8188e_FirmwareDownload(PADAPTER padapter, bool  bUsedWoWLANFw);
+void _8051Reset88E(PADAPTER padapter);
+void rtl8188e_InitializeFirmwareVars(PADAPTER padapter);
+
+
+s32 InitLLTTable(PADAPTER padapter, u8 txpktbuf_bndy);
+
+/* EFuse */
+u8 GetEEPROMSize8188E(PADAPTER padapter);
+void Hal_InitPGData88E(PADAPTER padapter);
+void Hal_EfuseParseIDCode88E(PADAPTER padapter, u8 *hwinfo);
+void Hal_ReadTxPowerInfo88E(PADAPTER padapter, u8 *hwinfo, bool	AutoLoadFail);
+
+void Hal_EfuseParseEEPROMVer88E(PADAPTER padapter, u8 *hwinfo, bool AutoLoadFail);
+void rtl8188e_EfuseParseChnlPlan(PADAPTER padapter, u8 *hwinfo, bool AutoLoadFail);
+void Hal_EfuseParseCustomerID88E(PADAPTER padapter, u8 *hwinfo, bool AutoLoadFail);
+void Hal_ReadAntennaDiversity88E(PADAPTER pAdapter, u8 *PROMContent, bool AutoLoadFail);
+void Hal_ReadThermalMeter_88E(PADAPTER	Adapter, u8 *PROMContent, bool	AutoloadFail);
+void Hal_EfuseParseXtal_8188E(PADAPTER pAdapter, u8 *hwinfo, bool AutoLoadFail);
+void Hal_EfuseParseBoardType88E(PADAPTER pAdapter, u8 *hwinfo, bool AutoLoadFail);
+void Hal_ReadPowerSavingMode88E(PADAPTER pAdapter, u8 *hwinfo, bool AutoLoadFail);
+void Hal_ReadPAType_8188E(PADAPTER Adapter, u8 *PROMContent, bool AutoloadFail);
+void Hal_ReadAmplifierType_8188E(PADAPTER Adapter, u8 *PROMContent, bool AutoloadFail);
+void Hal_ReadRFEType_8188E(PADAPTER Adapter, u8 *PROMContent, bool AutoloadFail);
+
+bool HalDetectPwrDownMode88E(PADAPTER Adapter);
+
+#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
+	void Hal_DetectWoWMode(PADAPTER pAdapter);
+#endif /* CONFIG_WOWLAN */
+
+
+#ifdef CONFIG_RF_POWER_TRIM
+	void Hal_ReadRFGainOffset(PADAPTER pAdapter, u8 *hwinfo, bool AutoLoadFail);
+#endif /*CONFIG_RF_POWER_TRIM*/
+
+void rtl8188e_init_default_value(_adapter *adapter);
+
+void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc);
+void init_hal_spec_8188e(_adapter *adapter);
+
+/* register */
+void SetBcnCtrlReg(PADAPTER padapter, u8 SetBits, u8 ClearBits);
+
+void rtl8188e_start_thread(_adapter *padapter);
+void rtl8188e_stop_thread(_adapter *padapter);
+
+void rtw_IOL_cmd_tx_pkt_buf_dump(ADAPTER *Adapter, int data_len);
+#ifdef CONFIG_IOL_EFUSE_PATCH
+	s32 rtl8188e_iol_efuse_patch(PADAPTER padapter);
+#endif/* CONFIG_IOL_EFUSE_PATCH */
+void _InitTransferPageSize(PADAPTER padapter);
+
+void SetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
+void GetHwReg8188E(PADAPTER padapter, u8 variable, u8 *val);
+
+u8
+GetHalDefVar8188E(
+	PADAPTER				Adapter,
+	HAL_DEF_VARIABLE		eVariable,
+	void *					pValue
+);
+#ifdef CONFIG_GPIO_API
+int rtl8188e_GpioFuncCheck(PADAPTER adapter, u8 gpio_num);
+#endif
+#endif /* __RTL8188E_HAL_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_led.h b/drivers/staging/rtl8188eu/include/rtl8188e_led.h
new file mode 100644
index 000000000000..ef9ca0bdf951
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_led.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_LED_H__
+#define __RTL8188E_LED_H__
+
+
+/* ********************************************************************************
+ * Interface to manipulate LED objects.
+ * ******************************************************************************** */
+	void rtl8188eu_InitSwLeds(PADAPTER padapter);
+	void rtl8188eu_DeInitSwLeds(PADAPTER padapter);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_recv.h b/drivers/staging/rtl8188eu/include/rtl8188e_recv.h
new file mode 100644
index 000000000000..b05f715c6b88
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_recv.h
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_RECV_H__
+#define __RTL8188E_RECV_H__
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+	#ifndef MAX_RECVBUF_SZ
+		#ifndef CONFIG_MINIMAL_MEMORY_USAGE
+			/* #define MAX_RECVBUF_SZ (32768) */ /* 32k */
+			/* #define MAX_RECVBUF_SZ (16384) */ /* 16K */
+			/* #define MAX_RECVBUF_SZ (10240) */ /* 10K */
+			#define MAX_RECVBUF_SZ (15360) /* 15k < 16k */
+			/* #define MAX_RECVBUF_SZ (8192+1024) */ /* 8K+1k */
+		#else
+			#define MAX_RECVBUF_SZ (4000) /* about 4K */
+		#endif
+	#endif /* !MAX_RECVBUF_SZ */
+
+/* Rx smooth factor */
+#define	Rx_Smooth_Factor (20)
+
+#define TX_RPT1_PKT_LEN 8
+
+typedef struct rxreport_8188e {
+	/* Offset 0 */
+	u32 pktlen:14;
+	u32 crc32:1;
+	u32 icverr:1;
+	u32 drvinfosize:4;
+	u32 security:3;
+	u32 qos:1;
+	u32 shift:2;
+	u32 physt:1;
+	u32 swdec:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 eor:1;
+	u32 own:1;
+
+	/* Offset 4 */
+	u32 macid:5;
+	u32 tid:4;
+	u32 hwrsvd:4;
+	u32 amsdu:1;
+	u32 paggr:1;
+	u32 faggr:1;
+	u32 a1fit:4;
+	u32 a2fit:4;
+	u32 pam:1;
+	u32 pwr:1;
+	u32 md:1;
+	u32 mf:1;
+	u32 type:2;
+	u32 mc:1;
+	u32 bc:1;
+
+	/* Offset 8 */
+	u32 seq:12;
+	u32 frag:4;
+	u32 nextpktlen:14;
+	u32 nextind:1;
+	u32 rsvd0831:1;
+
+	/* Offset 12 */
+	u32 rxmcs:6;
+	u32 rxht:1;
+	u32 gf:1;
+	u32 splcp:1;
+	u32 bw:1;
+	u32 htc:1;
+	u32 eosp:1;
+	u32 bssidfit:2;
+	u32 rpt_sel:2;
+	u32 rsvd1216:13;
+	u32 pattern_match:1;
+	u32 unicastwake:1;
+	u32 magicwake:1;
+
+	/* Offset 16 */
+	/*
+	u32 pattern0match:1;
+	u32 pattern1match:1;
+	u32 pattern2match:1;
+	u32 pattern3match:1;
+	u32 pattern4match:1;
+	u32 pattern5match:1;
+	u32 pattern6match:1;
+	u32 pattern7match:1;
+	u32 pattern8match:1;
+	u32 pattern9match:1;
+	u32 patternamatch:1;
+	u32 patternbmatch:1;
+	u32 patterncmatch:1;
+	u32 rsvd1613:19;
+	*/
+	u32 rsvd16;
+
+	/* Offset 20 */
+	u32 tsfl;
+
+	/* Offset 24 */
+	u32 bassn:12;
+	u32 bavld:1;
+	u32 rsvd2413:19;
+} RXREPORT, *PRXREPORT;
+
+	void rtl8188eu_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
+	s32 rtl8188eu_init_recv_priv(PADAPTER padapter);
+	void rtl8188eu_free_recv_priv(PADAPTER padapter);
+
+void rtl8188e_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *prxstat);
+
+#endif /* __RTL8188E_RECV_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_rf.h b/drivers/staging/rtl8188eu/include/rtl8188e_rf.h
new file mode 100644
index 000000000000..92075ca41e58
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_rf.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_RF_H__
+#define __RTL8188E_RF_H__
+
+
+
+int	PHY_RF6052_Config8188E(PADAPTER		Adapter);
+void		rtl8188e_RF_ChangeTxPath(PADAPTER	Adapter,
+		u16		DataRate);
+void		rtl8188e_PHY_RF6052SetBandwidth(
+	PADAPTER				Adapter,
+	CHANNEL_WIDTH		Bandwidth);
+
+#endif/* __RTL8188E_RF_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_spec.h b/drivers/staging/rtl8188eu/include/rtl8188e_spec.h
new file mode 100644
index 000000000000..0ed7899d7aab
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_spec.h
@@ -0,0 +1,137 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_SPEC_H__
+#define __RTL8188E_SPEC_H__
+
+
+/* ************************************************************
+ * 8188E Regsiter offset definition
+ * ************************************************************ */
+
+
+/* ************************************************************
+ *
+ * ************************************************************ */
+
+/* -----------------------------------------------------
+ *
+ *	0x0000h ~ 0x00FFh	System Configuration
+ *
+ * ----------------------------------------------------- */
+#define REG_BB_PAD_CTRL				0x0064
+#define REG_HMEBOX_E0					0x0088
+#define REG_HMEBOX_E1					0x008A
+#define REG_HMEBOX_E2					0x008C
+#define REG_HMEBOX_E3					0x008E
+#define REG_HMEBOX_EXT_0				0x01F0
+#define REG_HMEBOX_EXT_1				0x01F4
+#define REG_HMEBOX_EXT_2				0x01F8
+#define REG_HMEBOX_EXT_3				0x01FC
+#define REG_HIMR_88E					0x00B0 /* RTL8188E */
+#define REG_HISR_88E					0x00B4 /* RTL8188E */
+#define REG_HIMRE_88E					0x00B8 /* RTL8188E */
+#define REG_HISRE_88E					0x00BC /* RTL8188E */
+#define REG_MACID_NO_LINK_0			0x0484
+#define REG_MACID_NO_LINK_1			0x0488
+#define REG_MACID_PAUSE_0			0x048c
+#define REG_MACID_PAUSE_1			0x0490
+
+/* -----------------------------------------------------
+ *
+ *	0x0100h ~ 0x01FFh	MACTOP General Configuration
+ *
+ * ----------------------------------------------------- */
+#define REG_PKTBUF_DBG_ADDR			(REG_PKTBUF_DBG_CTRL)
+#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+#define REG_WOWLAN_WAKE_REASON		REG_MCUTST_WOWLAN
+
+/* -----------------------------------------------------
+ *
+ *	0x0200h ~ 0x027Fh	TXDMA Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* -----------------------------------------------------
+ *
+ *	0x0280h ~ 0x02FFh	RXDMA Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* -----------------------------------------------------
+ *
+ *	0x0300h ~ 0x03FFh	PCIe
+ *
+ * ----------------------------------------------------- */
+
+/* -----------------------------------------------------
+ *
+ *	0x0400h ~ 0x047Fh	Protocol Configuration
+ *
+ * ----------------------------------------------------- */
+#ifdef CONFIG_WOWLAN
+	#define REG_TXPKTBUF_IV_LOW             0x01a4
+	#define REG_TXPKTBUF_IV_HIGH            0x01a8
+#endif
+
+/* -----------------------------------------------------
+ *
+ *	0x0500h ~ 0x05FFh	EDCA Configuration
+ *
+ * ----------------------------------------------------- */
+
+/* -----------------------------------------------------
+ *
+ *	0x0600h ~ 0x07FFh	WMAC Configuration
+ *
+ * ----------------------------------------------------- */
+#ifdef CONFIG_RF_POWER_TRIM
+	#define EEPROM_RF_GAIN_OFFSET			0xC1
+	#define EEPROM_RF_GAIN_VAL				0xF6
+	#define EEPROM_THERMAL_OFFSET			0xF5
+#endif /*CONFIG_RF_POWER_TRIM*/
+/* ----------------------------------------------------------------------------
+ * 88E Driver Initialization Offload REG_FDHM0(Offset 0x88, 8 bits)
+ * ----------------------------------------------------------------------------
+ * IOL config for REG_FDHM0(Reg0x88) */
+#define CMD_INIT_LLT					BIT0
+#define CMD_READ_EFUSE_MAP		BIT1
+#define CMD_EFUSE_PATCH			BIT2
+#define CMD_IOCONFIG				BIT3
+#define CMD_INIT_LLT_ERR			BIT4
+#define CMD_READ_EFUSE_MAP_ERR	BIT5
+#define CMD_EFUSE_PATCH_ERR		BIT6
+#define CMD_IOCONFIG_ERR			BIT7
+
+/* -----------------------------------------------------
+ *
+ *	Redifine register definition for compatibility
+ *
+ * ----------------------------------------------------- */
+
+/* TODO: use these definition when using REG_xxx naming rule.
+ * NOTE: DO NOT Remove these definition. Use later. */
+#define ISR_88E				REG_HISR_88E
+
+#ifdef CONFIG_PCI_HCI
+	/* #define IMR_RX_MASK		(IMR_ROK_88E|IMR_RDU_88E|IMR_RXFOVW_88E) */
+	#define IMR_TX_MASK			(IMR_VODOK_88E | IMR_VIDOK_88E | IMR_BEDOK_88E | IMR_BKDOK_88E | IMR_MGNTDOK_88E | IMR_HIGHDOK_88E | IMR_BCNDERR0_88E)
+
+	#ifdef CONFIG_CONCURRENT_MODE
+		#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E | IMR_BCNDMAINT_E_88E)
+	#else
+		#define RT_BCN_INT_MASKS	(IMR_BCNDMAINT0_88E | IMR_TBDOK_88E | IMR_TBDER_88E)
+	#endif
+
+	#define RT_AC_INT_MASKS	(IMR_VIDOK_88E | IMR_VODOK_88E | IMR_BEDOK_88E | IMR_BKDOK_88E)
+#endif
+
+/* ----------------------------------------------------------------------------
+ * 8192C EEPROM/EFUSE share register definition.
+ * ---------------------------------------------------------------------------- */
+
+#define EFUSE_ACCESS_ON			0x69	/* For RTL8723 only. */
+#define EFUSE_ACCESS_OFF			0x00	/* For RTL8723 only. */
+
+#endif /* __RTL8188E_SPEC_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_sreset.h b/drivers/staging/rtl8188eu/include/rtl8188e_sreset.h
new file mode 100644
index 000000000000..b3e367d434bc
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_sreset.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTL8188E_SRESET_H_
+#define _RTL8188E_SRESET_H_
+
+#include <rtw_sreset.h>
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	extern void rtl8188e_sreset_xmit_status_check(_adapter *padapter);
+	extern void rtl8188e_sreset_linked_status_check(_adapter *padapter);
+#endif
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_xmit.h b/drivers/staging/rtl8188eu/include/rtl8188e_xmit.h
new file mode 100644
index 000000000000..76f90aff1c34
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_xmit.h
@@ -0,0 +1,270 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTL8188E_XMIT_H__
+#define __RTL8188E_XMIT_H__
+
+
+
+
+/* For 88e early mode */
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
+#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
+#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
+#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
+#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)
+
+/*
+ * defined for TX DESC Operation
+ *   */
+
+#define MAX_TID (15)
+
+/* OFFSET 0 */
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC		BIT(24)
+#define LSG		BIT(26)
+#define FSG		BIT(27)
+#define OWN		BIT(31)
+
+
+/* OFFSET 4 */
+#define PKT_OFFSET_SZ		0
+#define QSEL_SHT			8
+#define RATE_ID_SHT			16
+#define NAVUSEHDR			BIT(20)
+#define SEC_TYPE_SHT		22
+#define PKT_OFFSET_SHT		26
+
+/* OFFSET 8 */
+#define AGG_EN				BIT(12)
+#define AGG_BK					BIT(16)
+#define AMPDU_DENSITY_SHT	20
+#define ANTSEL_A			BIT(24)
+#define ANTSEL_B			BIT(25)
+#define TX_ANT_CCK_SHT		26
+#define TX_ANTL_SHT			28
+#define TX_ANT_HT_SHT		30
+
+/* OFFSET 12 */
+#define SEQ_SHT				16
+#define EN_HWSEQ			BIT(31)
+
+/* OFFSET 16 */
+#define	QOS                          BIT(6)
+#define	HW_SSN				BIT(7)
+#define	USERATE			BIT(8)
+#define	DISDATAFB			BIT(10)
+#define   CTS_2_SELF			BIT(11)
+#define	RTS_EN				BIT(12)
+#define	HW_RTS_EN			BIT(13)
+#define	DATA_SHORT			BIT(24)
+#define	PWR_STATUS_SHT	15
+#define	DATA_SC_SHT		20
+#define	DATA_BW			BIT(25)
+
+/* OFFSET 20 */
+#define	RTY_LMT_EN			BIT(17)
+
+
+/* OFFSET 20 */
+#define SGI					BIT(6)
+#define USB_TXAGG_NUM_SHT	24
+
+typedef struct txdesc_88e {
+	/* Offset 0 */
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 own:1;
+
+	/* Offset 4 */
+	u32 macid:6;
+	u32 rsvd0406:2;
+	u32 qsel:5;
+	u32 rd_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:4;
+	u32 navusehdr:1;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 rsvd0424:2;
+	u32 pkt_offset:5;	/* unit: 8 bytes */
+	u32 rsvd0431:1;
+
+	/* Offset 8 */
+	u32 rts_rc:6;
+	u32 data_rc:6;
+	u32 agg_en:1;
+	u32 rd_en:1;
+	u32 bar_rty_th:2;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 ccx:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 ant_sel_a:1;
+	u32 ant_sel_b:1;
+	u32 tx_ant_cck:2;
+	u32 tx_antl:2;
+	u32 tx_ant_ht:2;
+
+	/* Offset 12 */
+	u32 nextheadpage:8;
+	u32 tailpage:8;
+	u32 seq:12;
+	u32 cpu_handle:1;
+	u32 tag1:1;
+	u32 trigger_int:1;
+	u32 hwseq_en:1;
+
+	/* Offset 16 */
+	u32 rtsrate:5;
+	u32 ap_dcfe:1;
+	u32 hwseq_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 pwr_status:3;
+	u32 wait_dcts:1;
+	u32 cts2ap_en:1;
+	u32 data_sc:2;
+	u32 data_stbc:2;
+	u32 data_short:1;
+	u32 data_bw:1;
+	u32 rts_short:1;
+	u32 rts_bw:1;
+	u32 rts_sc:2;
+	u32 vcs_stbc:2;
+
+	/* Offset 20 */
+	u32 datarate:6;
+	u32 sgi:1;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 usb_txagg_num:8;
+
+	/* Offset 24 */
+	u32 txagg_a:5;
+	u32 txagg_b:5;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 mcsg1_max_len:4;
+	u32 mcsg2_max_len:4;
+	u32 mcsg3_max_len:4;
+	u32 mcs7_sgi_max_len:4;
+
+	/* Offset 28 */
+	u32 checksum:16;	/* TxBuffSize(PCIe)/CheckSum(USB) */
+	u32 sw0:8; /* offset 30 */
+	u32 sw1:4;
+	u32 mcs15_sgi_max_len:4;
+} TXDESC_8188E, *PTXDESC_8188E;
+
+#define txdesc_set_ccx_sw_88e(txdesc, value) \
+	do { \
+		((struct txdesc_88e *)(txdesc))->sw1 = (((value)>>8) & 0x0f); \
+		((struct txdesc_88e *)(txdesc))->sw0 = ((value) & 0xff); \
+	} while (0)
+
+struct txrpt_ccx_88e {
+	/* offset 0 */
+	u8 tag1:1;
+	u8 pkt_num:3;
+	u8 txdma_underflow:1;
+	u8 int_bt:1;
+	u8 int_tri:1;
+	u8 int_ccx:1;
+
+	/* offset 1 */
+	u8 mac_id:6;
+	u8 pkt_ok:1;
+	u8 bmc:1;
+
+	/* offset 2 */
+	u8 retry_cnt:6;
+	u8 lifetime_over:1;
+	u8 retry_over:1;
+
+	/* offset 3 */
+	u8 ccx_qtime0;
+	u8 ccx_qtime1;
+
+	/* offset 5 */
+	u8 final_data_rate;
+
+	/* offset 6 */
+	u8 sw1:4;
+	u8 qsel:4;
+
+	/* offset 7 */
+	u8 sw0;
+};
+
+#define txrpt_ccx_sw_88e(txrpt_ccx) ((txrpt_ccx)->sw0 + ((txrpt_ccx)->sw1<<8))
+#define txrpt_ccx_qtime_88e(txrpt_ccx) ((txrpt_ccx)->ccx_qtime0+((txrpt_ccx)->ccx_qtime1<<8))
+
+#define SET_TX_DESC_SEC_TYPE_8188E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 22, 2, __Value)
+
+void rtl8188e_fill_fake_txdesc(PADAPTER	padapter, u8 *pDesc, u32 BufferLen,
+			       u8 IsPsPoll, u8	IsBTQosNull, u8 bDataFrame);
+void rtl8188e_cal_txdesc_chksum(struct tx_desc	*ptxdesc);
+#if defined(CONFIG_CONCURRENT_MODE)
+	void fill_txdesc_force_bmc_camid(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
+#endif
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	s32 rtl8188es_init_xmit_priv(PADAPTER padapter);
+	void rtl8188es_free_xmit_priv(PADAPTER padapter);
+	s32 rtl8188es_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+	s32 rtl8188es_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+	s32	rtl8188es_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+	thread_return rtl8188es_xmit_thread(thread_context context);
+	s32 rtl8188es_xmit_buf_handler(PADAPTER padapter);
+
+	#ifdef CONFIG_SDIO_TX_TASKLET
+		void rtl8188es_xmit_tasklet(void *priv);
+	#endif
+#endif
+
+	s32 rtl8188eu_init_xmit_priv(PADAPTER padapter);
+	void rtl8188eu_free_xmit_priv(PADAPTER padapter);
+	s32 rtl8188eu_hal_xmit(PADAPTER padapter, struct xmit_frame *pxmitframe);
+	s32 rtl8188eu_mgnt_xmit(PADAPTER padapter, struct xmit_frame *pmgntframe);
+	s32	rtl8188eu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+	s32 rtl8188eu_xmit_buf_handler(PADAPTER padapter);
+	void rtl8188eu_xmit_tasklet(void *priv);
+	s32 rtl8188eu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+#ifdef CONFIG_TX_EARLY_MODE
+	void UpdateEarlyModeInfo8188E(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+#endif
+
+#ifdef CONFIG_XMIT_ACK
+	void dump_txrpt_ccx_88e(void *buf);
+	void handle_txrpt_ccx_88e(_adapter *adapter, u8 *buf);
+#else
+	#define dump_txrpt_ccx_88e(buf) do {} while (0)
+	#define handle_txrpt_ccx_88e(adapter, buf) do {} while (0)
+#endif /* CONFIG_XMIT_ACK */
+
+void _dbg_dump_tx_info(_adapter	*padapter, int frame_tag, struct tx_desc *ptxdesc);
+#endif /* __RTL8188E_XMIT_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_android.h b/drivers/staging/rtl8188eu/include/rtw_android.h
new file mode 100644
index 000000000000..bff49b607fc2
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_android.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef __RTW_ANDROID_H__
+#define __RTW_ANDROID_H__
+
+enum ANDROID_WIFI_CMD {
+	ANDROID_WIFI_CMD_START,
+	ANDROID_WIFI_CMD_STOP,
+	ANDROID_WIFI_CMD_SCAN_ACTIVE,
+	ANDROID_WIFI_CMD_SCAN_PASSIVE,
+	ANDROID_WIFI_CMD_RSSI,
+	ANDROID_WIFI_CMD_LINKSPEED,
+	ANDROID_WIFI_CMD_RXFILTER_START,
+	ANDROID_WIFI_CMD_RXFILTER_STOP,
+	ANDROID_WIFI_CMD_RXFILTER_ADD,
+	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
+	ANDROID_WIFI_CMD_BTCOEXMODE,
+	ANDROID_WIFI_CMD_SETSUSPENDOPT,
+	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
+	ANDROID_WIFI_CMD_SETFWPATH,
+	ANDROID_WIFI_CMD_SETBAND,
+	ANDROID_WIFI_CMD_GETBAND,
+	ANDROID_WIFI_CMD_COUNTRY,
+	ANDROID_WIFI_CMD_P2P_SET_NOA,
+	ANDROID_WIFI_CMD_P2P_GET_NOA,
+	ANDROID_WIFI_CMD_P2P_SET_PS,
+	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+
+	ANDROID_WIFI_CMD_MIRACAST,
+
+#ifdef CONFIG_PNO_SUPPORT
+	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
+	ANDROID_WIFI_CMD_PNOSETUP_SET,
+	ANDROID_WIFI_CMD_PNOENABLE_SET,
+	ANDROID_WIFI_CMD_PNODEBUG_SET,
+#endif
+
+	ANDROID_WIFI_CMD_MACADDR,
+
+	ANDROID_WIFI_CMD_BLOCK_SCAN,
+	ANDROID_WIFI_CMD_BLOCK,
+
+	ANDROID_WIFI_CMD_WFD_ENABLE,
+	ANDROID_WIFI_CMD_WFD_DISABLE,
+
+	ANDROID_WIFI_CMD_WFD_SET_TCPPORT,
+	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
+	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
+	ANDROID_WIFI_CMD_CHANGE_DTIM,
+	ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL,
+	ANDROID_WIFI_CMD_HOSTAPD_ACL_ADD_STA,
+	ANDROID_WIFI_CMD_HOSTAPD_ACL_REMOVE_STA,
+#if defined(CONFIG_GTK_OL) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0))
+	ANDROID_WIFI_CMD_GTK_REKEY_OFFLOAD,
+#endif /* CONFIG_GTK_OL */
+	ANDROID_WIFI_CMD_P2P_DISABLE,
+	ANDROID_WIFI_CMD_DRIVERVERSION,
+	ANDROID_WIFI_CMD_MAX
+};
+
+int rtw_android_cmdstr_to_num(char *cmdstr);
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#if defined(CONFIG_PNO_SUPPORT) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+int rtw_android_pno_enable(struct net_device *net, int pno_enable);
+int rtw_android_cfg80211_pno_setup(struct net_device *net,
+		   struct cfg80211_ssid *ssid, int n_ssids, int interval);
+#endif
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+int rtw_android_wifictrl_func_add(void);
+void rtw_android_wifictrl_func_del(void);
+void *wl_android_prealloc(int section, unsigned long size);
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr);
+int wifi_set_power(int on, unsigned long msec);
+int wifi_get_mac_addr(unsigned char *buf);
+void *wifi_get_country_code(char *ccode);
+#else
+static int rtw_android_wifictrl_func_add(void)
+{
+	return 0;
+}
+static void rtw_android_wifictrl_func_del(void) {}
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+#ifdef CONFIG_GPIO_WAKEUP
+#ifdef CONFIG_PLATFORM_INTEL_BYT
+int wifi_configure_gpio(void);
+#endif /* CONFIG_PLATFORM_INTEL_BYT */
+void wifi_free_gpio(unsigned int gpio);
+#endif /* CONFIG_GPIO_WAKEUP */
+
+
+#endif /* __RTW_ANDROID_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_ap.h b/drivers/staging/rtl8188eu/include/rtw_ap.h
new file mode 100644
index 000000000000..ca95e2f14330
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ap.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_AP_H_
+#define __RTW_AP_H_
+
+
+#ifdef CONFIG_AP_MODE
+
+/* external function */
+extern void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta);
+extern void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta);
+
+
+void init_mlme_ap_info(_adapter *padapter);
+void free_mlme_ap_info(_adapter *padapter);
+/* void update_BCNTIM(_adapter *padapter); */
+void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
+void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
+void _update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx, const char *tag);
+#define update_beacon(adapter, ie_id, oui, tx) _update_beacon((adapter), (ie_id), (oui), (tx), __func__)
+void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level, u8 is_update_bw);
+void expire_timeout_chk(_adapter *padapter);
+void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
+void rtw_start_bss_hdl_after_chbw_decided(_adapter *adapter);
+void start_bss_network(_adapter *padapter, struct createbss_parm *parm);
+int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len);
+void rtw_ap_restore_network(_adapter *padapter);
+
+#if CONFIG_RTW_MACADDR_ACL
+void rtw_set_macaddr_acl(_adapter *adapter, int mode);
+int rtw_acl_add_sta(_adapter *adapter, const u8 *addr);
+int rtw_acl_remove_sta(_adapter *adapter, const u8 *addr);
+#endif /* CONFIG_RTW_MACADDR_ACL */
+
+u8 rtw_ap_set_pairwise_key(_adapter *padapter, struct sta_info *psta);
+int rtw_ap_set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid);
+int rtw_ap_set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid, u8 set_tx);
+
+#ifdef CONFIG_NATIVEAP_MLME
+void associated_clients_update(_adapter *padapter, u8 updated, u32 sta_info_type);
+void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
+u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
+void sta_info_update(_adapter *padapter, struct sta_info *psta);
+void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta);
+u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason, bool enqueue);
+int rtw_sta_flush(_adapter *padapter, bool enqueue);
+int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset);
+void start_ap_mode(_adapter *padapter);
+void stop_ap_mode(_adapter *padapter);
+#endif
+
+void rtw_ap_update_bss_chbw(_adapter *adapter, WLAN_BSSID_EX *bss, u8 ch, u8 bw, u8 offset);
+bool rtw_ap_chbw_decision(_adapter *adapter, s16 req_ch, s8 req_bw, s8 req_offset, u8 *ch, u8 *bw, u8 *offset, u8 *chbw_allow);
+
+#ifdef CONFIG_AUTO_AP_MODE
+extern void rtw_start_auto_ap(_adapter *adapter);
+#endif /* CONFIG_AUTO_AP_MODE */
+
+#endif /* end of CONFIG_AP_MODE */
+
+#endif
+void update_bmc_sta(_adapter *padapter);
+
+void rtw_process_ht_action_smps(_adapter *padapter, u8 *ta, u8 ctrl_field);
+void rtw_process_public_act_bsscoex(_adapter *padapter, u8 *pframe, uint frame_len);
+int rtw_ht_operation_update(_adapter *padapter);
+
+#ifdef CONFIG_SWTIMER_BASED_TXBCN
+void tx_beacon_handler(struct dvobj_priv *pdvobj);
+void tx_beacon_timer_handler(struct dvobj_priv *pdvobj);
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_beamforming.h b/drivers/staging/rtl8188eu/include/rtw_beamforming.h
new file mode 100644
index 000000000000..ea566d3d1827
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_beamforming.h
@@ -0,0 +1,374 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_BEAMFORMING_H_
+#define __RTW_BEAMFORMING_H_
+
+#ifdef CONFIG_BEAMFORMING
+
+#ifdef RTW_BEAMFORMING_VERSION_2
+#define MAX_NUM_BEAMFORMEE_SU	2
+#define MAX_NUM_BEAMFORMER_SU	2
+#define MAX_NUM_BEAMFORMEE_MU	6
+#define MAX_NUM_BEAMFORMER_MU	1
+
+#define MAX_BEAMFORMEE_ENTRY_NUM	(MAX_NUM_BEAMFORMEE_SU + MAX_NUM_BEAMFORMEE_MU)
+#define MAX_BEAMFORMER_ENTRY_NUM	(MAX_NUM_BEAMFORMER_SU + MAX_NUM_BEAMFORMER_MU)
+
+/* <Note> Need to be defined by IC */
+#define SU_SOUNDING_TIMEOUT	5	/* unit: ms */
+#define MU_SOUNDING_TIMEOUT	8	/* unit: ms */
+
+#define GET_BEAMFORM_INFO(adapter)	(&GET_HAL_DATA(adapter)->beamforming_info)
+#define GetInitSoundCnt(_SoundPeriod, _MinSoundPeriod)	((_SoundPeriod)/(_MinSoundPeriod))
+
+enum BEAMFORMING_CTRL_TYPE {
+	BEAMFORMING_CTRL_ENTER = 0,
+	BEAMFORMING_CTRL_LEAVE = 1,
+	BEAMFORMING_CTRL_START_PERIOD = 2,
+	BEAMFORMING_CTRL_END_PERIOD = 3,
+	BEAMFORMING_CTRL_SOUNDING_FAIL = 4,
+	BEAMFORMING_CTRL_SOUNDING_CLK = 5,
+	BEAMFORMING_CTRL_SET_GID_TABLE = 6,
+	BEAMFORMING_CTRL_SET_CSI_REPORT = 7,
+};
+
+enum _BEAMFORMING_STATE {
+	BEAMFORMING_STATE_IDLE,
+	BEAMFORMING_STATE_START,
+	BEAMFORMING_STATE_END,
+};
+
+/*
+ * typedef BEAMFORMING_CAP for phydm
+ */
+typedef enum beamforming_cap {
+	BEAMFORMING_CAP_NONE = 0x0,
+	BEAMFORMER_CAP_HT_EXPLICIT = 0x1,
+	BEAMFORMEE_CAP_HT_EXPLICIT = 0x2,
+	BEAMFORMER_CAP_VHT_SU = 0x4,			/* Self has er Cap, because Reg er  & peer ee */
+	BEAMFORMEE_CAP_VHT_SU = 0x8, 			/* Self has ee Cap, because Reg ee & peer er */
+	BEAMFORMER_CAP_VHT_MU = 0x10,			/* Self has er Cap, because Reg er & peer ee */
+	BEAMFORMEE_CAP_VHT_MU = 0x20,			/* Self has ee Cap, because Reg ee & peer er */
+	BEAMFORMER_CAP = 0x40,
+	BEAMFORMEE_CAP = 0x80,
+} BEAMFORMING_CAP;
+
+enum _BEAMFORM_ENTRY_HW_STATE {
+	BEAMFORM_ENTRY_HW_STATE_NONE,
+	BEAMFORM_ENTRY_HW_STATE_ADD_INIT,
+	BEAMFORM_ENTRY_HW_STATE_ADDING,
+	BEAMFORM_ENTRY_HW_STATE_ADDED,
+	BEAMFORM_ENTRY_HW_STATE_DELETE_INIT,
+	BEAMFORM_ENTRY_HW_STATE_DELETING,
+	BEAMFORM_ENTRY_HW_STATE_MAX
+};
+
+/* The sounding state is recorded by BFer. */
+enum _SOUNDING_STATE {
+	SOUNDING_STATE_NONE		= 0,
+	SOUNDING_STATE_INIT		= 1,
+	SOUNDING_STATE_SU_START		= 2,
+	SOUNDING_STATE_SU_SOUNDDOWN	= 3,
+	SOUNDING_STATE_MU_START		= 4,
+	SOUNDING_STATE_MU_SOUNDDOWN	= 5,
+	SOUNDING_STATE_SOUNDING_TIMEOUT	= 6,
+	SOUNDING_STATE_MAX
+};
+
+struct beamformee_entry {
+	u8 used;	/* true/false */
+	u8 txbf;
+	u8 sounding;
+	/* Used to construct AID field of NDPA packet */
+	u16 aid;
+	/* Used to Set Reg42C in IBSS mode */
+	u16 mac_id;
+	/* Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC */
+	u16 p_aid;
+	u8 g_id;
+	/* Used to fill Reg6E4 to fill Mac address of CSI report frame */
+	u8 mac_addr[ETH_ALEN];
+	/* Sounding BandWidth */
+	CHANNEL_WIDTH sound_bw;
+	u16 sound_period;
+
+	enum beamforming_cap cap;
+	enum _BEAMFORM_ENTRY_HW_STATE state;
+
+	/* The BFee need to be sounded when count to zero */
+	u8 SoundCnt;
+	u8 bCandidateSoundingPeer;
+	u8 bSoundingTimeout;
+	u8 bDeleteSounding;
+	/* Get the result through throughput and Tx rate from BB API */
+	u8 bApplySounding;
+
+	/* information for sounding judgement */
+	u32 tx_timestamp;
+	u64 tx_bytes;
+
+	u16 LogStatusFailCnt:5;	/* 0~21 */
+	u16 DefaultCSICnt:5; /* 0~21 */
+	u8 CSIMatrix[327];
+	u16 CSIMatrixLen;
+
+	u8 NumofSoundingDim;
+
+	u8 comp_steering_num_of_bfer;
+
+
+	/* SU-MIMO */
+	u8 su_reg_index;
+
+	/* MU-MIMO */
+	u8 mu_reg_index;
+	u8 gid_valid[8];
+	u8 user_position[16];
+
+	/* For 8822B C-cut workaround */
+	/* If the flag set to true, do not sound this STA */
+	u8 bSuspendSUCap;
+};
+
+struct beamformer_entry {
+	u8 used;
+	/* p_aid of BFer entry is probably not used */
+	/* Used to fill Reg42C & Reg714 to compare with p_aid of Tx DESC */
+	u16 p_aid;
+	u8 g_id;
+	u8 mac_addr[ETH_ALEN];
+
+	enum beamforming_cap cap;
+	enum _BEAMFORM_ENTRY_HW_STATE state;
+
+	u8 NumofSoundingDim;
+
+	/* SU-MIMO */
+	u8 su_reg_index;
+
+	/* MU-MIMO */
+	u8 gid_valid[8];
+	u8 user_position[16];
+	u16 aid;
+};
+
+struct sounding_info {
+	u8 su_sounding_list[MAX_NUM_BEAMFORMEE_SU];
+	u8 mu_sounding_list[MAX_NUM_BEAMFORMEE_MU];
+
+	enum _SOUNDING_STATE state;
+	/*
+	 * su_bfee_curidx is index for beamforming_info.bfee_entry[]
+	 * range: 0~MAX_BEAMFORMEE_ENTRY_NUM
+	 */
+	u8 su_bfee_curidx;
+	u8 candidate_mu_bfee_cnt;
+
+	/* For sounding schedule maintenance */
+	u16 min_sounding_period;
+	/* Get from sounding list */
+	/* Ex: SU STA1, SU STA2, MU STA(1~n) => the value will be 2+1=3 */
+	u8 sound_remain_cnt_per_period;
+};
+
+struct _RT_CSI_INFO{
+	u8 Nc;
+	u8 Nr;
+	u8 Ng;
+	u8 CodeBook;
+	u8 ChnlWidth;
+	u8 bVHT;
+};
+
+struct beamforming_info {
+	enum beamforming_cap beamforming_cap;
+	enum _BEAMFORMING_STATE beamforming_state;
+	struct beamformee_entry bfee_entry[MAX_BEAMFORMEE_ENTRY_NUM];
+	struct beamformer_entry bfer_entry[MAX_BEAMFORMER_ENTRY_NUM];
+	u8 sounding_sequence;
+	u8 beamformee_su_cnt;
+	u8 beamformer_su_cnt;
+	u32 beamformee_su_reg_maping;
+	u32 beamformer_su_reg_maping;
+	/* For MU-MINO */
+	u8 beamformee_mu_cnt;
+	u8 beamformer_mu_cnt;
+	u32 beamformee_mu_reg_maping;
+	u8 first_mu_bfee_index;
+	u8 mu_bfer_curidx;
+
+	struct sounding_info sounding_info;
+	/* schedule regular timer for sounding */
+	struct timer_list sounding_timer;
+	/* moniter if soudning too long */
+	struct timer_list sounding_timeout_timer;
+
+	/* For HW configuration */
+	u8 SetHalBFEnterOnDemandCnt;
+	u8 SetHalBFLeaveOnDemandCnt;
+	u8 SetHalSoundownOnDemandCnt;
+	u8 bSetBFHwConfigInProgess;
+
+	/*
+	 * Target CSI report info.
+	 * Keep the first SU CSI report info for 8822B HW bug workaround.
+	 */
+	u8 bEnableSUTxBFWorkAround;
+	struct _RT_CSI_INFO TargetCSIInfo;
+	/* Only peform sounding to the first SU BFee */
+	struct beamformee_entry *TargetSUBFee;
+
+	/* For debug */
+	s8 sounding_running;
+};
+
+enum beamforming_cap rtw_bf_bfee_get_entry_cap_by_macid(void *mlmepriv, u8 mac_id);
+struct beamformer_entry *rtw_bf_bfer_get_entry_by_addr(PADAPTER, u8 *ra);
+struct beamformee_entry *rtw_bf_bfee_get_entry_by_addr(PADAPTER, u8 *ra);
+void rtw_bf_get_ndpa_packet(PADAPTER, union recv_frame *);
+u32 rtw_bf_get_report_packet(PADAPTER, union recv_frame *);
+u8 rtw_bf_send_vht_gid_mgnt_packet(PADAPTER, u8 *ra, u8 *gid, u8 *position);
+void rtw_bf_get_vht_gid_mgnt_packet(PADAPTER, union recv_frame *);
+void rtw_bf_init(PADAPTER);
+void rtw_bf_cmd_hdl(PADAPTER, u8 type, u8 *pbuf);
+u8 rtw_bf_cmd(PADAPTER, s32 type, u8 *pbuf, s32 size, u8 enqueue);
+void rtw_bf_update_attrib(PADAPTER, struct pkt_attrib *, struct sta_info *);
+void rtw_bf_c2h_handler(PADAPTER, u8 id, u8 *buf, u8 buf_len);
+void rtw_bf_update_traffic(PADAPTER);
+
+/* Compatible with old function name, only for using outside rtw_beamforming.c */
+#define beamforming_get_entry_beam_cap_by_mac_id	rtw_bf_bfee_get_entry_cap_by_macid
+#define rtw_beamforming_get_ndpa_frame			rtw_bf_get_ndpa_packet
+#define rtw_beamforming_get_report_frame			rtw_bf_get_report_packet
+#define rtw_beamforming_get_vht_gid_mgnt_frame		rtw_bf_get_vht_gid_mgnt_packet
+#define beamforming_wk_hdl				rtw_bf_cmd_hdl
+#define beamforming_wk_cmd				rtw_bf_cmd
+#define update_attrib_txbf_info				rtw_bf_update_attrib
+
+#else /* !RTW_BEAMFORMING_VERSION_2 */
+
+#if (BEAMFORMING_SUPPORT == 0) /*for diver defined beamforming*/
+#define BEAMFORMING_ENTRY_NUM		2
+#define GET_BEAMFORM_INFO(_pmlmepriv)	((struct beamforming_info *)(&(_pmlmepriv)->beamforming_info))
+
+
+typedef enum _BEAMFORMING_ENTRY_STATE {
+	BEAMFORMING_ENTRY_STATE_UNINITIALIZE,
+	BEAMFORMING_ENTRY_STATE_INITIALIZEING,
+	BEAMFORMING_ENTRY_STATE_INITIALIZED,
+	BEAMFORMING_ENTRY_STATE_PROGRESSING,
+	BEAMFORMING_ENTRY_STATE_PROGRESSED,
+} BEAMFORMING_ENTRY_STATE, *PBEAMFORMING_ENTRY_STATE;
+
+
+typedef enum _BEAMFORMING_STATE {
+	BEAMFORMING_STATE_IDLE,
+	BEAMFORMING_STATE_START,
+	BEAMFORMING_STATE_END,
+} BEAMFORMING_STATE, *PBEAMFORMING_STATE;
+
+
+typedef enum _BEAMFORMING_CAP {
+	BEAMFORMING_CAP_NONE = 0x0,
+	BEAMFORMER_CAP_HT_EXPLICIT = 0x1,
+	BEAMFORMEE_CAP_HT_EXPLICIT = 0x2,
+	BEAMFORMER_CAP_VHT_SU = 0x4,			/* Self has er Cap, because Reg er  & peer ee */
+	BEAMFORMEE_CAP_VHT_SU = 0x8, 			/* Self has ee Cap, because Reg ee & peer er */
+	BEAMFORMER_CAP = 0x10,
+	BEAMFORMEE_CAP = 0x20,
+} BEAMFORMING_CAP, *PBEAMFORMING_CAP;
+
+
+typedef enum _SOUNDING_MODE {
+	SOUNDING_SW_VHT_TIMER = 0x0,
+	SOUNDING_SW_HT_TIMER = 0x1,
+	SOUNDING_STOP_All_TIMER = 0x2,
+	SOUNDING_HW_VHT_TIMER = 0x3,
+	SOUNDING_HW_HT_TIMER = 0x4,
+	SOUNDING_STOP_OID_TIMER = 0x5,
+	SOUNDING_AUTO_VHT_TIMER = 0x6,
+	SOUNDING_AUTO_HT_TIMER = 0x7,
+	SOUNDING_FW_VHT_TIMER = 0x8,
+	SOUNDING_FW_HT_TIMER = 0x9,
+} SOUNDING_MODE, *PSOUNDING_MODE;
+
+struct beamforming_entry {
+	bool	bUsed;
+	bool	bSound;
+	u16	aid;			/* Used to construct AID field of NDPA packet. */
+	u16	mac_id;		/* Used to Set Reg42C in IBSS mode. */
+	u16	p_aid;		/* Used to fill Reg42C & Reg714 to compare with P_AID of Tx DESC. */
+	u16 g_id;
+	u8	mac_addr[6];/* Used to fill Reg6E4 to fill Mac address of CSI report frame. */
+	CHANNEL_WIDTH	sound_bw;	/* Sounding BandWidth */
+	u16	sound_period;
+	BEAMFORMING_CAP	beamforming_entry_cap;
+	BEAMFORMING_ENTRY_STATE	beamforming_entry_state;
+	u8				ClockResetTimes;			/*Modified by Jeffery @2015-04-10*/
+	u8				PreLogSeq;				/*Modified by Jeffery @2015-03-30*/
+	u8				LogSeq;					/*Modified by Jeffery @2014-10-29*/
+	u16				LogRetryCnt:3;			/*Modified by Jeffery @2014-10-29*/
+	u16				LogSuccess:2;			/*Modified by Jeffery @2014-10-29*/
+
+	u8	LogStatusFailCnt;
+	u8	PreCsiReport[327];
+	u8	DefaultCsiCnt;
+	bool	bDefaultCSI;
+};
+
+struct sounding_info {
+	u8				sound_idx;
+	CHANNEL_WIDTH	sound_bw;
+	SOUNDING_MODE	sound_mode;
+	u16				sound_period;
+};
+
+struct beamforming_info {
+	BEAMFORMING_CAP		beamforming_cap;
+	BEAMFORMING_STATE		beamforming_state;
+	struct beamforming_entry	beamforming_entry[BEAMFORMING_ENTRY_NUM];
+	u8						beamforming_cur_idx;
+	u8						beamforming_in_progress;
+	u8						sounding_sequence;
+	struct sounding_info		sounding_info;
+};
+
+struct rtw_ndpa_sta_info {
+	u16	aid:12;
+	u16	feedback_type:1;
+	u16	nc_index:3;
+};
+
+BEAMFORMING_CAP beamforming_get_entry_beam_cap_by_mac_id(void * pmlmepriv , u8 mac_id);
+void	beamforming_notify(PADAPTER adapter);
+BEAMFORMING_CAP beamforming_get_beamform_cap(struct beamforming_info	*pBeamInfo);
+
+bool	beamforming_send_ht_ndpa_packet(PADAPTER Adapter, u8 *ra, CHANNEL_WIDTH bw, u8 qidx);
+bool	beamforming_send_vht_ndpa_packet(PADAPTER Adapter, u8 *ra, u16 aid, CHANNEL_WIDTH bw, u8 qidx);
+
+void	beamforming_check_sounding_success(PADAPTER Adapter, bool status);
+
+void	beamforming_watchdog(PADAPTER Adapter);
+#endif /*#if (BEAMFORMING_SUPPORT ==0)- for diver defined beamforming*/
+
+enum BEAMFORMING_CTRL_TYPE {
+	BEAMFORMING_CTRL_ENTER = 0,
+	BEAMFORMING_CTRL_LEAVE = 1,
+	BEAMFORMING_CTRL_START_PERIOD = 2,
+	BEAMFORMING_CTRL_END_PERIOD = 3,
+	BEAMFORMING_CTRL_SOUNDING_FAIL = 4,
+	BEAMFORMING_CTRL_SOUNDING_CLK = 5,
+};
+u32	rtw_beamforming_get_report_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);
+void	rtw_beamforming_get_ndpa_frame(PADAPTER	 Adapter, union recv_frame *precv_frame);
+
+void	beamforming_wk_hdl(_adapter *padapter, u8 type, u8 *pbuf);
+u8	beamforming_wk_cmd(_adapter *padapter, s32 type, u8 *pbuf, s32 size, u8 enqueue);
+void update_attrib_txbf_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+
+#endif /* !RTW_BEAMFORMING_VERSION_2 */
+
+#endif /*#ifdef CONFIG_BEAMFORMING */
+
+#endif /*__RTW_BEAMFORMING_H_*/
diff --git a/drivers/staging/rtl8188eu/include/rtw_br_ext.h b/drivers/staging/rtl8188eu/include/rtw_br_ext.h
new file mode 100644
index 000000000000..547bdb39f8da
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_br_ext.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_BR_EXT_H_
+#define _RTW_BR_EXT_H_
+
+#define CL_IPV6_PASS	1
+#define MACADDRLEN		6
+#define _DEBUG_ERR		RTW_INFO
+#define _DEBUG_INFO		/* RTW_INFO */
+#define DEBUG_WARN		RTW_INFO
+#define DEBUG_INFO		/* RTW_INFO */
+#define DEBUG_ERR		RTW_INFO
+/* #define GET_MY_HWADDR		((GET_MIB(priv))->dot11OperationEntry.hwaddr) */
+#define GET_MY_HWADDR(padapter)		(adapter_mac_addr(padapter))
+
+#define NAT25_HASH_BITS		4
+#define NAT25_HASH_SIZE		(1 << NAT25_HASH_BITS)
+#define NAT25_AGEING_TIME	300
+
+#ifdef CL_IPV6_PASS
+	#define MAX_NETWORK_ADDR_LEN	17
+#else
+	#define MAX_NETWORK_ADDR_LEN	11
+#endif
+
+struct nat25_network_db_entry {
+	struct nat25_network_db_entry	*next_hash;
+	struct nat25_network_db_entry	**pprev_hash;
+	atomic_t						use_count;
+	unsigned char					macAddr[6];
+	unsigned long					ageing_timer;
+	unsigned char				networkAddr[MAX_NETWORK_ADDR_LEN];
+};
+
+enum NAT25_METHOD {
+	NAT25_MIN,
+	NAT25_CHECK,
+	NAT25_INSERT,
+	NAT25_LOOKUP,
+	NAT25_PARSE,
+	NAT25_MAX
+};
+
+struct br_ext_info {
+	unsigned int	nat25_disable;
+	unsigned int	macclone_enable;
+	unsigned int	dhcp_bcst_disable;
+	int		addPPPoETag;		/* 1: Add PPPoE relay-SID, 0: disable */
+	unsigned char	nat25_dmzMac[MACADDRLEN];
+	unsigned int	nat25sc_disable;
+};
+
+void nat25_db_cleanup(_adapter *priv);
+
+#endif /* _RTW_BR_EXT_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_bt_mp.h b/drivers/staging/rtl8188eu/include/rtw_bt_mp.h
new file mode 100644
index 000000000000..e010a7e47014
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_bt_mp.h
@@ -0,0 +1,277 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef __RTW_BT_MP_H
+#define __RTW_BT_MP_H
+
+
+#if (MP_DRIVER == 1)
+
+#pragma pack(1)
+
+/* definition for BT_UP_OP_BT_READY */
+#define	MP_BT_NOT_READY						0
+#define	MP_BT_READY							1
+
+/* definition for BT_UP_OP_BT_SET_MODE */
+typedef enum _MP_BT_MODE {
+	MP_BT_MODE_RF_TXRX_TEST_MODE							= 0,
+	MP_BT_MODE_BT20_DUT_TEST_MODE							= 1,
+	MP_BT_MODE_BT40_DIRECT_TEST_MODE						= 2,
+	MP_BT_MODE_CONNECT_TEST_MODE							= 3,
+	MP_BT_MODE_MAX
+} MP_BT_MODE, *PMP_BT_MODE;
+
+
+/* definition for BT_UP_OP_BT_SET_TX_RX_PARAMETER */
+typedef struct _BT_TXRX_PARAMETERS {
+	u8		txrxChannel;
+	u32		txrxTxPktCnt;
+	u8		txrxTxPktInterval;
+	u8		txrxPayloadType;
+	u8		txrxPktType;
+	u16		txrxPayloadLen;
+	u32		txrxPktHeader;
+	u8		txrxWhitenCoeff;
+	u8		txrxBdaddr[6];
+	u8		txrxTxGainIndex;
+} BT_TXRX_PARAMETERS, *PBT_TXRX_PARAMETERS;
+
+/* txrxPktType */
+typedef enum _MP_BT_PKT_TYPE {
+	MP_BT_PKT_DH1							= 0,
+	MP_BT_PKT_DH3							= 1,
+	MP_BT_PKT_DH5							= 2,
+	MP_BT_PKT_2DH1							= 3,
+	MP_BT_PKT_2DH3							= 4,
+	MP_BT_PKT_2DH5							= 5,
+	MP_BT_PKT_3DH1							= 6,
+	MP_BT_PKT_3DH3							= 7,
+	MP_BT_PKT_3DH5							= 8,
+	MP_BT_PKT_LE							= 9,
+	MP_BT_PKT_MAX
+} MP_BT_PKT_TYPE, *PMP_BT_PKT_TYPE;
+/* txrxPayloadType */
+typedef enum _MP_BT_PAYLOAD_TYPE {
+	MP_BT_PAYLOAD_01010101					= 0,
+	MP_BT_PAYLOAD_ALL_1						= 1,
+	MP_BT_PAYLOAD_ALL_0						= 2,
+	MP_BT_PAYLOAD_11110000					= 3,
+	MP_BT_PAYLOAD_PRBS9						= 4,
+	MP_BT_PAYLOAD_MAX						= 8,
+} MP_BT_PAYLOAD_TYPE, *PMP_BT_PAYLOAD_TYPE;
+
+
+/* definition for BT_UP_OP_BT_TEST_CTRL */
+typedef enum _MP_BT_TEST_CTRL {
+	MP_BT_TEST_STOP_ALL_TESTS						= 0,
+	MP_BT_TEST_START_RX_TEST						= 1,
+	MP_BT_TEST_START_PACKET_TX_TEST					= 2,
+	MP_BT_TEST_START_CONTINUOUS_TX_TEST			= 3,
+	MP_BT_TEST_START_INQUIRY_SCAN_TEST				= 4,
+	MP_BT_TEST_START_PAGE_SCAN_TEST					= 5,
+	MP_BT_TEST_START_INQUIRY_PAGE_SCAN_TEST			= 6,
+	MP_BT_TEST_START_LEGACY_CONNECT_TEST			= 7,
+	MP_BT_TEST_START_LE_CONNECT_TEST_INITIATOR		= 8,
+	MP_BT_TEST_START_LE_CONNECT_TEST_ADVERTISER	= 9,
+	MP_BT_TEST_MAX
+} MP_BT_TEST_CTRL, *PMP_BT_TEST_CTRL;
+
+
+typedef enum _RTL_EXT_C2H_EVT {
+	EXT_C2H_WIFI_FW_ACTIVE_RSP = 0,
+	EXT_C2H_TRIG_BY_BT_FW = 1,
+	MAX_EXT_C2HEVENT
+} RTL_EXT_C2H_EVT;
+
+/* OP codes definition between the user layer and driver */
+typedef enum _BT_CTRL_OPCODE_UPPER {
+	BT_UP_OP_BT_READY										= 0x00,
+	BT_UP_OP_BT_SET_MODE									= 0x01,
+	BT_UP_OP_BT_SET_TX_RX_PARAMETER						= 0x02,
+	BT_UP_OP_BT_SET_GENERAL								= 0x03,
+	BT_UP_OP_BT_GET_GENERAL								= 0x04,
+	BT_UP_OP_BT_TEST_CTRL									= 0x05,
+	BT_UP_OP_TEST_BT										= 0x06,
+	BT_UP_OP_MAX
+} BT_CTRL_OPCODE_UPPER, *PBT_CTRL_OPCODE_UPPER;
+
+
+typedef enum _BT_SET_GENERAL {
+	BT_GSET_REG											= 0x00,
+	BT_GSET_RESET											= 0x01,
+	BT_GSET_TARGET_BD_ADDR									= 0x02,
+	BT_GSET_TX_PWR_FINETUNE								= 0x03,
+	BT_SET_TRACKING_INTERVAL								= 0x04,
+	BT_SET_THERMAL_METER									= 0x05,
+	BT_ENABLE_CFO_TRACKING									= 0x06,
+	BT_GSET_UPDATE_BT_PATCH								= 0x07,
+	BT_GSET_MAX
+} BT_SET_GENERAL, *PBT_SET_GENERAL;
+
+typedef enum _BT_GET_GENERAL {
+	BT_GGET_REG											= 0x00,
+	BT_GGET_STATUS											= 0x01,
+	BT_GGET_REPORT											= 0x02,
+	BT_GGET_AFH_MAP										= 0x03,
+	BT_GGET_AFH_STATUS										= 0x04,
+	BT_GGET_MAX
+} BT_GET_GENERAL, *PBT_GET_GENERAL;
+
+/* definition for BT_UP_OP_BT_SET_GENERAL */
+typedef enum _BT_REG_TYPE {
+	BT_REG_RF								= 0,
+	BT_REG_MODEM							= 1,
+	BT_REG_BLUEWIZE						= 2,
+	BT_REG_VENDOR							= 3,
+	BT_REG_LE								= 4,
+	BT_REG_MAX
+} BT_REG_TYPE, *PBT_REG_TYPE;
+
+/* definition for BT_LO_OP_GET_AFH_MAP */
+typedef enum _BT_AFH_MAP_TYPE {
+	BT_AFH_MAP_RESULT						= 0,
+	BT_AFH_MAP_WIFI_PSD_ONLY				= 1,
+	BT_AFH_MAP_WIFI_CH_BW_ONLY				= 2,
+	BT_AFH_MAP_BT_PSD_ONLY					= 3,
+	BT_AFH_MAP_HOST_CLASSIFICATION_ONLY	= 4,
+	BT_AFH_MAP_MAX
+} BT_AFH_MAP_TYPE, *PBT_AFH_MAP_TYPE;
+
+/* definition for BT_UP_OP_BT_GET_GENERAL */
+typedef enum _BT_REPORT_TYPE {
+	BT_REPORT_RX_PACKET_CNT				= 0,
+	BT_REPORT_RX_ERROR_BITS				= 1,
+	BT_REPORT_RSSI							= 2,
+	BT_REPORT_CFO_HDR_QUALITY				= 3,
+	BT_REPORT_CONNECT_TARGET_BD_ADDR		= 4,
+	BT_REPORT_MAX
+} BT_REPORT_TYPE, *PBT_REPORT_TYPE;
+
+void
+MPTBT_Test(
+	IN	PADAPTER	Adapter,
+	IN	u8		opCode,
+	IN	u8		byte1,
+	IN	u8		byte2,
+	IN	u8		byte3
+);
+
+NDIS_STATUS
+MPTBT_SendOidBT(
+	IN	PADAPTER		pAdapter,
+	IN	void *			InformationBuffer,
+	IN	u32			InformationBufferLength,
+	OUT	u32 *			BytesRead,
+	OUT	u32 *			BytesNeeded
+);
+
+void
+MPTBT_FwC2hBtMpCtrl(
+	PADAPTER	Adapter,
+	u8 *	tmpBuf,
+	u8		length
+);
+
+void MPh2c_timeout_handle(void *FunctionContext);
+
+void mptbt_BtControlProcess(
+	PADAPTER	Adapter,
+	void *		pInBuf
+);
+
+#define	BT_H2C_MAX_RETRY								1
+#define	BT_MAX_C2H_LEN								20
+
+typedef struct _BT_REQ_CMD {
+	u8       opCodeVer;
+	u8       OpCode;
+	u16      paraLength;
+	u8       pParamStart[100];
+} BT_REQ_CMD, *PBT_REQ_CMD;
+
+typedef struct _BT_RSP_CMD {
+	u16      status;
+	u16      paraLength;
+	u8       pParamStart[100];
+} BT_RSP_CMD, *PBT_RSP_CMD;
+
+
+typedef struct _BT_H2C {
+	u8	opCodeVer:4;
+	u8	reqNum:4;
+	u8	opCode;
+	u8	buf[100];
+} BT_H2C, *PBT_H2C;
+
+
+
+typedef struct _BT_EXT_C2H {
+	u8	extendId;
+	u8	statusCode:4;
+	u8	retLen:4;
+	u8	opCodeVer:4;
+	u8	reqNum:4;
+	u8	buf[100];
+} BT_EXT_C2H, *PBT_EXT_C2H;
+
+
+typedef enum _BT_OPCODE_STATUS {
+	BT_OP_STATUS_SUCCESS									= 0x00, /* Success */
+	BT_OP_STATUS_VERSION_MISMATCH							= 0x01,
+	BT_OP_STATUS_UNKNOWN_OPCODE								= 0x02,
+	BT_OP_STATUS_ERROR_PARAMETER							= 0x03,
+	BT_OP_STATUS_MAX
+} BT_OPCODE_STATUS, *PBT_OPCODE_STATUS;
+
+
+
+/* OP codes definition between driver and bt fw */
+typedef enum _BT_CTRL_OPCODE_LOWER {
+	BT_LO_OP_GET_BT_VERSION									= 0x00,
+	BT_LO_OP_RESET												= 0x01,
+	BT_LO_OP_TEST_CTRL											= 0x02,
+	BT_LO_OP_SET_BT_MODE										= 0x03,
+	BT_LO_OP_SET_CHNL_TX_GAIN									= 0x04,
+	BT_LO_OP_SET_PKT_TYPE_LEN									= 0x05,
+	BT_LO_OP_SET_PKT_CNT_L_PL_TYPE								= 0x06,
+	BT_LO_OP_SET_PKT_CNT_H_PKT_INTV							= 0x07,
+	BT_LO_OP_SET_PKT_HEADER									= 0x08,
+	BT_LO_OP_SET_WHITENCOEFF									= 0x09,
+	BT_LO_OP_SET_BD_ADDR_L										= 0x0a,
+	BT_LO_OP_SET_BD_ADDR_H										= 0x0b,
+	BT_LO_OP_WRITE_REG_ADDR									= 0x0c,
+	BT_LO_OP_WRITE_REG_VALUE									= 0x0d,
+	BT_LO_OP_GET_BT_STATUS										= 0x0e,
+	BT_LO_OP_GET_BD_ADDR_L										= 0x0f,
+	BT_LO_OP_GET_BD_ADDR_H										= 0x10,
+	BT_LO_OP_READ_REG											= 0x11,
+	BT_LO_OP_SET_TARGET_BD_ADDR_L								= 0x12,
+	BT_LO_OP_SET_TARGET_BD_ADDR_H								= 0x13,
+	BT_LO_OP_SET_TX_POWER_CALIBRATION							= 0x14,
+	BT_LO_OP_GET_RX_PKT_CNT_L									= 0x15,
+	BT_LO_OP_GET_RX_PKT_CNT_H									= 0x16,
+	BT_LO_OP_GET_RX_ERROR_BITS_L								= 0x17,
+	BT_LO_OP_GET_RX_ERROR_BITS_H								= 0x18,
+	BT_LO_OP_GET_RSSI											= 0x19,
+	BT_LO_OP_GET_CFO_HDR_QUALITY_L								= 0x1a,
+	BT_LO_OP_GET_CFO_HDR_QUALITY_H								= 0x1b,
+	BT_LO_OP_GET_TARGET_BD_ADDR_L								= 0x1c,
+	BT_LO_OP_GET_TARGET_BD_ADDR_H								= 0x1d,
+	BT_LO_OP_GET_AFH_MAP_L										= 0x1e,
+	BT_LO_OP_GET_AFH_MAP_M										= 0x1f,
+	BT_LO_OP_GET_AFH_MAP_H										= 0x20,
+	BT_LO_OP_GET_AFH_STATUS									= 0x21,
+	BT_LO_OP_SET_TRACKING_INTERVAL								= 0x22,
+	BT_LO_OP_SET_THERMAL_METER									= 0x23,
+	BT_LO_OP_ENABLE_CFO_TRACKING								= 0x24,
+	BT_LO_OP_MAX
+} BT_CTRL_OPCODE_LOWER, *PBT_CTRL_OPCODE_LOWER;
+
+
+
+
+#endif  /* #if(MP_DRIVER == 1) */
+
+#endif /*  #ifndef __INC_MPT_BT_H */
diff --git a/drivers/staging/rtl8188eu/include/rtw_btcoex.h b/drivers/staging/rtl8188eu/include/rtw_btcoex.h
new file mode 100644
index 000000000000..fb30add726e5
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_btcoex.h
@@ -0,0 +1,428 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_BTCOEX_H__
+#define __RTW_BTCOEX_H__
+
+#include <drv_types.h>
+
+/* For H2C: H2C_BT_MP_OPER. Return status definition to the user layer */
+typedef enum _BT_CTRL_STATUS {
+	BT_STATUS_SUCCESS								= 0x00, /* Success */
+	BT_STATUS_BT_OP_SUCCESS							= 0x01, /* bt fw op execution success */
+	BT_STATUS_H2C_SUCCESS							= 0x02, /* H2c success */
+	BT_STATUS_H2C_FAIL								= 0x03, /* H2c fail */
+	BT_STATUS_H2C_LENGTH_EXCEEDED					= 0x04, /* H2c command length exceeded */
+	BT_STATUS_H2C_TIMTOUT							= 0x05, /* H2c timeout */
+	BT_STATUS_H2C_BT_NO_RSP							= 0x06, /* H2c sent, bt no rsp */
+	BT_STATUS_C2H_SUCCESS							= 0x07, /* C2h success */
+	BT_STATUS_C2H_REQNUM_MISMATCH					= 0x08, /* bt fw wrong rsp */
+	BT_STATUS_OPCODE_U_VERSION_MISMATCH				= 0x08, /* Upper layer OP code version mismatch. */
+	BT_STATUS_OPCODE_L_VERSION_MISMATCH				= 0x0a, /* Lower layer OP code version mismatch. */
+	BT_STATUS_UNKNOWN_OPCODE_U						= 0x0b, /* Unknown Upper layer OP code */
+	BT_STATUS_UNKNOWN_OPCODE_L						= 0x0c, /* Unknown Lower layer OP code */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_U				= 0x0d, /* Wrong parameters sent by upper layer. */
+	BT_STATUS_PARAMETER_FORMAT_ERROR_L				= 0x0e, /* bt fw parameter format is not consistency */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_U				= 0x0f, /* uppery layer parameter value is out of range */
+	BT_STATUS_PARAMETER_OUT_OF_RANGE_L				= 0x10, /* bt fw parameter value is out of range */
+	BT_STATUS_UNKNOWN_STATUS_L						= 0x11, /* bt returned an defined status code */
+	BT_STATUS_UNKNOWN_STATUS_H						= 0x12, /* driver need to do error handle or not handle-well. */
+	BT_STATUS_WRONG_LEVEL							= 0x13, /* should be under passive level */
+	BT_STATUS_NOT_IMPLEMENT						= 0x14, /* op code not implemented yet */
+	BT_STATUS_BT_STACK_OP_SUCCESS					= 0x15, /* bt stack op execution success */
+	BT_STATUS_BT_STACK_NOT_SUPPORT					= 0x16, /* stack version not support this. */
+	BT_STATUS_BT_STACK_SEND_HCI_EVENT_FAIL			= 0x17, /* send hci event fail */
+	BT_STATUS_BT_STACK_NOT_BIND						= 0x18, /* stack not bind wifi driver */
+	BT_STATUS_BT_STACK_NO_RSP						= 0x19, /* stack doesn't have any rsp. */
+	BT_STATUS_MAX
+} BT_CTRL_STATUS, *PBT_CTRL_STATUS;
+
+typedef enum _BTCOEX_SUSPEND_STATE {
+	BTCOEX_SUSPEND_STATE_RESUME					= 0x0,
+	BTCOEX_SUSPEND_STATE_SUSPEND				= 0x1,
+	BTCOEX_SUSPEND_STATE_SUSPEND_KEEP_ANT		= 0x2,
+	BTCOEX_SUSPEND_STATE_MAX
+} BTCOEX_SUSPEND_STATE, *PBTCOEX_SUSPEND_STATE;
+
+#define SET_BT_MP_OPER_RET(OpCode, StatusCode)						((OpCode << 8) | StatusCode)
+#define GET_OP_CODE_FROM_BT_MP_OPER_RET(RetCode)					((RetCode & 0xF0) >> 8)
+#define GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode)				(RetCode & 0x0F)
+#define CHECK_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode, StatusCode)	(GET_STATUS_CODE_FROM_BT_MP_OPER_RET(RetCode) == StatusCode)
+
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+
+#define NETLINK_USER 31
+#define CONNECT_PORT 30000
+#define CONNECT_PORT_BT 30001
+#define KERNEL_SOCKET_OK 0x01
+#define NETLINK_SOCKET_OK 0x02
+
+#define OTHER 0
+#define RX_ATTEND_ACK 1
+#define RX_LEAVE_ACK 2
+#define RX_BT_LEAVE 3
+#define RX_INVITE_REQ 4
+#define RX_ATTEND_REQ 5
+#define RX_INVITE_RSP 6
+
+#define invite_req "INVITE_REQ"
+#define invite_rsp "INVITE_RSP"
+#define attend_req "ATTEND_REQ"
+#define attend_ack "ATTEND_ACK"
+#define wifi_leave "WIFI_LEAVE"
+#define leave_ack "LEAVE_ACK"
+#define bt_leave "BT_LEAVE"
+
+#define BT_INFO_NOTIFY_CMD 0x0106
+#define BT_INFO_LEN 8
+
+typedef struct _HCI_LINK_INFO {
+	u16					ConnectHandle;
+	u8					IncomingTrafficMode;
+	u8					OutgoingTrafficMode;
+	u8					BTProfile;
+	u8					BTCoreSpec;
+	s1Byte					BT_RSSI;
+	u8					TrafficProfile;
+	u8					linkRole;
+} HCI_LINK_INFO, *PHCI_LINK_INFO;
+
+#define	MAX_BT_ACL_LINK_NUM				8
+
+typedef struct _HCI_EXT_CONFIG {
+	HCI_LINK_INFO				aclLink[MAX_BT_ACL_LINK_NUM];
+	u8					btOperationCode;
+	u16					CurrentConnectHandle;
+	u8					CurrentIncomingTrafficMode;
+	u8					CurrentOutgoingTrafficMode;
+
+	u8					NumberOfACL;
+	u8					NumberOfSCO;
+	u8					CurrentBTStatus;
+	u16					HCIExtensionVer;
+
+	bool					bEnableWifiScanNotify;
+} HCI_EXT_CONFIG, *PHCI_EXT_CONFIG;
+
+typedef struct _HCI_PHY_LINK_BSS_INFO {
+	u16						bdCap;			/* capability information */
+
+	/* Qos related. Added by Annie, 2005-11-01. */
+	/* BSS_QOS						BssQos;		 */
+
+} HCI_PHY_LINK_BSS_INFO, *PHCI_PHY_LINK_BSS_INFO;
+
+typedef enum _BT_CONNECT_TYPE {
+	BT_CONNECT_AUTH_REQ								= 0x00,
+	BT_CONNECT_AUTH_RSP								= 0x01,
+	BT_CONNECT_ASOC_REQ								= 0x02,
+	BT_CONNECT_ASOC_RSP								= 0x03,
+	BT_DISCONNECT										= 0x04
+} BT_CONNECT_TYPE, *PBT_CONNECT_TYPE;
+
+
+typedef struct _PACKET_IRP_HCIEVENT_DATA {
+	u8		EventCode;
+	u8		Length; /* total cmd length = extension event length+1(extension event code length) */
+	u8		Data[1]; /* byte1 is extension event code */
+} rtw_HCI_event;
+
+
+struct btinfo_8761ATV {
+	u8 cid;
+	u8 len;
+
+	u8 bConnection:1;
+	u8 bSCOeSCO:1;
+	u8 bInQPage:1;
+	u8 bACLBusy:1;
+	u8 bSCOBusy:1;
+	u8 bHID:1;
+	u8 bA2DP:1;
+	u8 bFTP:1;
+
+	u8 retry_cnt:4;
+	u8 rsvd_34:1;
+	u8 bPage:1;
+	u8 TRxMask:1;
+	u8 Sniff_attempt:1;
+
+	u8 rssi;
+
+	u8 A2dp_rate:1;
+	u8 ReInit:1;
+	u8 MaxPower:1;
+	u8 bEnIgnoreWlanAct:1;
+	u8 TxPowerLow:1;
+	u8 TxPowerHigh:1;
+	u8 eSCO_SCO:1;
+	u8 Master_Slave:1;
+
+	u8 ACL_TRx_TP_low;
+	u8 ACL_TRx_TP_high;
+};
+
+#define HCIOPCODE(_OCF, _OGF)     ((_OGF)<<10|(_OCF))
+#define HCIOPCODELOW(_OCF, _OGF)	(u8)(HCIOPCODE(_OCF, _OGF) & 0x00ff)
+#define HCIOPCODEHIGHT(_OCF, _OGF) (u8)(HCIOPCODE(_OCF, _OGF)>>8)
+#define HCI_OGF(opCode)  (unsigned char)((0xFC00 & (opCode)) >> 10)
+#define HCI_OCF(opCode)  (0x3FF & (opCode))
+
+
+typedef enum _HCI_STATUS {
+	HCI_STATUS_SUCCESS										= 0x00, /* Success */
+	HCI_STATUS_UNKNOW_HCI_CMD								= 0x01, /* Unknown HCI Command */
+	HCI_STATUS_UNKNOW_CONNECT_ID							= 0X02, /* Unknown Connection Identifier */
+	HCI_STATUS_HW_FAIL										= 0X03, /* Hardware Failure */
+	HCI_STATUS_PAGE_TIMEOUT									= 0X04, /* Page Timeout */
+	HCI_STATUS_AUTH_FAIL										= 0X05, /* Authentication Failure */
+	HCI_STATUS_PIN_OR_KEY_MISSING							= 0X06, /* PIN or Key Missing */
+	HCI_STATUS_MEM_CAP_EXCEED								= 0X07, /* Memory Capacity Exceeded */
+	HCI_STATUS_CONNECT_TIMEOUT								= 0X08, /* Connection Timeout */
+	HCI_STATUS_CONNECT_LIMIT									= 0X09, /* Connection Limit Exceeded */
+	HCI_STATUS_SYN_CONNECT_LIMIT								= 0X0a, /* Synchronous Connection Limit To A Device Exceeded */
+	HCI_STATUS_ACL_CONNECT_EXISTS							= 0X0b, /* ACL Connection Already Exists */
+	HCI_STATUS_CMD_DISALLOW									= 0X0c, /* Command Disallowed */
+	HCI_STATUS_CONNECT_RJT_LIMIT_RESOURCE					= 0X0d, /* Connection Rejected due to Limited Resources */
+	HCI_STATUS_CONNECT_RJT_SEC_REASON						= 0X0e, /* Connection Rejected Due To Security Reasons */
+	HCI_STATUS_CONNECT_RJT_UNACCEPT_BD_ADDR				= 0X0f, /* Connection Rejected due to Unacceptable BD_ADDR */
+	HCI_STATUS_CONNECT_ACCEPT_TIMEOUT						= 0X10, /* Connection Accept Timeout Exceeded */
+	HCI_STATUS_UNSUPPORT_FEATURE_PARA_VALUE				= 0X11, /* Unsupported Feature or Parameter Value */
+	HCI_STATUS_INVALID_HCI_CMD_PARA_VALUE					= 0X12, /* Invalid HCI Command Parameters */
+	HCI_STATUS_REMOTE_USER_TERMINATE_CONNECT				= 0X13, /* Remote User Terminated Connection */
+	HCI_STATUS_REMOTE_DEV_TERMINATE_LOW_RESOURCE			= 0X14, /* Remote Device Terminated Connection due to Low Resources */
+	HCI_STATUS_REMOTE_DEV_TERMINATE_CONNECT_POWER_OFF	= 0X15, /* Remote Device Terminated Connection due to Power Off */
+	HCI_STATUS_CONNECT_TERMINATE_LOCAL_HOST				= 0X16, /* Connection Terminated By Local Host */
+	HCI_STATUS_REPEATE_ATTEMPT								= 0X17, /* Repeated Attempts */
+	HCI_STATUS_PAIR_NOT_ALLOW								= 0X18, /* Pairing Not Allowed */
+	HCI_STATUS_UNKNOW_LMP_PDU								= 0X19, /* Unknown LMP PDU */
+	HCI_STATUS_UNSUPPORT_REMOTE_LMP_FEATURE				= 0X1a, /* Unsupported Remote Feature / Unsupported LMP Feature */
+	HCI_STATUS_SOC_OFFSET_REJECT								= 0X1b, /* SCO Offset Rejected */
+	HCI_STATUS_SOC_INTERVAL_REJECT							= 0X1c, /* SCO Interval Rejected */
+	HCI_STATUS_SOC_AIR_MODE_REJECT							= 0X1d, /* SCO Air Mode Rejected */
+	HCI_STATUS_INVALID_LMP_PARA								= 0X1e, /* Invalid LMP Parameters */
+	HCI_STATUS_UNSPECIFIC_ERROR								= 0X1f, /* Unspecified Error */
+	HCI_STATUS_UNSUPPORT_LMP_PARA_VALUE					= 0X20, /* Unsupported LMP Parameter Value */
+	HCI_STATUS_ROLE_CHANGE_NOT_ALLOW						= 0X21, /* Role Change Not Allowed */
+	HCI_STATUS_LMP_RESPONSE_TIMEOUT							= 0X22, /* LMP Response Timeout */
+	HCI_STATUS_LMP_ERROR_TRANSACTION_COLLISION				= 0X23, /* LMP Error Transaction Collision */
+	HCI_STATUS_LMP_PDU_NOT_ALLOW							= 0X24, /* LMP PDU Not Allowed */
+	HCI_STATUS_ENCRYPTION_MODE_NOT_ALLOW					= 0X25, /* Encryption Mode Not Acceptable */
+	HCI_STATUS_LINK_KEY_CAN_NOT_CHANGE						= 0X26, /* Link Key Can Not be Changed */
+	HCI_STATUS_REQUEST_QOS_NOT_SUPPORT						= 0X27, /* Requested QoS Not Supported */
+	HCI_STATUS_INSTANT_PASSED								= 0X28, /* Instant Passed */
+	HCI_STATUS_PAIRING_UNIT_KEY_NOT_SUPPORT					= 0X29, /* Pairing With Unit Key Not Supported */
+	HCI_STATUS_DIFFERENT_TRANSACTION_COLLISION				= 0X2a, /* Different Transaction Collision */
+	HCI_STATUS_RESERVE_1										= 0X2b, /* Reserved */
+	HCI_STATUS_QOS_UNACCEPT_PARA							= 0X2c, /* QoS Unacceptable Parameter */
+	HCI_STATUS_QOS_REJECT										= 0X2d, /* QoS Rejected */
+	HCI_STATUS_CHNL_CLASSIFICATION_NOT_SUPPORT				= 0X2e, /* Channel Classification Not Supported */
+	HCI_STATUS_INSUFFICIENT_SECURITY							= 0X2f, /* Insufficient Security */
+	HCI_STATUS_PARA_OUT_OF_RANGE							= 0x30, /* Parameter Out Of Mandatory Range */
+	HCI_STATUS_RESERVE_2										= 0X31, /* Reserved */
+	HCI_STATUS_ROLE_SWITCH_PENDING							= 0X32, /* Role Switch Pending */
+	HCI_STATUS_RESERVE_3										= 0X33, /* Reserved */
+	HCI_STATUS_RESERVE_SOLT_VIOLATION						= 0X34, /* Reserved Slot Violation */
+	HCI_STATUS_ROLE_SWITCH_FAIL								= 0X35, /* Role Switch Failed */
+	HCI_STATUS_EXTEND_INQUIRY_RSP_TOO_LARGE				= 0X36, /* Extended Inquiry Response Too Large */
+	HCI_STATUS_SEC_SIMPLE_PAIRING_NOT_SUPPORT				= 0X37, /* Secure Simple Pairing Not Supported By Host. */
+	HCI_STATUS_HOST_BUSY_PAIRING								= 0X38, /* Host Busy - Pairing */
+	HCI_STATUS_CONNECT_REJ_NOT_SUIT_CHNL_FOUND			= 0X39, /* Connection Rejected due to No Suitable Channel Found */
+	HCI_STATUS_CONTROLLER_BUSY								= 0X3a /* CONTROLLER BUSY */
+} RTW_HCI_STATUS;
+
+#define HCI_EVENT_COMMAND_COMPLETE					0x0e
+
+#define OGF_EXTENSION									0X3f
+typedef enum HCI_EXTENSION_COMMANDS {
+	HCI_SET_ACL_LINK_DATA_FLOW_MODE				= 0x0010,
+	HCI_SET_ACL_LINK_STATUS							= 0x0020,
+	HCI_SET_SCO_LINK_STATUS							= 0x0030,
+	HCI_SET_RSSI_VALUE								= 0x0040,
+	HCI_SET_CURRENT_BLUETOOTH_STATUS				= 0x0041,
+
+	/* The following is for RTK8723 */
+	HCI_EXTENSION_VERSION_NOTIFY					= 0x0100,
+	HCI_LINK_STATUS_NOTIFY							= 0x0101,
+	HCI_BT_OPERATION_NOTIFY							= 0x0102,
+	HCI_ENABLE_WIFI_SCAN_NOTIFY						= 0x0103,
+	HCI_QUERY_RF_STATUS								= 0x0104,
+	HCI_BT_ABNORMAL_NOTIFY							= 0x0105,
+	HCI_BT_INFO_NOTIFY								= 0x0106,
+	HCI_BT_COEX_NOTIFY								= 0x0107,
+	HCI_BT_PATCH_VERSION_NOTIFY						= 0x0108,
+	HCI_BT_AFH_MAP_NOTIFY							= 0x0109,
+	HCI_BT_REGISTER_VALUE_NOTIFY					= 0x010a,
+
+	/* The following is for IVT */
+	HCI_WIFI_CURRENT_CHANNEL						= 0x0300,
+	HCI_WIFI_CURRENT_BANDWIDTH						= 0x0301,
+	HCI_WIFI_CONNECTION_STATUS						= 0x0302
+} RTW_HCI_EXT_CMD;
+
+#define HCI_EVENT_EXTENSION_RTK						0xfe
+typedef enum HCI_EXTENSION_EVENT_RTK {
+	HCI_EVENT_EXT_WIFI_SCAN_NOTIFY								= 0x01,
+	HCI_EVENT_EXT_WIFI_RF_STATUS_NOTIFY						= 0x02,
+	HCI_EVENT_EXT_BT_INFO_CONTROL								= 0x03,
+	HCI_EVENT_EXT_BT_COEX_CONTROL								= 0x04
+} RTW_HCI_EXT_EVENT;
+
+typedef enum _BT_TRAFFIC_MODE {
+	BT_MOTOR_EXT_BE		= 0x00, /* Best Effort. Default. for HCRP, PAN, SDP, RFCOMM-based profiles like FTP,OPP, SPP, DUN, etc. */
+	BT_MOTOR_EXT_GUL		= 0x01, /* Guaranteed Latency. This type of traffic is used e.g. for HID and AVRCP. */
+	BT_MOTOR_EXT_GUB		= 0X02, /* Guaranteed Bandwidth. */
+	BT_MOTOR_EXT_GULB	= 0X03  /* Guaranteed Latency and Bandwidth. for A2DP and VDP. */
+} BT_TRAFFIC_MODE;
+
+typedef enum _BT_TRAFFIC_MODE_PROFILE {
+	BT_PROFILE_NONE,
+	BT_PROFILE_A2DP,
+	BT_PROFILE_PAN	,
+	BT_PROFILE_HID,
+	BT_PROFILE_SCO
+} BT_TRAFFIC_MODE_PROFILE;
+
+typedef enum _HCI_EXT_BT_OPERATION {
+	HCI_BT_OP_NONE				= 0x0,
+	HCI_BT_OP_INQUIRY_START		= 0x1,
+	HCI_BT_OP_INQUIRY_FINISH		= 0x2,
+	HCI_BT_OP_PAGING_START		= 0x3,
+	HCI_BT_OP_PAGING_SUCCESS		= 0x4,
+	HCI_BT_OP_PAGING_UNSUCCESS	= 0x5,
+	HCI_BT_OP_PAIRING_START		= 0x6,
+	HCI_BT_OP_PAIRING_FINISH		= 0x7,
+	HCI_BT_OP_BT_DEV_ENABLE		= 0x8,
+	HCI_BT_OP_BT_DEV_DISABLE		= 0x9,
+	HCI_BT_OP_MAX
+} HCI_EXT_BT_OPERATION, *PHCI_EXT_BT_OPERATION;
+
+typedef struct _BT_MGNT {
+	bool				bBTConnectInProgress;
+	bool				bLogLinkInProgress;
+	bool				bPhyLinkInProgress;
+	bool				bPhyLinkInProgressStartLL;
+	u8				BtCurrentPhyLinkhandle;
+	u16				BtCurrentLogLinkhandle;
+	u8				CurrentConnectEntryNum;
+	u8				DisconnectEntryNum;
+	u8				CurrentBTConnectionCnt;
+	BT_CONNECT_TYPE		BTCurrentConnectType;
+	BT_CONNECT_TYPE		BTReceiveConnectPkt;
+	u8				BTAuthCount;
+	u8				BTAsocCount;
+	bool				bStartSendSupervisionPkt;
+	bool				BtOperationOn;
+	bool				BTNeedAMPStatusChg;
+	bool				JoinerNeedSendAuth;
+	HCI_PHY_LINK_BSS_INFO	bssDesc;
+	HCI_EXT_CONFIG		ExtConfig;
+	bool				bNeedNotifyAMPNoCap;
+	bool				bCreateSpportQos;
+	bool				bSupportProfile;
+	u8				BTChannel;
+	bool				CheckChnlIsSuit;
+	bool				bBtScan;
+	bool				btLogoTest;
+	bool				bRfStatusNotified;
+	bool				bBtRsvedPageDownload;
+} BT_MGNT, *PBT_MGNT;
+
+struct bt_coex_info {
+	/* For Kernel Socket */
+	struct socket *udpsock;
+	struct sockaddr_in wifi_sockaddr; /*wifi socket*/
+	struct sockaddr_in bt_sockaddr;/* BT socket */
+	struct sock *sk_store;/*back up socket for UDP RX int*/
+
+	/* store which socket is OK */
+	u8 sock_open;
+
+	u8 BT_attend;
+	u8 is_exist; /* socket exist */
+	BT_MGNT BtMgnt;
+	struct workqueue_struct *btcoex_wq;
+	struct delayed_work recvmsg_work;
+};
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+
+#define	PACKET_NORMAL			0
+#define	PACKET_DHCP				1
+#define	PACKET_ARP				2
+#define	PACKET_EAPOL			3
+
+void rtw_btcoex_Initialize(PADAPTER);
+void rtw_btcoex_PowerOnSetting(PADAPTER padapter);
+void rtw_btcoex_PreLoadFirmware(PADAPTER padapter);
+void rtw_btcoex_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly);
+void rtw_btcoex_IpsNotify(PADAPTER, u8 type);
+void rtw_btcoex_LpsNotify(PADAPTER, u8 type);
+void rtw_btcoex_ScanNotify(PADAPTER, u8 type);
+void rtw_btcoex_ConnectNotify(PADAPTER, u8 action);
+void rtw_btcoex_MediaStatusNotify(PADAPTER, u8 mediaStatus);
+void rtw_btcoex_SpecialPacketNotify(PADAPTER, u8 pktType);
+void rtw_btcoex_IQKNotify(PADAPTER padapter, u8 state);
+void rtw_btcoex_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
+void rtw_btcoex_BtMpRptNotify(PADAPTER, u8 length, u8 *tmpBuf);
+void rtw_btcoex_SuspendNotify(PADAPTER, u8 state);
+void rtw_btcoex_HaltNotify(PADAPTER);
+void rtw_btcoex_switchband_notify(u8 under_scan, u8 band_type);
+void rtw_btcoex_SwitchBtTRxMask(PADAPTER);
+void rtw_btcoex_Switch(PADAPTER, u8 enable);
+u8 rtw_btcoex_IsBtDisabled(PADAPTER);
+void rtw_btcoex_Handler(PADAPTER);
+s32 rtw_btcoex_IsBTCoexRejectAMPDU(PADAPTER padapter);
+s32 rtw_btcoex_IsBTCoexCtrlAMPDUSize(PADAPTER);
+u32 rtw_btcoex_GetAMPDUSize(PADAPTER);
+void rtw_btcoex_SetManualControl(PADAPTER, u8 bmanual);
+u8 rtw_btcoex_1Ant(PADAPTER);
+u8 rtw_btcoex_IsBtControlLps(PADAPTER);
+u8 rtw_btcoex_IsLpsOn(PADAPTER);
+u8 rtw_btcoex_RpwmVal(PADAPTER);
+u8 rtw_btcoex_LpsVal(PADAPTER);
+u32 rtw_btcoex_GetRaMask(PADAPTER);
+void rtw_btcoex_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
+void rtw_btcoex_DisplayBtCoexInfo(PADAPTER, u8 *pbuf, u32 bufsize);
+void rtw_btcoex_SetDBG(PADAPTER, u32 *pDbgModule);
+u32 rtw_btcoex_GetDBG(PADAPTER, u8 *pStrBuf, u32 bufSize);
+u8 rtw_btcoex_IncreaseScanDeviceNum(PADAPTER);
+u8 rtw_btcoex_IsBtLinkExist(PADAPTER);
+void rtw_btcoex_pta_off_on_notify(PADAPTER padapter, u8 bBTON);
+#ifdef CONFIG_BT_COEXIST_SOCKET_TRX
+void rtw_btcoex_SetBtPatchVersion(PADAPTER padapter, u16 btHciVer, u16 btPatchVer);
+void rtw_btcoex_SetHciVersion(PADAPTER  padapter, u16 hciVersion);
+void rtw_btcoex_StackUpdateProfileInfo(void);
+void rtw_btcoex_init_socket(_adapter *padapter);
+void rtw_btcoex_close_socket(_adapter *padapter);
+void rtw_btcoex_dump_tx_msg(u8 *tx_msg, u8 len, u8 *msg_name);
+u8 rtw_btcoex_sendmsgbysocket(_adapter *padapter, u8 *msg, u8 msg_size, bool force);
+u8 rtw_btcoex_create_kernel_socket(_adapter *padapter);
+void rtw_btcoex_close_kernel_socket(_adapter *padapter);
+void rtw_btcoex_recvmsgbysocket(void *data);
+u16 rtw_btcoex_parse_recv_data(u8 *msg, u8 msg_size);
+u8 rtw_btcoex_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+void rtw_btcoex_parse_hci_cmd(_adapter *padapter, u8 *cmd, u16 len);
+void rtw_btcoex_SendEventExtBtCoexControl(PADAPTER Adapter, u8 bNeedDbgRsp, u8 dataLen, void *pData);
+void rtw_btcoex_SendEventExtBtInfoControl(PADAPTER Adapter, u8 dataLen, void *pData);
+void rtw_btcoex_SendScanNotify(PADAPTER padapter, u8 scanType);
+#define BT_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData) rtw_btcoex_SendEventExtBtCoexControl(Adapter, bNeedDbgRsp, dataLen, pData)
+#define BT_SendEventExtBtInfoControl(Adapter, dataLen, pData) rtw_btcoex_SendEventExtBtInfoControl(Adapter, dataLen, pData)
+#endif /* CONFIG_BT_COEXIST_SOCKET_TRX */
+u16 rtw_btcoex_btreg_read(PADAPTER padapter, u8 type, u16 addr, u32 *data);
+u16 rtw_btcoex_btreg_write(PADAPTER padapter, u8 type, u16 addr, u16 val);
+u8 rtw_btcoex_get_bt_coexist(PADAPTER padapter);
+u8 rtw_btcoex_get_chip_type(PADAPTER padapter);
+u8 rtw_btcoex_get_pg_ant_num(PADAPTER padapter);
+u8 rtw_btcoex_get_pg_single_ant_path(PADAPTER padapter);
+u8 rtw_btcoex_get_pg_rfe_type(PADAPTER padapter);
+u8 rtw_btcoex_is_tfbga_package_type(PADAPTER padapter);
+u8 rtw_btcoex_get_ant_div_cfg(PADAPTER padapter);
+
+/* ==================================================
+ * Below Functions are called by BT-Coex
+ * ================================================== */
+void rtw_btcoex_rx_ampdu_apply(PADAPTER);
+void rtw_btcoex_LPS_Enter(PADAPTER);
+void rtw_btcoex_LPS_Leave(PADAPTER);
+
+#endif /* __RTW_BTCOEX_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_btcoex_wifionly.h b/drivers/staging/rtl8188eu/include/rtw_btcoex_wifionly.h
new file mode 100644
index 000000000000..4d4059ffe1a7
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_btcoex_wifionly.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_BTCOEX_WIFIONLY_H__
+#define __RTW_BTCOEX_WIFIONLY_H__
+
+void rtw_btcoex_wifionly_switchband_notify(PADAPTER padapter);
+void rtw_btcoex_wifionly_scan_notify(PADAPTER padapter);
+void rtw_btcoex_wifionly_hw_config(PADAPTER padapter);
+void rtw_btcoex_wifionly_initialize(PADAPTER padapter);
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_cmd.h b/drivers/staging/rtl8188eu/include/rtw_cmd.h
new file mode 100644
index 000000000000..dfadd5b5cca0
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_cmd.h
@@ -0,0 +1,1280 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_CMD_H_
+#define __RTW_CMD_H_
+
+
+#define C2H_MEM_SZ (16*1024)
+
+#define FREE_CMDOBJ_SZ	128
+
+#define MAX_CMDSZ	1024
+#define MAX_RSPSZ	512
+#define MAX_EVTSZ	1024
+
+#define CMDBUFF_ALIGN_SZ 512
+
+struct cmd_obj {
+	_adapter *padapter;
+	u16	cmdcode;
+	u8	res;
+	u8	*parmbuf;
+	u32	cmdsz;
+	u8	*rsp;
+	u32	rspsz;
+	struct submit_ctx *sctx;
+	u8 no_io;
+	/* _sema 	cmd_sem; */
+	_list	list;
+};
+
+/* cmd flags */
+enum {
+	RTW_CMDF_DIRECTLY = BIT0,
+	RTW_CMDF_WAIT_ACK = BIT1,
+};
+
+struct cmd_priv {
+	_sema	cmd_queue_sema;
+	/* _sema	cmd_done_sema; */
+	_sema	terminate_cmdthread_sema;
+	_queue	cmd_queue;
+	u8	cmd_seq;
+	u8	*cmd_buf;	/* shall be non-paged, and 4 bytes aligned */
+	u8	*cmd_allocated_buf;
+	u8	*rsp_buf;	/* shall be non-paged, and 4 bytes aligned		 */
+	u8	*rsp_allocated_buf;
+	u32	cmd_issued_cnt;
+	u32	cmd_done_cnt;
+	u32	rsp_cnt;
+	ATOMIC_T cmdthd_running;
+	/* u8 cmdthd_running; */
+	u8 stop_req;
+	_adapter *padapter;
+	_mutex sctx_mutex;
+};
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+struct evt_obj {
+	u16	evtcode;
+	u8	res;
+	u8	*parmbuf;
+	u32	evtsz;
+	_list	list;
+};
+#endif
+
+struct	evt_priv {
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_sema	evt_notify;
+	_sema	terminate_evtthread_sema;
+	_queue	evt_queue;
+#endif
+
+#ifdef CONFIG_FW_C2H_REG
+	#define CONFIG_C2H_WK
+#endif
+
+#ifdef CONFIG_C2H_WK
+	_workitem c2h_wk;
+	bool c2h_wk_alive;
+	struct rtw_cbuf *c2h_queue;
+	#define C2H_QUEUE_MAX_LEN 10
+#endif
+
+#ifdef CONFIG_H2CLBK
+	_sema	lbkevt_done;
+	u8	lbkevt_limit;
+	u8	lbkevt_num;
+	u8	*cmdevt_parm;
+#endif
+	ATOMIC_T event_seq;
+	u8	*evt_buf;	/* shall be non-paged, and 4 bytes aligned		 */
+	u8	*evt_allocated_buf;
+	u32	evt_done_cnt;
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	u8	*c2h_mem;
+	u8	*allocated_c2h_mem;
+#endif
+
+};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+	do {\
+		INIT_LIST_HEAD(&pcmd->list);\
+		pcmd->cmdcode = code;\
+		pcmd->parmbuf = (u8 *)(pparm);\
+		pcmd->cmdsz = sizeof (*pparm);\
+		pcmd->rsp = NULL;\
+		pcmd->rspsz = 0;\
+	} while (0)
+
+#define init_h2fwcmd_w_parm_no_parm_rsp(pcmd, code) \
+	do {\
+		INIT_LIST_HEAD(&pcmd->list);\
+		pcmd->cmdcode = code;\
+		pcmd->parmbuf = NULL;\
+		pcmd->cmdsz = 0;\
+		pcmd->rsp = NULL;\
+		pcmd->rspsz = 0;\
+	} while (0)
+
+struct P2P_PS_Offload_t {
+	u8 Offload_En:1;
+	u8 role:1; /* 1: Owner, 0: Client */
+	u8 CTWindow_En:1;
+	u8 NoA0_En:1;
+	u8 NoA1_En:1;
+	u8 AllStaSleep:1; /* Only valid in Owner */
+	u8 discovery:1;
+	u8 rsvd:1;
+};
+
+struct P2P_PS_CTWPeriod_t {
+	u8 CTWPeriod;	/* TU */
+};
+
+#ifdef CONFIG_P2P_WOWLAN
+
+struct P2P_WoWlan_Offload_t {
+	u8 Disconnect_Wkup_Drv:1;
+	u8 role:2;
+	u8 Wps_Config[2];
+};
+
+#endif /* CONFIG_P2P_WOWLAN */
+
+extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+extern u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
+extern struct evt_obj *rtw_dequeue_evt(_queue *queue);
+extern void rtw_free_evt_obj(struct evt_obj *pcmd);
+#endif
+
+void rtw_stop_cmd_thread(_adapter *adapter);
+thread_return rtw_cmd_thread(thread_context context);
+
+extern u32 rtw_init_cmd_priv(struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv);
+
+extern u32 rtw_init_evt_priv(struct evt_priv *pevtpriv);
+extern void rtw_free_evt_priv(struct evt_priv *pevtpriv);
+extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
+#ifdef CONFIG_P2P
+u8 p2p_protocol_wk_cmd(_adapter *padapter, int intCmdType);
+
+#ifdef CONFIG_IOCTL_CFG80211
+struct p2p_roch_parm {
+	u64 cookie;
+	struct wireless_dev *wdev;
+	struct ieee80211_channel ch;
+	enum nl80211_channel_type ch_type;
+	unsigned int duration;
+};
+
+u8 p2p_roch_cmd(_adapter *adapter
+	, u64 cookie, struct wireless_dev *wdev
+	, struct ieee80211_channel *ch, enum nl80211_channel_type ch_type
+	, unsigned int duration
+	, u8 flags
+);
+u8 p2p_cancel_roch_cmd(_adapter *adapter, u64 cookie, struct wireless_dev *wdev, u8 flags);
+#endif /* CONFIG_IOCTL_CFG80211 */
+#endif /* CONFIG_P2P */
+
+enum rtw_drvextra_cmd_id {
+	NONE_WK_CID,
+	STA_MSTATUS_RPT_WK_CID,
+	DYNAMIC_CHK_WK_CID,
+	DM_CTRL_WK_CID,
+	PBC_POLLING_WK_CID,
+	POWER_SAVING_CTRL_WK_CID,/* IPS,AUTOSuspend */
+	LPS_CTRL_WK_CID,
+	ANT_SELECT_WK_CID,
+	P2P_PS_WK_CID,
+	P2P_PROTO_WK_CID,
+	CHECK_HIQ_WK_CID,/* for softap mode, check hi queue if empty */
+	INTEl_WIDI_WK_CID,
+	C2H_WK_CID,
+	RTP_TIMER_CFG_WK_CID,
+	RESET_SECURITYPRIV, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	FREE_ASSOC_RESOURCES, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	DM_IN_LPS_WK_CID,
+	DM_RA_MSK_WK_CID, /* add for STA update RAMask when bandwith change. */
+	BEAMFORMING_WK_CID,
+	LPS_CHANGE_DTIM_CID,
+	BTINFO_WK_CID,
+	DFS_MASTER_WK_CID,
+	SESSION_TRACKER_WK_CID,
+	EN_HW_UPDATE_TSF_WK_CID,
+	TEST_H2C_CID,
+	MP_CMD_WK_CID,
+	CUSTOMER_STR_WK_CID,
+	MAX_WK_CID
+};
+
+enum LPS_CTRL_TYPE {
+	LPS_CTRL_SCAN = 0,
+	LPS_CTRL_JOINBSS = 1,
+	LPS_CTRL_CONNECT = 2,
+	LPS_CTRL_DISCONNECT = 3,
+	LPS_CTRL_SPECIAL_PACKET = 4,
+	LPS_CTRL_LEAVE = 5,
+	LPS_CTRL_TRAFFIC_BUSY = 6,
+	LPS_CTRL_TX_TRAFFIC_LEAVE = 7,
+	LPS_CTRL_RX_TRAFFIC_LEAVE = 8,
+	LPS_CTRL_ENTER = 9,
+	LPS_CTRL_LEAVE_CFG80211_PWRMGMT = 10,
+};
+
+enum STAKEY_TYPE {
+	GROUP_KEY		= 0,
+	UNICAST_KEY		= 1,
+	TDLS_KEY		= 2,
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;/* 1: sleep, 0:resume */
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 deauth_timeout_ms;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	bool adhoc;
+
+	/* used by AP mode now */
+	s16 req_ch;
+	s8 req_bw;
+	s8 req_offset;
+};
+
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode
+
+*/
+
+#define RTW_SSID_SCAN_AMOUNT 9 /* for WEXT_CSCAN_AMOUNT 9 */
+#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
+struct sitesurvey_parm {
+	sint scan_mode;	/* active: 1, passive: 0 */
+	/* sint bsslimit;	// 1 ~ 48 */
+	u8 ssid_num;
+	u8 ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	u8 mode;  /* 0: legacy open, 1: legacy shared 2: 802.1x */
+	u8 _1x;   /* 0: PSK, 1: TLS */
+	u8 rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	u8	algorithm;	/* encryption algorithm, could be none, wep40, TKIP, CCMP, wep104 */
+	u8	keyid;
+	u8	grpkey;		/* 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x */
+	u8	set_tx;		/* 1: main tx key for wep. 0: other key. */
+	u8	key[16];	/* this could be 40 or 104 */
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid
+
+*/
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	keyid;
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+	Command mode
+	This is to force fw to del an sta_data entry per driver's request
+	FW will invalidate the cam entry associated with it.
+*/
+struct del_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	u8	mac_id;
+	u8	datarates[NumRates];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	u8 datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	u8	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	u8	rfchannel;
+	u8	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct readMAC_parm {
+	u8 len;
+	u32	addr;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+
+struct Tx_Beacon_param {
+	WLAN_BSSID_EX network;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=	swap32(w1);
+		b0		=	b1
+		s2		=	s0 + s1
+		b1		=	b0
+		w1		=	w0
+
+	mac[0] ==	2
+	==> CMD_EVENT mode, return	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=	swap32(w0);
+		b0		=	b1
+		s2		=	s0 + event.mac[2]
+		b1		=	b0
+		w1		=	swap32(w1) - event.mac[2];
+
+		parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+#ifdef CONFIG_H2CLBK
+
+struct seth2clbk_parm {
+	u8 mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16  s2;
+	u8	b1;
+	u32	w1;
+};
+
+struct geth2clbk_parm {
+	u32 rsv;
+};
+
+struct geth2clbk_rsp {
+	u8	mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16	s2;
+	u8	b1;
+	u32	w1;
+};
+
+#endif	/* CONFIG_H2CLBK */
+
+/* CMD param Formart for driver extra cmd handler */
+struct drvextra_cmd_parm {
+	int ec_id; /* extra cmd id */
+	int type; /* Can use this field as the type id or command size */
+	int size; /* buffer size */
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;
+	u8	rx_antset;
+	u8	tx_antenna;
+	u8	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		/* 0: pure hw, 1: fw */
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+
+struct setratable_parm {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+struct getratable_parm {
+	uint rsvd;
+};
+struct getratable_rsp {
+	u8 ss_ForceUp[NumRates];
+	u8 ss_ULevel[NumRates];
+	u8 ss_DLevel[NumRates];
+	u8 count_judge[NumRates];
+};
+
+
+/* to get TX,RX retry count */
+struct gettxretrycnt_parm {
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp {
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm {
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp {
+	unsigned long rx_retrycnt;
+};
+
+/* to get BCNOK,BCNERR count */
+struct getbcnokcnt_parm {
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp {
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm {
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp {
+	unsigned long bcnerrcnt;
+};
+
+/* to get current TX power level */
+struct getcurtxpwrlevel_parm {
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp {
+	unsigned short tx_power;
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm {
+	unsigned int tid;
+	u8	addr[ETH_ALEN];
+};
+
+struct addBaRsp_parm {
+	unsigned int tid;
+	unsigned int start_seq;
+	u8 addr[ETH_ALEN];
+	u8 status;
+	u8 size;
+};
+
+/*H2C Handler index: 46 */
+struct set_ch_parm {
+	u8 ch;
+	u8 bw;
+	u8 ch_offset;
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTxPower_parm {
+	u8 TxPower;
+};
+
+/*H2C Handler index: 48 */
+struct SwitchAntenna_parm {
+	u16 antenna_tx;
+	u16 antenna_rx;
+	/*	R_ANTENNA_SELECT_CCK cck_txrx; */
+	u8 cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct SetCrystalCap_parm {
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct SetSingleCarrierTx_parm {
+	u8 bStart;
+};
+
+/*H2C Handler index: 51 */
+struct SetSingleToneTx_parm {
+	u8 bStart;
+	u8 curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct SetCarrierSuppressionTx_parm {
+	u8 bStart;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct SetContinuousTx_parm {
+	u8 bStart;
+	u8 CCK_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct SwitchBandwidth_parm {
+	u8 curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+/*H2C Handler index: 59 */
+struct SetChannelPlan_param {
+	const struct country_chplan *country_ent;
+	u8 channel_plan;
+};
+
+/*H2C Handler index: 60 */
+struct LedBlink_param {
+	void *	 pLed;
+};
+
+/*H2C Handler index: 61 */
+struct SetChannelSwitch_param {
+	u8 new_ch_no;
+};
+
+/*H2C Handler index: 62 */
+struct TDLSoption_param {
+	u8 addr[ETH_ALEN];
+	u8 option;
+};
+
+/*H2C Handler index: 64 */
+struct RunInThread_param {
+	void (*func)(void *);
+	void *context;
+};
+
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result:
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+#define H2C_ENQ_HEAD			0x08
+#define H2C_ENQ_HEAD_FAIL		0x09
+
+extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
+extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
+u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num, struct rtw_ieee80211_channel *ch, int ch_num);
+
+u8 rtw_create_ibss_cmd(_adapter *adapter, int flags);
+u8 rtw_startbss_cmd(_adapter *adapter, int flags);
+u8 rtw_change_bss_chbw_cmd(_adapter *adapter, int flags, s16 req_ch, s8 req_bw, s8 req_offset);
+
+extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
+
+struct sta_info;
+extern u8 rtw_setstakey_cmd(_adapter  *padapter, struct sta_info *sta, u8 key_type, bool enqueue);
+extern u8 rtw_clearstakey_cmd(_adapter *padapter, struct sta_info *sta, u8 enqueue);
+
+extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network *pnetwork);
+u8 rtw_disassoc_cmd(_adapter *padapter, u32 deauth_timeout_ms, bool enqueue);
+extern u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype, bool enqueue);
+extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
+extern u8 rtw_getmacreg_cmd(_adapter *padapter, u8 len, u32 addr);
+extern void rtw_usb_catc_trigger_cmd(_adapter *padapter, const char *caller);
+extern u8 rtw_setbbreg_cmd(_adapter *padapter, u8 offset, u8 val);
+extern u8 rtw_setrfreg_cmd(_adapter *padapter, u8 offset, u32 val);
+extern u8 rtw_getbbreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
+extern u8 rtw_getrfreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
+extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
+extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
+extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
+
+extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset, u8 *pval);
+extern u8 rtw_setfwdig_cmd(_adapter *padapter, u8 type);
+extern u8 rtw_setfwra_cmd(_adapter *padapter, u8 type);
+
+extern u8 rtw_addbareq_cmd(_adapter *padapter, u8 tid, u8 *addr);
+extern u8 rtw_addbarsp_cmd(_adapter *padapter, u8 *addr, u16 tid, u8 status, u8 size, u16 start_seq);
+/* add for CONFIG_IEEE80211W, none 11w also can use */
+extern u8 rtw_reset_securitypriv_cmd(_adapter *padapter);
+extern u8 rtw_free_assoc_resources_cmd(_adapter *padapter);
+extern u8 rtw_dynamic_chk_wk_cmd(_adapter *adapter);
+
+u8 rtw_lps_ctrl_wk_cmd(_adapter *padapter, u8 lps_ctrl_type, u8 enqueue);
+u8 rtw_dm_in_lps_wk_cmd(_adapter *padapter);
+u8 rtw_lps_change_dtim_cmd(_adapter *padapter, u8 dtim);
+
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+u8 rtw_rpt_timer_cfg_cmd(_adapter *padapter, u16 minRptTime);
+#endif
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+extern  u8 rtw_antenna_select_cmd(_adapter *padapter, u8 antenna, u8 enqueue);
+#endif
+
+u8 rtw_dm_ra_mask_wk_cmd(_adapter *padapter, u8 *psta);
+
+extern u8 rtw_ps_cmd(_adapter *padapter);
+
+#ifdef CONFIG_AP_MODE
+u8 rtw_chk_hi_queue_cmd(_adapter *padapter);
+#ifdef CONFIG_DFS_MASTER
+u8 rtw_dfs_master_cmd(_adapter *adapter, bool enqueue);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void rtw_dfs_master_timer_hdl(RTW_TIMER_HDL_ARGS);
+#else
+void rtw_dfs_master_timer_hdl(struct timer_list *t);
+#endif
+void rtw_dfs_master_enable(_adapter *adapter, u8 ch, u8 bw, u8 offset);
+void rtw_dfs_master_disable(_adapter *adapter, u8 ch, u8 bw, u8 offset, bool by_others);
+enum {
+	MLME_STA_CONNECTING,
+	MLME_STA_CONNECTED,
+	MLME_STA_DISCONNECTED,
+	MLME_AP_STARTED,
+	MLME_AP_STOPPED,
+};
+void rtw_dfs_master_status_apply(_adapter *adapter, u8 self_action);
+#endif /* CONFIG_DFS_MASTER */
+#endif /* CONFIG_AP_MODE */
+
+#ifdef CONFIG_BT_COEXIST
+u8 rtw_btinfo_cmd(PADAPTER padapter, u8 *pbuf, u16 length);
+#endif
+
+u8 rtw_test_h2c_cmd(_adapter *adapter, u8 *buf, u8 len);
+
+u8 rtw_enable_hw_update_tsf_cmd(_adapter *padapter);
+
+u8 rtw_set_ch_cmd(_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
+
+u8 rtw_set_chplan_cmd(_adapter *adapter, int flags, u8 chplan, u8 swconfig);
+u8 rtw_set_country_cmd(_adapter *adapter, int flags, const char *country_code, u8 swconfig);
+
+extern u8 rtw_led_blink_cmd(_adapter *padapter, void * pLed);
+extern u8 rtw_set_csa_cmd(_adapter *padapter, u8 new_ch_no);
+extern u8 rtw_tdls_cmd(_adapter *padapter, u8 *addr, u8 option);
+
+u8 rtw_mp_cmd(_adapter *adapter, u8 mp_cmd_id, u8 flags);
+
+#ifdef CONFIG_RTW_CUSTOMER_STR
+u8 rtw_customer_str_req_cmd(_adapter *adapter);
+u8 rtw_customer_str_write_cmd(_adapter *adapter, const u8 *cstr);
+#endif
+
+#ifdef CONFIG_FW_C2H_REG
+u8 rtw_c2h_reg_wk_cmd(_adapter *adapter, u8 *c2h_evt);
+#endif
+#ifdef CONFIG_FW_C2H_PKT
+u8 rtw_c2h_packet_wk_cmd(_adapter *adapter, u8 *c2h_evt, u16 length);
+#endif
+
+u8 rtw_run_in_thread_cmd(PADAPTER padapter, void (*func)(void *), void *context);
+
+u8 session_tracker_chk_cmd(_adapter *adapter, struct sta_info *sta);
+u8 session_tracker_add_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+u8 session_tracker_del_cmd(_adapter *adapter, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+
+u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf);
+
+extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+void rtw_create_ibss_post_hdl(_adapter *padapter, int status);
+extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_readtssi_cmdrsp_callback(_adapter	*padapter,  struct cmd_obj *pcmd);
+
+extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_getmacreg_cmdrsp_callback(_adapter *padapter,  struct cmd_obj *pcmd);
+
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
+};
+
+enum rtw_h2c_cmd {
+	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
+	GEN_CMD_CODE(_Write_MACREG) ,
+	GEN_CMD_CODE(_Read_BBREG) ,
+	GEN_CMD_CODE(_Write_BBREG) ,
+	GEN_CMD_CODE(_Read_RFREG) ,
+	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+	GEN_CMD_CODE(_Read_EEPROM) ,
+	GEN_CMD_CODE(_Write_EEPROM) ,
+	GEN_CMD_CODE(_Read_EFUSE) ,
+	GEN_CMD_CODE(_Write_EFUSE) ,
+
+	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+	GEN_CMD_CODE(_Write_CAM) ,
+	GEN_CMD_CODE(_setBCNITV),
+	GEN_CMD_CODE(_setMBIDCFG),
+	GEN_CMD_CODE(_JoinBss),   /*14*/
+	GEN_CMD_CODE(_DisConnect) , /*15*/
+	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) ,
+	GEN_CMD_CODE(_SiteSurvey),  /*18*/
+	GEN_CMD_CODE(_SetAuth) ,
+
+	GEN_CMD_CODE(_SetKey) ,	/*20*/
+	GEN_CMD_CODE(_SetStaKey) ,
+	GEN_CMD_CODE(_SetAssocSta) ,
+	GEN_CMD_CODE(_DelAssocSta) ,
+	GEN_CMD_CODE(_SetStaPwrState) ,
+	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+	GEN_CMD_CODE(_GetBasicRate) ,
+	GEN_CMD_CODE(_SetDataRate) ,
+	GEN_CMD_CODE(_GetDataRate) ,
+	GEN_CMD_CODE(_SetPhyInfo) ,
+
+	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	GEN_CMD_CODE(_SetPhy) ,
+	GEN_CMD_CODE(_GetPhy) ,
+	GEN_CMD_CODE(_readRssi) ,
+	GEN_CMD_CODE(_readGain) ,
+	GEN_CMD_CODE(_SetAtim) , /*35*/
+	GEN_CMD_CODE(_SetPwrMode) ,
+	GEN_CMD_CODE(_JoinbssRpt),
+	GEN_CMD_CODE(_SetRaTable) ,
+	GEN_CMD_CODE(_GetRaTable) ,
+
+	GEN_CMD_CODE(_GetCCXReport), /*40*/
+	GEN_CMD_CODE(_GetDTMReport),
+	GEN_CMD_CODE(_GetTXRateStatistics),
+	GEN_CMD_CODE(_SetUsbSuspend),
+	GEN_CMD_CODE(_SetH2cLbk),
+	GEN_CMD_CODE(_AddBAReq) , /*45*/
+	GEN_CMD_CODE(_SetChannel), /*46*/
+	GEN_CMD_CODE(_SetTxPower),
+	GEN_CMD_CODE(_SwitchAntenna),
+	GEN_CMD_CODE(_SetCrystalCap),
+	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
+
+	GEN_CMD_CODE(_SetSingleToneTx),/*51*/
+	GEN_CMD_CODE(_SetCarrierSuppressionTx),
+	GEN_CMD_CODE(_SetContinuousTx),
+	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
+	GEN_CMD_CODE(_TX_Beacon), /*55*/
+
+	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
+	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
+	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/
+
+	GEN_CMD_CODE(_SetChannelPlan), /*59*/
+	GEN_CMD_CODE(_LedBlink), /*60*/
+
+	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
+	GEN_CMD_CODE(_TDLS), /*62*/
+	GEN_CMD_CODE(_ChkBMCSleepq), /*63*/
+
+	GEN_CMD_CODE(_RunInThreadCMD), /*64*/
+	GEN_CMD_CODE(_AddBARsp) , /*65*/
+
+	MAX_H2CCMD
+};
+
+#define _GetMACReg_CMD_ _Read_MACREG_CMD_
+#define _SetMACReg_CMD_ _Write_MACREG_CMD_
+#define _GetBBReg_CMD_		_Read_BBREG_CMD_
+#define _SetBBReg_CMD_		_Write_BBREG_CMD_
+#define _GetRFReg_CMD_		_Read_RFREG_CMD_
+#define _SetRFReg_CMD_		_Write_RFREG_CMD_
+
+#ifdef _RTW_CMD_C_
+static struct _cmd_callback	rtw_cmd_callback[] = {
+	{GEN_CMD_CODE(_Read_MACREG), &rtw_getmacreg_cmdrsp_callback}, /*0*/
+	{GEN_CMD_CODE(_Write_MACREG), NULL},
+	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_BBREG), NULL},
+	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_Write_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_Read_EEPROM), NULL},
+	{GEN_CMD_CODE(_Write_EEPROM), NULL},
+	{GEN_CMD_CODE(_Read_EFUSE), NULL},
+	{GEN_CMD_CODE(_Write_EFUSE), NULL},
+
+	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},
+	{GEN_CMD_CODE(_setBCNITV), NULL},
+	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CreateBss), NULL},
+	{GEN_CMD_CODE(_SetOpMode), NULL},
+	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SetAuth), NULL},
+
+	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
+	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},
+	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
+	{GEN_CMD_CODE(_GetBasicRate), NULL},
+	{GEN_CMD_CODE(_SetDataRate), NULL},
+	{GEN_CMD_CODE(_GetDataRate), NULL},
+	{GEN_CMD_CODE(_SetPhyInfo), NULL},
+
+	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
+	{GEN_CMD_CODE(_SetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},
+	{GEN_CMD_CODE(_readRssi), NULL},
+	{GEN_CMD_CODE(_readGain), NULL},
+	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
+	{GEN_CMD_CODE(_SetPwrMode), NULL},
+	{GEN_CMD_CODE(_JoinbssRpt), NULL},
+	{GEN_CMD_CODE(_SetRaTable), NULL},
+	{GEN_CMD_CODE(_GetRaTable) , NULL},
+
+	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
+	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
+	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
+	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
+	{GEN_CMD_CODE(_SetTxPower), NULL},
+	{GEN_CMD_CODE(_SwitchAntenna), NULL},
+	{GEN_CMD_CODE(_SetCrystalCap), NULL},
+	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
+
+	{GEN_CMD_CODE(_SetSingleToneTx), NULL}, /*51*/
+	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
+	{GEN_CMD_CODE(_SetContinuousTx), NULL},
+	{GEN_CMD_CODE(_SwitchBandwidth), NULL},		/*54*/
+	{GEN_CMD_CODE(_TX_Beacon), NULL},/*55*/
+
+	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},/*56*/
+	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},/*57*/
+	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
+	{GEN_CMD_CODE(_SetChannelPlan), NULL},/*59*/
+	{GEN_CMD_CODE(_LedBlink), NULL},/*60*/
+
+	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
+	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
+	{GEN_CMD_CODE(_ChkBMCSleepq), NULL}, /*63*/
+
+	{GEN_CMD_CODE(_RunInThreadCMD), NULL},/*64*/
+	{GEN_CMD_CODE(_AddBARsp), NULL}, /*65*/
+};
+#endif
+
+#define CMD_FMT "cmd=%d,%d,%d"
+#define CMD_ARG(cmd) \
+	(cmd)->cmdcode, \
+	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->ec_id : ((cmd)->cmdcode == GEN_CMD_CODE(_Set_MLME_EVT) ? ((struct C2HEvent_Header *)(cmd)->parmbuf)->ID : 0), \
+	(cmd)->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ? ((struct drvextra_cmd_parm *)(cmd)->parmbuf)->type : 0
+
+#endif /* _CMD_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_debug.h b/drivers/staging/rtl8188eu/include/rtw_debug.h
new file mode 100644
index 000000000000..ad60609abaf9
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_debug.h
@@ -0,0 +1,596 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_DEBUG_H__
+#define __RTW_DEBUG_H__
+
+/* driver log level*/
+enum {
+	_DRV_NONE_ = 0,
+	_DRV_ALWAYS_ = 1,
+	_DRV_ERR_ = 2,
+	_DRV_WARNING_ = 3,
+	_DRV_INFO_ = 4,
+	_DRV_DEBUG_ = 5,
+	_DRV_MAX_ = 6
+};
+
+#define DRIVER_PREFIX "RTW: "
+
+#define RTW_PRINT(x, ...) do {} while (0)
+#define RTW_ERR(x, ...) do {} while (0)
+#define RTW_WARN(x,...) do {} while (0)
+#define RTW_INFO(x,...) do {} while (0)
+#define RTW_DBG(x,...) do {} while (0)
+#define RTW_PRINT_SEL(x,...) do {} while (0)
+#define _RTW_PRINT(x, ...) do {} while (0)
+#define _RTW_ERR(x, ...) do {} while (0)
+#define _RTW_WARN(x,...) do {} while (0)
+#define _RTW_INFO(x,...) do {} while (0)
+#define _RTW_DBG(x,...) do {} while (0)
+#define _RTW_PRINT_SEL(x,...) do {} while (0)
+
+#define RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+#define RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+#define RTW_PRINT_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+#define _RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+#define _RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen) do {} while (0)
+
+#define RTW_DBG_EXPR(EXPR) do {} while (0)
+
+#define RTW_DBGDUMP NULL /* 'stream' for _dbgdump */
+
+/* don't use these 3 APIs anymore, will be removed later */
+#define RT_TRACE(_Comp, _Level, Fmt) do {} while (0)
+
+
+#undef _dbgdump
+#undef _seqdump
+
+#define _dbgdump printk
+#define _seqdump seq_printf
+
+#ifdef CONFIG_RTW_DEBUG
+
+extern uint rtw_drv_log_level;
+
+#if defined(_dbgdump)
+
+/* with driver-defined prefix */
+#undef RTW_PRINT
+#define RTW_PRINT(fmt, arg...)     \
+	do {\
+		if (RTW_LOG_LEVEL <= rtw_drv_log_level) {\
+			_dbgdump(DRIVER_PREFIX fmt, ##arg);\
+		} \
+	} while (0)
+
+#undef RTW_ERR
+#define RTW_ERR(fmt, arg...)     \
+	do {\
+		if (_DRV_ERR_ <= rtw_drv_log_level) {\
+			_dbgdump(DRIVER_PREFIX"ERROR " fmt, ##arg);\
+		} \
+	} while (0)
+
+
+#undef RTW_WARN
+#define RTW_WARN(fmt, arg...)     \
+	do {\
+		if (_DRV_WARNING_ <= rtw_drv_log_level) {\
+			_dbgdump(DRIVER_PREFIX"WARN " fmt, ##arg);\
+		} \
+	} while (0)
+
+#undef RTW_INFO
+#define RTW_INFO(fmt, arg...)     \
+	do {\
+		if (_DRV_INFO_ <= rtw_drv_log_level) {\
+			_dbgdump(DRIVER_PREFIX fmt, ##arg);\
+		} \
+	} while (0)
+
+
+#undef RTW_DBG
+#define RTW_DBG(fmt, arg...)     \
+	do {\
+		if (_DRV_DEBUG_ <= rtw_drv_log_level) {\
+			_dbgdump(DRIVER_PREFIX fmt, ##arg);\
+		} \
+	} while (0)
+
+
+#undef RTW_INFO_DUMP
+#define RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen)			\
+	do {\
+		if (_DRV_INFO_ <= rtw_drv_log_level) {	\
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			_dbgdump("%s", DRIVER_PREFIX);						\
+			_dbgdump(_TitleString);						\
+			for (__i = 0; __i < (int)_HexDataLen; __i++) {				\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+				if (((__i + 1) % 16) == 0)	\
+					_dbgdump("\n");			\
+			}								\
+			_dbgdump("\n");							\
+		} \
+	} while (0)
+
+#undef RTW_DBG_DUMP
+#define RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen)			\
+	do {\
+		if (_DRV_DEBUG_ <= rtw_drv_log_level) { \
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			_dbgdump("%s", DRIVER_PREFIX);						\
+			_dbgdump(_TitleString);						\
+			for (__i = 0; __i < (int)_HexDataLen; __i++) {				\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+				if (((__i + 1) % 16) == 0)	\
+					_dbgdump("\n");			\
+			}								\
+			_dbgdump("\n");							\
+		} \
+	} while (0)
+
+
+#undef RTW_PRINT_DUMP
+#define RTW_PRINT_DUMP(_TitleString, _HexData, _HexDataLen)			\
+	do {\
+		if (_DRV_ALWAYS_ <= rtw_drv_log_level) { \
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			_dbgdump("%s", DRIVER_PREFIX);						\
+			_dbgdump(_TitleString); 					\
+			for (__i = 0; __i < (int)_HexDataLen; __i++) {				\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+				if (((__i + 1) % 16) == 0)	\
+					_dbgdump("\n"); 		\
+			}								\
+			_dbgdump("\n"); 						\
+		} \
+	} while (0)
+
+/* without driver-defined prefix */
+#undef _RTW_PRINT
+#define _RTW_PRINT(fmt, arg...)     \
+	do {\
+		if (_DRV_ALWAYS_ <= rtw_drv_log_level) {\
+			_dbgdump(fmt, ##arg);\
+		} \
+	} while (0)
+
+#undef _RTW_ERR
+#define _RTW_ERR(fmt, arg...)     \
+	do {\
+		if (_DRV_ERR_ <= rtw_drv_log_level) {\
+			_dbgdump(fmt, ##arg);\
+		} \
+	} while (0)
+
+
+#undef _RTW_WARN
+#define _RTW_WARN(fmt, arg...)     \
+	do {\
+		if (_DRV_WARNING_ <= rtw_drv_log_level) {\
+			_dbgdump(fmt, ##arg);\
+		} \
+	} while (0)
+
+#undef _RTW_INFO
+#define _RTW_INFO(fmt, arg...)     \
+	do {\
+		if (_DRV_INFO_ <= rtw_drv_log_level) {\
+			_dbgdump(fmt, ##arg);\
+		} \
+	} while (0)
+
+#undef _RTW_DBG
+#define _RTW_DBG(fmt, arg...)     \
+	do {\
+		if (_DRV_DEBUG_ <= rtw_drv_log_level) {\
+			_dbgdump(fmt, ##arg);\
+		} \
+	} while (0)
+
+
+#undef _RTW_INFO_DUMP
+#define _RTW_INFO_DUMP(_TitleString, _HexData, _HexDataLen)			\
+	if (_DRV_INFO_ <= rtw_drv_log_level) {	\
+		int __i;								\
+		u8	*ptr = (u8 *)_HexData;				\
+		_dbgdump(_TitleString);						\
+		for (__i = 0; __i<(int)_HexDataLen; __i++)				\
+		{								\
+			_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+			if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
+		}								\
+		_dbgdump("\n");							\
+	}
+
+#undef _RTW_DBG_DUMP
+#define _RTW_DBG_DUMP(_TitleString, _HexData, _HexDataLen)			\
+	if (_DRV_DEBUG_ <= rtw_drv_log_level) { \
+		int __i;								\
+		u8	*ptr = (u8 *)_HexData;				\
+		_dbgdump(_TitleString);						\
+		for (__i = 0; __i<(int)_HexDataLen; __i++)				\
+		{								\
+			_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+			if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
+		}								\
+		_dbgdump("\n");							\
+	}
+
+/* other debug APIs */
+#undef RTW_DBG_EXPR
+#define RTW_DBG_EXPR(EXPR) do { if (_DRV_DEBUG_ <= rtw_drv_log_level) EXPR; } while (0)
+
+#endif /* defined(_dbgdump) */
+#endif /* CONFIG_RTW_DEBUG */
+
+
+#if defined(_seqdump)
+/* dump message to selected 'stream' with driver-defined prefix */
+#undef RTW_PRINT_SEL
+#define RTW_PRINT_SEL(sel, fmt, arg...) \
+	do {\
+	if (RTW_LOG_LEVEL <= rtw_drv_log_level) {\
+		if (sel == RTW_DBGDUMP)\
+			RTW_PRINT(fmt, ##arg); \
+		else {\
+			_seqdump(sel, fmt, ##arg) /*rtw_warn_on(1)*/; \
+		} \
+	} \
+	} while (0)
+
+/* dump message to selected 'stream' */
+#undef _RTW_PRINT_SEL
+#define _RTW_PRINT_SEL(sel, fmt, arg...) \
+	do {\
+	if (RTW_LOG_LEVEL <= rtw_drv_log_level) {\
+		if (sel == RTW_DBGDUMP)\
+			_RTW_PRINT(fmt, ##arg); \
+		else {\
+			_seqdump(sel, fmt, ##arg) /*rtw_warn_on(1)*/; \
+		} \
+	} \
+	} while (0)
+
+/* dump message to selected 'stream' */
+#undef _RTW_DUMP_SEL
+#define _RTW_DUMP_SEL(sel, _HexData, _HexDataLen) \
+	do {\
+	if (RTW_LOG_LEVEL <= rtw_drv_log_level) {\
+		if (sel == RTW_DBGDUMP) {\
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			for (__i = 0; __i < (int)_HexDataLen; __i++) {				\
+				_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+				if (((__i + 1) % 16) == 0)	\
+					_dbgdump("\n");			\
+			}								\
+			_dbgdump("\n");							\
+		} \
+		else {\
+			int __i;								\
+			u8	*ptr = (u8 *)_HexData;				\
+			for (__i = 0; __i < (int)_HexDataLen; __i++) {				\
+				_seqdump(sel, "%02X%s", ptr[__i], (((__i + 1) % 4) == 0) ? "  " : " ");	\
+				if (((__i + 1) % 16) == 0)	\
+					_seqdump(sel, "\n");			\
+			}								\
+			_seqdump(sel, "\n");							\
+		} \
+	} \
+	} while (0)
+
+#endif /* defined(_seqdump) */
+
+
+#ifdef CONFIG_DBG_COUNTER
+	#define DBG_COUNTER(counter) counter++
+#else
+	#define DBG_COUNTER(counter)
+#endif
+
+void dump_drv_version(void *sel);
+void dump_log_level(void *sel);
+void dump_drv_cfg(void *sel);
+
+#ifdef CONFIG_SDIO_HCI
+void sd_f0_reg_dump(void *sel, _adapter *adapter);
+void sdio_local_reg_dump(void *sel, _adapter *adapter);
+#endif /* CONFIG_SDIO_HCI */
+
+void mac_reg_dump(void *sel, _adapter *adapter);
+void bb_reg_dump(void *sel, _adapter *adapter);
+void bb_reg_dump_ex(void *sel, _adapter *adapter);
+void rf_reg_dump(void *sel, _adapter *adapter);
+
+bool rtw_fwdl_test_trigger_chksum_fail(void);
+bool rtw_fwdl_test_trigger_wintint_rdy_fail(void);
+bool rtw_del_rx_ampdu_test_trigger_no_tx_fail(void);
+
+u32 rtw_get_wait_hiq_empty_ms(void);
+void rtw_sink_rtp_seq_dbg(_adapter *adapter, _pkt *pkt);
+
+struct sta_info;
+void sta_rx_reorder_ctl_dump(void *sel, struct sta_info *sta);
+
+struct dvobj_priv;
+void dump_tx_rate_bmp(void *sel, struct dvobj_priv *dvobj);
+void dump_adapters_status(void *sel, struct dvobj_priv *dvobj);
+
+struct sec_cam_ent;
+void dump_sec_cam_ent(void *sel, struct sec_cam_ent *ent, int id);
+void dump_sec_cam_ent_title(void *sel, u8 has_id);
+void dump_sec_cam(void *sel, _adapter *adapter);
+void dump_sec_cam_cache(void *sel, _adapter *adapter);
+
+#ifdef CONFIG_PROC_DEBUG
+ssize_t proc_set_write_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_read_reg(struct seq_file *m, void *v);
+ssize_t proc_set_read_reg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_fwstate(struct seq_file *m, void *v);
+int proc_get_sec_info(struct seq_file *m, void *v);
+int proc_get_mlmext_state(struct seq_file *m, void *v);
+#ifdef CONFIG_LAYER2_ROAMING
+int proc_get_roam_flags(struct seq_file *m, void *v);
+ssize_t proc_set_roam_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_roam_param(struct seq_file *m, void *v);
+ssize_t proc_set_roam_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_roam_tgt_addr(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_LAYER2_ROAMING */
+#ifdef CONFIG_RTW_80211R
+int proc_get_ft_flags(struct seq_file *m, void *v);
+ssize_t proc_set_ft_flags(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif
+int proc_get_qos_option(struct seq_file *m, void *v);
+int proc_get_ht_option(struct seq_file *m, void *v);
+int proc_get_rf_info(struct seq_file *m, void *v);
+int proc_get_scan_param(struct seq_file *m, void *v);
+ssize_t proc_set_scan_param(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_scan_abort(struct seq_file *m, void *v);
+#ifdef CONFIG_SCAN_BACKOP
+int proc_get_backop_flags_sta(struct seq_file *m, void *v);
+ssize_t proc_set_backop_flags_sta(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_backop_flags_ap(struct seq_file *m, void *v);
+ssize_t proc_set_backop_flags_ap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_SCAN_BACKOP */
+int proc_get_survey_info(struct seq_file *m, void *v);
+ssize_t proc_set_survey_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_ap_info(struct seq_file *m, void *v);
+ssize_t proc_reset_trx_info(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_trx_info(struct seq_file *m, void *v);
+ssize_t proc_set_tx_power_offset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_power_offset(struct seq_file *m, void *v);
+int proc_get_rate_ctl(struct seq_file *m, void *v);
+int proc_get_wifi_spec(struct seq_file *m, void *v);
+ssize_t proc_set_rate_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_bw_ctl(struct seq_file *m, void *v);
+ssize_t proc_set_bw_ctl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#ifdef DBG_RX_COUNTER_DUMP
+int proc_get_rx_cnt_dump(struct seq_file *m, void *v);
+ssize_t proc_set_rx_cnt_dump(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif
+int proc_get_dis_pwt(struct seq_file *m, void *v);
+ssize_t proc_set_dis_pwt(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_suspend_resume_info(struct seq_file *m, void *v);
+
+ssize_t proc_set_fwdl_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_del_rx_ampdu_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#ifdef CONFIG_DFS_MASTER
+int proc_get_dfs_master_test_case(struct seq_file *m, void *v);
+ssize_t proc_set_dfs_master_test_case(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_DFS_MASTER */
+ssize_t proc_set_wait_hiq_empty(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+int proc_get_rx_stat(struct seq_file *m, void *v);
+int proc_get_tx_stat(struct seq_file *m, void *v);
+#ifdef CONFIG_AP_MODE
+int proc_get_all_sta_info(struct seq_file *m, void *v);
+#endif /* CONFIG_AP_MODE */
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+int proc_get_best_channel(struct seq_file *m, void *v);
+ssize_t proc_set_best_channel(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+int proc_get_trx_info_debug(struct seq_file *m, void *v);
+
+int proc_get_rx_signal(struct seq_file *m, void *v);
+ssize_t proc_set_rx_signal(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_hw_status(struct seq_file *m, void *v);
+ssize_t proc_set_hw_status(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_ht_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ht_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_bw_mode(struct seq_file *m, void *v);
+ssize_t proc_set_bw_mode(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_ampdu_enable(struct seq_file *m, void *v);
+ssize_t proc_set_ampdu_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_mac_rptbuf(struct seq_file *m, void *v);
+
+int proc_get_rx_ampdu(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+void rtw_dump_dft_phy_cap(void *sel, _adapter *adapter);
+void rtw_get_dft_phy_cap(void *sel, _adapter *adapter);
+void rtw_dump_drv_phy_cap(void *sel, _adapter *adapter);
+
+int proc_get_rx_stbc(struct seq_file *m, void *v);
+ssize_t proc_set_rx_stbc(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_stbc_cap(struct seq_file *m, void *v);
+ssize_t proc_set_stbc_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_ldpc_cap(struct seq_file *m, void *v);
+ssize_t proc_set_ldpc_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#ifdef CONFIG_BEAMFORMING
+int proc_get_txbf_cap(struct seq_file *m, void *v);
+ssize_t proc_set_txbf_cap(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif
+int proc_get_rx_ampdu_factor(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_factor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_rx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_rx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+int proc_get_tx_ampdu_density(struct seq_file *m, void *v);
+ssize_t proc_set_tx_ampdu_density(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_TX_AMSDU
+int proc_get_tx_amsdu(struct seq_file *m, void *v);
+ssize_t proc_set_tx_amsdu(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_amsdu_rate(struct seq_file *m, void *v);
+ssize_t proc_set_tx_amsdu_rate(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif
+
+int proc_get_en_fwps(struct seq_file *m, void *v);
+ssize_t proc_set_en_fwps(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_BT_COEXIST
+int proc_get_btcoex_dbg(struct seq_file *m, void *v);
+ssize_t proc_set_btcoex_dbg(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_btcoex_info(struct seq_file *m, void *v);
+#endif /* CONFIG_BT_COEXIST */
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+int proc_get_sreset(struct seq_file *m, void *v);
+ssize_t proc_set_sreset(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* DBG_CONFIG_ERROR_DETECT */
+
+int proc_get_odm_adaptivity(struct seq_file *m, void *v);
+ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_DBG_COUNTER
+int proc_get_rx_logs(struct seq_file *m, void *v);
+int proc_get_tx_logs(struct seq_file *m, void *v);
+int proc_get_int_logs(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_PCI_HCI
+int proc_get_rx_ring(struct seq_file *m, void *v);
+int proc_get_tx_ring(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_WOWLAN
+int proc_get_pattern_info(struct seq_file *m, void *v);
+ssize_t proc_set_pattern_info(struct file *file, const char __user *buffer,
+		size_t count, loff_t *pos, void *data);
+int proc_get_wakeup_reason(struct seq_file *m, void *v);
+#endif
+
+#ifdef CONFIG_GPIO_WAKEUP
+int proc_get_wowlan_gpio_info(struct seq_file *m, void *v);
+ssize_t proc_set_wowlan_gpio_info(struct file *file, const char __user *buffer,
+		size_t count, loff_t *pos, void *data);
+#endif /*CONFIG_GPIO_WAKEUP*/
+
+#ifdef CONFIG_P2P_WOWLAN
+int proc_get_p2p_wowlan_info(struct seq_file *m, void *v);
+#endif /* CONFIG_P2P_WOWLAN */
+
+int proc_get_new_bcn_max(struct seq_file *m, void *v);
+ssize_t proc_set_new_bcn_max(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_POWER_SAVING
+int proc_get_ps_info(struct seq_file *m, void *v);
+#endif /* CONFIG_POWER_SAVING */
+
+#ifdef CONFIG_TDLS
+int proc_get_tdls_info(struct seq_file *m, void *v);
+#endif
+
+int proc_get_monitor(struct seq_file *m, void *v);
+ssize_t proc_set_monitor(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+int proc_get_rtkm_info(struct seq_file *m, void *v);
+#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */
+
+#ifdef CONFIG_IEEE80211W
+ssize_t proc_set_tx_sa_query(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_sa_query(struct seq_file *m, void *v);
+ssize_t proc_set_tx_deauth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_deauth(struct seq_file *m, void *v);
+ssize_t proc_set_tx_auth(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_tx_auth(struct seq_file *m, void *v);
+#endif /* CONFIG_IEEE80211W */
+
+#endif /* CONFIG_PROC_DEBUG */
+
+int proc_get_efuse_map(struct seq_file *m, void *v);
+ssize_t proc_set_efuse_map(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+#ifdef CONFIG_MCC_MODE
+int proc_get_mcc_info(struct seq_file *m, void *v);
+ssize_t proc_set_mcc_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_single_tx_criteria(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_ap_bw20_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_ap_bw40_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_ap_bw80_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_sta_bw20_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_sta_bw40_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+ssize_t proc_set_mcc_sta_bw80_target_tp(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+int proc_get_mcc_policy_table(struct seq_file *m, void *v);
+ssize_t proc_set_mcc_policy_table(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+#endif /* CONFIG_MCC_MODE */
+
+int proc_get_ack_timeout(struct seq_file *m, void *v);
+ssize_t proc_set_ack_timeout(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
+
+
+#define _drv_always_		1
+#define _drv_emerg_			2
+#define _drv_alert_			3
+#define _drv_crit_			4
+#define _drv_err_			5
+#define _drv_warning_		6
+#define _drv_notice_		7
+#define _drv_info_			8
+#define _drv_dump_			9
+#define _drv_debug_			10
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define _module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_		BIT(6)
+#define _module_rtl871x_cmd_c_			BIT(7)
+#define _module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_				BIT(9)
+#define _module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_			BIT(11)
+#define _module_rtl871x_security_c_		BIT(12)
+#define _module_rtl871x_eeprom_c_			BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_		BIT(16)
+#define _module_rtl871x_ioctl_set_c_		BIT(17)
+#define _module_rtl871x_ioctl_query_c_	BIT(18)
+#define _module_rtl871x_pwrctrl_c_			BIT(19)
+#define _module_hci_intfs_c_			BIT(20)
+#define _module_hci_ops_c_			BIT(21)
+#define _module_osdep_service_c_			BIT(22)
+#define _module_mp_			BIT(23)
+#define _module_hci_ops_os_c_			BIT(24)
+#define _module_rtl871x_ioctl_os_c		BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+/* #define _module_efuse_			BIT(27) */
+#define	_module_rtl8192c_xmit_c_ BIT(28)
+#define _module_hal_xmit_c_	BIT(28)
+#define _module_efuse_			BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#endif /* __RTW_DEBUG_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_eeprom.h b/drivers/staging/rtl8188eu/include/rtw_eeprom.h
new file mode 100644
index 000000000000..70750b5fad29
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_eeprom.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_EEPROM_H__
+#define __RTW_EEPROM_H__
+
+
+#define	RTL8712_EEPROM_ID			0x8712
+/* #define	EEPROM_MAX_SIZE			256 */
+
+#define	HWSET_MAX_SIZE_128		128
+#define	HWSET_MAX_SIZE_256		256
+#define	HWSET_MAX_SIZE_512		512
+#define HWSET_MAX_SIZE_1024		1024
+
+#define	EEPROM_MAX_SIZE			HWSET_MAX_SIZE_1024
+
+#define	CLOCK_RATE					50			/* 100us		 */
+
+/* - EEPROM opcodes */
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      /* Erase/write enable */
+#define EEPROM_EWDS_OPCODE		16      /* Erase/write disable */
+
+/* Country codes */
+#define USA							0x555320
+#define EUROPE						0x1 /* temp, should be provided later	 */
+#define JAPAN						0x2 /* temp, should be provided later */
+
+/*
+ * Customer ID, note that:
+ * This variable is initiailzed through EEPROM or registry,
+ * however, its definition may be different with that in EEPROM for
+ * EEPROM size consideration. So, we have to perform proper translation between them.
+ * Besides, CustomerID of registry has precedence of that of EEPROM.
+ * defined below. 060703, by rcnjko.
+ *   */
+typedef enum _RT_CUSTOMER_ID {
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,	/* Merge by Jacken, 2008/01/31. */
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_CHINA_MOBILE = 15,
+	RT_CID_819x_ALPHA = 16,
+	RT_CID_819x_Sitecom = 17,
+	RT_CID_CCX = 18, /* It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17. */
+	RT_CID_819X_LENOVO = 19,
+	RT_CID_819x_QMI = 20,
+	RT_CID_819x_Edimax_Belkin = 21,
+	RT_CID_819x_Sercomm_Belkin = 22,
+	RT_CID_819x_CAMEO1 = 23,
+	RT_CID_819x_MSI = 24,
+	RT_CID_819X_ACER = 25,
+	RT_CID_819x_AzWave_ASUS = 26,
+	RT_CID_819x_AzWave = 27, /* For AzWave in PCIe, The ID is AzWave use and not only Asus */
+	RT_CID_819x_HP = 28,
+	RT_CID_819x_WNC_COREGA = 29,
+	RT_CID_819x_Arcadyan_Belkin = 30,
+	RT_CID_819x_SAMSUNG = 31,
+	RT_CID_819x_CLEVO = 32,
+	RT_CID_819x_DELL = 33,
+	RT_CID_819x_PRONETS = 34,
+	RT_CID_819x_Edimax_ASUS = 35,
+	RT_CID_NETGEAR = 36,
+	RT_CID_PLANEX = 37,
+	RT_CID_CC_C = 38,
+	RT_CID_819x_Xavi = 39,
+	RT_CID_LENOVO_CHINA = 40,
+	RT_CID_INTEL_CHINA = 41,
+	RT_CID_TPLINK_HPWR = 42,
+	RT_CID_819x_Sercomm_Netgear = 43,
+	RT_CID_819x_ALPHA_Dlink = 44,/* add by ylb 20121012 for customer led for alpha */
+	RT_CID_WNC_NEC = 45,/* add by page for NEC */
+	RT_CID_DNI_BUFFALO = 46,/* add by page for NEC */
+} RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
+
+extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
+extern u16 eeprom_read16(_adapter *padapter, u16 reg);
+extern void read_eeprom_content(_adapter *padapter);
+extern void eeprom_read_sz(_adapter *padapter, u16 reg, u8 *data, u32 sz);
+
+extern void read_eeprom_content_by_attrib(_adapter	*padapter);
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+extern int isAdaptorInfoFileValid(void);
+extern int storeAdaptorInfoFile(char *path, u8 *efuse_data);
+extern int retriveAdaptorInfoFile(char *path, u8 *efuse_data);
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
+
+#endif /* __RTL871X_EEPROM_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_efuse.h b/drivers/staging/rtl8188eu/include/rtw_efuse.h
new file mode 100644
index 000000000000..b70b9052649c
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_efuse.h
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_EFUSE_H__
+#define __RTW_EFUSE_H__
+
+
+#define	EFUSE_ERROE_HANDLE		1
+
+#define	PG_STATE_HEADER		0x01
+#define	PG_STATE_WORD_0		0x02
+#define	PG_STATE_WORD_1		0x04
+#define	PG_STATE_WORD_2		0x08
+#define	PG_STATE_WORD_3		0x10
+#define	PG_STATE_DATA			0x20
+
+#define	PG_SWBYTE_H			0x01
+#define	PG_SWBYTE_L			0x02
+
+#define	PGPKT_DATA_SIZE		8
+
+#define	EFUSE_WIFI				0
+#define	EFUSE_BT				1
+
+enum _EFUSE_DEF_TYPE {
+	TYPE_EFUSE_MAX_SECTION				= 0,
+	TYPE_EFUSE_REAL_CONTENT_LEN			= 1,
+	TYPE_AVAILABLE_EFUSE_BYTES_BANK		= 2,
+	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL	= 3,
+	TYPE_EFUSE_MAP_LEN					= 4,
+	TYPE_EFUSE_PROTECT_BYTES_BANK		= 5,
+	TYPE_EFUSE_CONTENT_LEN_BANK			= 6,
+};
+
+#define		EFUSE_MAX_MAP_LEN		1024
+
+#define		EFUSE_MAX_HW_SIZE		1024
+#define		EFUSE_MAX_SECTION_BASE	16
+
+/*RTL8822B 8821C BT EFUSE Define 1 BANK 128 size logical map 1024*/ 
+#ifdef RTW_HALMAC
+#define BANK_NUM		1
+#define EFUSE_BT_REAL_BANK_CONTENT_LEN	128
+#define EFUSE_BT_REAL_CONTENT_LEN		(EFUSE_BT_REAL_BANK_CONTENT_LEN * BANK_NUM)
+#define EFUSE_BT_MAP_LEN				1024	/* 1k bytes */
+#define EFUSE_BT_MAX_SECTION			(EFUSE_BT_MAP_LEN / 8)
+#define EFUSE_PROTECT_BYTES_BANK		16
+#define AVAILABLE_EFUSE_ADDR(addr)	(addr < EFUSE_BT_REAL_CONTENT_LEN)
+#endif
+
+#define EXT_HEADER(header) ((header & 0x1F) == 0x0F)
+#define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
+#define GET_HDR_OFFSET_2_0(header) ((header & 0xE0) >> 5)
+
+#define		EFUSE_REPEAT_THRESHOLD_			3
+
+#define IS_MASKED_MP(ic, txt, offset) (EFUSE_IsAddressMasked_MP_##ic##txt(offset))
+#define IS_MASKED_TC(ic, txt, offset) (EFUSE_IsAddressMasked_TC_##ic##txt(offset))
+#define GET_MASK_ARRAY_LEN_MP(ic, txt) (EFUSE_GetArrayLen_MP_##ic##txt())
+#define GET_MASK_ARRAY_LEN_TC(ic, txt) (EFUSE_GetArrayLen_TC_##ic##txt())
+#define GET_MASK_ARRAY_MP(ic, txt, offset) (EFUSE_GetMaskArray_MP_##ic##txt(offset))
+#define GET_MASK_ARRAY_TC(ic, txt, offset) (EFUSE_GetMaskArray_TC_##ic##txt(offset))
+
+
+#define IS_MASKED(ic, txt, offset) (IS_MASKED_MP(ic, txt, offset))
+#define GET_MASK_ARRAY_LEN(ic, txt) (GET_MASK_ARRAY_LEN_MP(ic, txt))
+#define GET_MASK_ARRAY(ic, txt, out) do { GET_MASK_ARRAY_MP(ic, txt, out); } while (0)
+
+/* *********************************************
+ *	The following is for BT Efuse definition
+ * ********************************************* */
+#define		EFUSE_BT_MAX_MAP_LEN		1024
+#define		EFUSE_MAX_BANK			4
+#define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
+/* *********************************************
+ *--------------------------Define Parameters-------------------------------*/
+#define		EFUSE_MAX_WORD_UNIT			4
+
+/*------------------------------Define structure----------------------------*/
+typedef struct PG_PKT_STRUCT_A {
+	u8 offset;
+	u8 word_en;
+	u8 data[8];
+	u8 word_cnts;
+} PGPKT_STRUCT, *PPGPKT_STRUCT;
+
+typedef enum {
+	ERR_SUCCESS = 0,
+	ERR_DRIVER_FAILURE,
+	ERR_IO_FAILURE,
+	ERR_WI_TIMEOUT,
+	ERR_WI_BUSY,
+	ERR_BAD_FORMAT,
+	ERR_INVALID_DATA,
+	ERR_NOT_ENOUGH_SPACE,
+	ERR_WRITE_PROTECT,
+	ERR_READ_BACK_FAIL,
+	ERR_OUT_OF_RANGE
+} ERROR_CODE;
+
+/*------------------------------Define structure----------------------------*/
+typedef struct _EFUSE_HAL {
+	u8	fakeEfuseBank;
+	u32	fakeEfuseUsedBytes;
+	u8	fakeEfuseContent[EFUSE_MAX_HW_SIZE];
+	u8	fakeEfuseInitMap[EFUSE_MAX_MAP_LEN];
+	u8	fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN];
+	u32	EfuseUsedBytes;
+	u8	EfuseUsedPercentage;
+
+	u16	BTEfuseUsedBytes;
+	u8	BTEfuseUsedPercentage;
+	u8	BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+
+	u16	fakeBTEfuseUsedBytes;
+	u8	fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+	u8	fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN];
+	u8	fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN];
+
+	/* EFUSE Configuration, initialized in HAL_CmnInitPGData(). */
+	const u16  MaxSecNum_WiFi;
+	const u16  MaxSecNum_BT;
+	const u16  WordUnit;
+	const u16  PhysicalLen_WiFi;
+	const u16  PhysicalLen_BT;
+	const u16  LogicalLen_WiFi;
+	const u16  LogicalLen_BT;
+	const u16  BankSize;
+	const u16  TotalBankNum;
+	const u16  BankNum_WiFi;
+	const u16  BankNum_BT;
+	const u16  OOBProtectBytes;
+	const u16  ProtectBytes;
+	const u16  BankAvailBytes;
+	const u16  TotalAvailBytes_WiFi;
+	const u16  TotalAvailBytes_BT;
+	const u16  HeaderRetry;
+	const u16  DataRetry;
+
+	ERROR_CODE	  Status;
+
+} EFUSE_HAL, *PEFUSE_HAL;
+
+extern u8 maskfileBuffer[64];
+
+/*------------------------Export global variable----------------------------*/
+extern u8 fakeEfuseBank;
+extern u32 fakeEfuseUsedBytes;
+extern u8 fakeEfuseContent[];
+extern u8 fakeEfuseInitMap[];
+extern u8 fakeEfuseModifiedMap[];
+
+extern u32 BTEfuseUsedBytes;
+extern u8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 BTEfuseInitMap[];
+extern u8 BTEfuseModifiedMap[];
+
+extern u32 fakeBTEfuseUsedBytes;
+extern u8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 fakeBTEfuseInitMap[];
+extern u8 fakeBTEfuseModifiedMap[];
+/*------------------------Export global variable----------------------------*/
+u8	efuse_bt_GetCurrentSize(PADAPTER padapter, u16 *size);
+u16	efuse_bt_GetMaxSize(PADAPTER padapter);
+u16 efuse_GetavailableSize(PADAPTER adapter);
+
+u8	efuse_GetCurrentSize(PADAPTER padapter, u16 *size);
+u16	efuse_GetMaxSize(PADAPTER padapter);
+u8	rtw_efuse_access(PADAPTER padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
+u8	rtw_efuse_bt_access(PADAPTER adapter, u8 write, u16 addr, u16 cnts, u8 *data);
+
+u8	rtw_efuse_mask_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_BT_efuse_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_BT_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
+
+u16	Efuse_GetCurrentSize(PADAPTER pAdapter, u8 efuseType, bool bPseudoTest);
+u8	Efuse_CalculateWordCnts(u8 word_en);
+void	ReadEFuseByte(PADAPTER Adapter, u16 _offset, u8 *pbuf, bool bPseudoTest) ;
+void	EFUSE_GetEfuseDefinition(PADAPTER pAdapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
+u8	efuse_OneByteRead(PADAPTER pAdapter, u16 addr, u8 *data, bool	 bPseudoTest);
+u8	efuse_OneByteWrite(PADAPTER pAdapter, u16 addr, u8 data, bool	 bPseudoTest);
+
+void	BTEfuse_PowerSwitch(PADAPTER pAdapter, u8	bWrite, u8	 PwrState);
+void	Efuse_PowerSwitch(PADAPTER pAdapter, u8	bWrite, u8	 PwrState);
+int	Efuse_PgPacketRead(PADAPTER pAdapter, u8 offset, u8 *data, bool bPseudoTest);
+int	Efuse_PgPacketWrite(PADAPTER pAdapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+void	efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata);
+u8	Efuse_WordEnableDataWrite(PADAPTER pAdapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+void	EFUSE_ShadowMapUpdate(PADAPTER pAdapter, u8 efuseType, bool bPseudoTest);
+void	EFUSE_ShadowRead(PADAPTER pAdapter, u8 Type, u16 Offset, u32 *Value);
+
+void	hal_ReadEFuse_BT_logic_map(
+	PADAPTER	padapter,
+	u16			_offset,
+	u16			_size_byte,
+	u8			*pbuf
+);
+u8	EfusePgPacketWrite_BT(
+	PADAPTER	pAdapter,
+	u8			offset,
+	u8			word_en,
+	u8			*pData,
+	u8			bPseudoTest);
+u16 rtw_get_efuse_mask_arraylen(PADAPTER pAdapter);
+void rtw_efuse_mask_array(PADAPTER pAdapter, u8 *pArray);
+
+#define MAC_HIDDEN_MAX_BW_NUM 8
+extern const u8 _mac_hidden_max_bw_to_hal_bw_cap[];
+#define mac_hidden_max_bw_to_hal_bw_cap(max_bw) (((max_bw) >= MAC_HIDDEN_MAX_BW_NUM) ? 0 : _mac_hidden_max_bw_to_hal_bw_cap[(max_bw)])
+
+#define MAC_HIDDEN_PROTOCOL_NUM 4
+extern const u8 _mac_hidden_proto_to_hal_proto_cap[];
+#define mac_hidden_proto_to_hal_proto_cap(proto) (((proto) >= MAC_HIDDEN_PROTOCOL_NUM) ? 0 : _mac_hidden_proto_to_hal_proto_cap[(proto)])
+
+u8 mac_hidden_wl_func_to_hal_wl_func(u8 func);
+
+u8 rtw_efuse_file_read(PADAPTER padapter, u8 *filepatch, u8 *buf, u32 len);
+#ifdef CONFIG_EFUSE_CONFIG_FILE
+u32 rtw_read_efuse_from_file(const char *path, u8 *buf, int map_size);
+u32 rtw_read_macaddr_from_file(const char *path, u8 *buf);
+#endif /* CONFIG_EFUSE_CONFIG_FILE */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_event.h b/drivers/staging/rtl8188eu/include/rtw_event.h
new file mode 100644
index 000000000000..1244aa00b3fb
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_event.h
@@ -0,0 +1,119 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_EVENT_H_
+#define _RTW_EVENT_H_
+
+#ifdef CONFIG_H2CLBK
+	#include <h2clbk.h>
+#endif
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	WLAN_BSSID_EX bss;
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+};
+
+struct stadel_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2]; /* for reason */
+	unsigned char locally_generated;
+	int mac_id;
+};
+
+struct addba_event {
+	unsigned int tid;
+};
+
+struct wmm_event {
+	unsigned char wmm;
+};
+
+#ifdef CONFIG_H2CLBK
+struct c2hlbk_event {
+	unsigned char mac[6];
+	unsigned short	s0;
+	unsigned short	s1;
+	unsigned int	w0;
+	unsigned char	b0;
+	unsigned short  s2;
+	unsigned char	b1;
+	unsigned int	w1;
+};
+#endif/* CONFIG_H2CLBK */
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(_adapter *dev, u8 *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32
+
+struct event_node {
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];
+};
+
+
+#endif /* _WLANEVENT_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_ht.h b/drivers/staging/rtl8188eu/include/rtw_ht.h
new file mode 100644
index 000000000000..44a4777083c5
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ht.h
@@ -0,0 +1,203 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_HT_H_
+#define _RTW_HT_H_
+
+
+struct ht_priv {
+	u8	ht_option;
+	u8	ampdu_enable;/* for enable Tx A-MPDU */
+	u8	tx_amsdu_enable;/* for enable Tx A-MSDU */
+	u8	bss_coexist;/* for 20/40 Bss coexist */
+
+	/* u8	baddbareq_issued[16]; */
+	u32	tx_amsdu_maxlen; /* 1: 8k, 0:4k ; default:8k, for tx */
+	u32	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz, updated when join_callback. */
+
+	u8	rx_ampdu_min_spacing;
+
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi_20m;
+	u8	sgi_40m;
+
+	/* for processing Tx A-MPDU */
+	u8	agg_enable_bitmap;
+	/* u8	ADDBA_retry_count; */
+	u8	candidate_tid_bitmap;
+
+	u8	ldpc_cap;
+	u8	stbc_cap;
+	u8	beamform_cap;
+	u8	smps_cap; /*spatial multiplexing power save mode. 0:static SMPS, 1:dynamic SMPS, 3:SMPS disabled, 2:reserved*/
+
+	struct rtw_ieee80211_ht_cap ht_cap;
+
+};
+
+typedef enum AGGRE_SIZE {
+	HT_AGG_SIZE_8K = 0,
+	HT_AGG_SIZE_16K = 1,
+	HT_AGG_SIZE_32K = 2,
+	HT_AGG_SIZE_64K = 3,
+	VHT_AGG_SIZE_128K = 4,
+	VHT_AGG_SIZE_256K = 5,
+	VHT_AGG_SIZE_512K = 6,
+	VHT_AGG_SIZE_1024K = 7,
+} AGGRE_SIZE_E, *PAGGRE_SIZE_E;
+
+typedef enum _RT_HT_INF0_CAP {
+	RT_HT_CAP_USE_TURBO_AGGR = 0x01,
+	RT_HT_CAP_USE_LONG_PREAMBLE = 0x02,
+	RT_HT_CAP_USE_AMPDU = 0x04,
+	RT_HT_CAP_USE_WOW = 0x8,
+	RT_HT_CAP_USE_SOFTAP = 0x10,
+	RT_HT_CAP_USE_92SE = 0x20,
+	RT_HT_CAP_USE_88C_92C = 0x40,
+	RT_HT_CAP_USE_AP_CLIENT_MODE = 0x80,	/* AP team request to reserve this bit, by Emily */
+} RT_HT_INF0_CAPBILITY, *PRT_HT_INF0_CAPBILITY;
+
+typedef enum _RT_HT_INF1_CAP {
+	RT_HT_CAP_USE_VIDEO_CLIENT = 0x01,
+	RT_HT_CAP_USE_JAGUAR_BCUT = 0x02,
+	RT_HT_CAP_USE_JAGUAR_CCUT = 0x04,
+} RT_HT_INF1_CAPBILITY, *PRT_HT_INF1_CAPBILITY;
+
+#define	LDPC_HT_ENABLE_RX			BIT0
+#define	LDPC_HT_ENABLE_TX			BIT1
+#define	LDPC_HT_TEST_TX_ENABLE		BIT2
+#define	LDPC_HT_CAP_TX				BIT3
+
+#define	STBC_HT_ENABLE_RX			BIT0
+#define	STBC_HT_ENABLE_TX			BIT1
+#define	STBC_HT_TEST_TX_ENABLE		BIT2
+#define	STBC_HT_CAP_TX				BIT3
+
+#define	BEAMFORMING_HT_BEAMFORMER_ENABLE	BIT0	/* Declare our NIC supports beamformer */
+#define	BEAMFORMING_HT_BEAMFORMEE_ENABLE	BIT1	/* Declare our NIC supports beamformee */
+#define	BEAMFORMING_HT_BEAMFORMER_TEST		BIT2	/* Transmiting Beamforming no matter the target supports it or not */
+#define	BEAMFORMING_HT_BEAMFORMER_STEER_NUM		(BIT4 | BIT5)
+#define	BEAMFORMING_HT_BEAMFORMEE_CHNL_EST_CAP	(BIT6 | BIT7)
+
+/* ------------------------------------------------------------
+ * The HT Control field
+ * ------------------------------------------------------------ */
+#define SET_HT_CTRL_CSI_STEERING(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 6, 2, _val)
+#define SET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+3, 0, 1, _val)
+#define GET_HT_CTRL_NDP_ANNOUNCEMENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+3, 0, 1)
+
+/* 20/40 BSS Coexist */
+#define SET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_BSS_COEXIST(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)
+
+/* HT Capabilities Info field */
+#define HT_CAP_ELE_CAP_INFO(_pEleStart)					((u8 *)(_pEleStart))
+#define GET_HT_CAP_ELE_LDPC_CAP(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 1)
+#define GET_HT_CAP_ELE_CHL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 1, 1)
+#define GET_HT_CAP_ELE_SM_PS(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 2, 2)
+#define GET_HT_CAP_ELE_GREENFIELD(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 4, 1)
+#define GET_HT_CAP_ELE_SHORT_GI20M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 5, 1)
+#define GET_HT_CAP_ELE_SHORT_GI40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 6, 1)
+#define GET_HT_CAP_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 7, 1)
+#define GET_HT_CAP_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 0, 2)
+#define GET_HT_CAP_ELE_DELAYED_BA(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 2, 1)
+#define GET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 3, 1)
+#define GET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 4, 1)
+#define GET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 6, 1)
+#define GET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+1, 7, 1)
+
+#define SET_HT_CAP_ELE_LDPC_CAP(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 1, _val)
+#define SET_HT_CAP_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 1, 1, _val)
+#define SET_HT_CAP_ELE_SM_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 2, 2, _val)
+#define SET_HT_CAP_ELE_GREENFIELD(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 4, 1, _val)
+#define SET_HT_CAP_ELE_SHORT_GI20M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 5, 1, _val)
+#define SET_HT_CAP_ELE_SHORT_GI40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 6, 1, _val)
+#define SET_HT_CAP_ELE_TX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 7, 1, _val)
+#define SET_HT_CAP_ELE_RX_STBC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
+#define SET_HT_CAP_ELE_DELAYED_BA(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
+#define SET_HT_CAP_ELE_MAX_AMSDU_LENGTH(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
+#define SET_HT_CAP_ELE_DSSS_CCK_40M(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 4, 1, _val)
+#define SET_HT_CAP_ELE_FORTY_INTOLERANT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 6, 1, _val)
+#define SET_HT_CAP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 7, 1, _val)
+
+/* A-MPDU Parameters field */
+#define HT_CAP_ELE_AMPDU_PARA(_pEleStart)				(((u8 *)(_pEleStart))+2)
+#define GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(_pEleStart)	LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 0, 2)
+#define GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+2, 2, 3)
+
+#define HT_AMPDU_PARA_FMT "%02x " \
+	"MAX AMPDU len:%u bytes, MIN MPDU Start Spacing:%u"
+
+#define HT_AMPDU_PARA_ARG(x) \
+	*((u8 *)(x)) \
+	, (1 << (13+GET_HT_CAP_ELE_MAX_AMPDU_LEN_EXP(((u8 *)x)-2)))-1 \
+	, GET_HT_CAP_ELE_MIN_MPDU_S_SPACE(((u8 *)x)-2)
+
+/* Supported MCS Set field */
+#define HT_CAP_ELE_SUP_MCS_SET(_pEleStart)				(((u8 *)(_pEleStart))+3)
+#define HT_CAP_ELE_RX_MCS_MAP(_pEleStart)				HT_CAP_ELE_SUP_MCS_SET(_pEleStart)
+#define GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(_pEleStart)	LE_BITS_TO_2BYTE(((u8 *)(_pEleStart))+13, 0, 10)
+#define GET_HT_CAP_ELE_TX_MCS_DEF(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 0, 1)
+#define GET_HT_CAP_ELE_TRX_MCS_NEQ(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 1, 1)
+#define GET_HT_CAP_ELE_TX_MAX_SS(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 2, 2)
+#define GET_HT_CAP_ELE_TX_UEQM(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart))+15, 4, 1)
+
+#define HT_SUP_MCS_SET_FMT "%02x %02x %02x %02x %02x%02x%02x%02x%02x%02x" \
+	/* "\n%02x%02x%02x%02x%02x%02x" */\
+	" %uMbps %s%s%s"
+#define HT_SUP_MCS_SET_ARG(x) ((u8 *)(x))[0], ((u8 *)(x))[1], ((u8 *)(x))[2], ((u8 *)(x))[3], ((u8 *)(x))[4], ((u8 *)(x))[5], \
+	((u8 *)(x))[6], ((u8 *)(x))[7], ((u8 *)(x))[8], ((u8 *)(x))[9] \
+	/*,((u8 *)(x))[10], ((u8 *)(x))[11], ((u8 *)(x))[12], ((u8 *)(x))[13], ((u8 *)(x))[14], ((u8 *)(x))[15] */\
+	, GET_HT_CAP_ELE_RX_HIGHEST_DATA_RATE(((u8 *)x)-3) \
+	, GET_HT_CAP_ELE_TX_MCS_DEF(((u8 *)x)-3) ? "TX_MCS_DEF " : "" \
+	, GET_HT_CAP_ELE_TRX_MCS_NEQ(((u8 *)x)-3) ? "TRX_MCS_NEQ " : "" \
+	, GET_HT_CAP_ELE_TX_UEQM(((u8 *)x)-3) ? "TX_UEQM " : ""
+
+/* TXBF Capabilities */
+#define SET_HT_CAP_TXBF_RECEIVE_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 3, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_TRANSMIT_NDP_CAP(_pEleStart, _val)				SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 4, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 10, 1, ((u8)_val))
+#define SET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 15, 2, ((u8)_val))
+#define SET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 23, 2, ((u8)_val))
+#define SET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart, _val)	SET_BITS_TO_LE_4BYTE(((u8 *)(_pEleStart))+21, 27, 2, ((u8)_val))
+
+
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 10, 1)
+#define GET_HT_CAP_TXBF_EXPLICIT_COMP_FEEDBACK_CAP(_pEleStart)			LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 15, 2)
+#define GET_HT_CAP_TXBF_COMP_STEERING_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 23, 2)
+#define GET_HT_CAP_TXBF_CHNL_ESTIMATION_NUM_ANTENNAS(_pEleStart)		LE_BITS_TO_4BYTE(((u8 *)(_pEleStart))+21, 27, 2)
+
+/* HT Operation element */
+
+#define GET_HT_OP_ELE_PRI_CHL(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 8)
+#define SET_HT_OP_ELE_PRI_CHL(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 8, _val)
+
+/* HT Operation Info field */
+#define HT_OP_ELE_OP_INFO(_pEleStart)						(((u8 *)(_pEleStart)) + 1)
+#define GET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2)
+#define GET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1)
+#define GET_HT_OP_ELE_RIFS_MODE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1)
+#define GET_HT_OP_ELE_HT_PROTECT(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2)
+#define GET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1)
+#define GET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart)		LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1)
+#define GET_HT_OP_ELE_DUAL_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1)
+#define GET_HT_OP_ELE_DUAL_CTS(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1)
+#define GET_HT_OP_ELE_STBC_BEACON(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1)
+#define GET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart)			LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1)
+#define GET_HT_OP_ELE_PCO_ACTIVE(_pEleStart)				LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1)
+#define GET_HT_OP_ELE_PCO_PHASE(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1)
+
+#define SET_HT_OP_ELE_2ND_CHL_OFFSET(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 0, 2, _val)
+#define SET_HT_OP_ELE_STA_CHL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 2, 1, _val)
+#define SET_HT_OP_ELE_RIFS_MODE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 1, 3, 1, _val)
+#define SET_HT_OP_ELE_HT_PROTECT(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 0, 2, _val)
+#define SET_HT_OP_ELE_NON_GREEN_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 2, 1, _val)
+#define SET_HT_OP_ELE_OBSS_NON_HT_PRESENT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 2, 4, 1, _val)
+#define SET_HT_OP_ELE_DUAL_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 6, 1, _val)
+#define SET_HT_OP_ELE_DUAL_CTS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 4, 7, 1, _val)
+#define SET_HT_OP_ELE_STBC_BEACON(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 0, 1, _val)
+#define SET_HT_OP_ELE_LSIG_TXOP_PROTECT(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 1, 1, _val)
+#define SET_HT_OP_ELE_PCO_ACTIVE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1, _val)
+#define SET_HT_OP_ELE_PCO_PHASE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1, _val)
+
+#endif /* _RTL871X_HT_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_io.h b/drivers/staging/rtl8188eu/include/rtw_io.h
new file mode 100644
index 000000000000..42859f878b4a
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_io.h
@@ -0,0 +1,431 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+#ifndef _RTW_IO_H_
+#define _RTW_IO_H_
+
+#define NUM_IOREQ		8
+
+#define MAX_PROT_SZ	(64-16)
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+/* IO COMMAND TYPE */
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+/* IO STATUS TYPE */
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+
+
+
+/* below is for the intf_option bit defition... */
+
+#define _INTF_ASYNC_	BIT(0)	/* support async io */
+
+struct intf_priv;
+struct intf_hdl;
+struct io_queue;
+
+struct _io_ops {
+	u8(*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+	u16(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+	u32(*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+	int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, __le16 val);
+	int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, __le32 val);
+	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+
+	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, __le16 val);
+	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, __le32 val);
+
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+	void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+
+	u32(*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
+
+	u32(*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+	u32(*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+	u32(*_write_scsi)(struct intf_hdl *pintfhdl, u32 cnt, u8 *pmem);
+
+	void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+	void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+};
+
+struct io_req {
+	_list	list;
+	u32	addr;
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;
+	_sema	sema;
+
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;
+};
+
+struct	intf_hdl {
+	_adapter *padapter;
+	struct dvobj_priv *pintf_dev;/*	pointer to &(padapter->dvobjpriv); */
+
+	struct _io_ops	io_ops;
+
+};
+
+struct reg_protocol_rd {
+
+#ifdef __LITTLE_ENDIAN
+
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/* DW3 */
+	u32		BusAddress;
+	/* DW4 */
+	/* u32		Value; */
+#else
+
+
+	/* DW1 */
+	u32 Reserved2:24;
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+
+	/* DW2 */
+	u32 Reserved4:16;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 WriteEnable:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1;
+	u32 FixOrContinuous:1;
+	u32 ByteCount:7;
+
+	/* DW3 */
+	u32		BusAddress;
+
+	/* DW4 */
+	/* u32		Value; */
+
+#endif
+};
+
+struct reg_protocol_wt {
+
+
+#ifdef __LITTLE_ENDIAN
+
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/* DW3 */
+	u32		BusAddress;
+	/* DW4 */
+	u32		Value;
+
+#else
+	/* DW1 */
+	u32 Reserved2:24;
+	u32 Reserved1:4;
+	u32 NumOfTrans:4;
+
+
+	/* DW2 */
+	u32 Reserved4:16;
+	u32 Reserved3:3;
+	u32 Byte4Access:1;
+	u32 Byte2Access:1;
+	u32 Byte1Access:1;
+	u32 BurstMode:1;
+	u32 FixOrContinuous:1;
+	u32 WriteEnable:1;
+	u32 ByteCount:7;
+
+	/* DW3 */
+	u32		BusAddress;
+
+	/* DW4 */
+	u32		Value;
+
+#endif
+
+};
+
+#define MAX_CONTINUAL_IO_ERR 4
+
+int rtw_inc_and_chk_continual_io_error(struct dvobj_priv *dvobj);
+void rtw_reset_continual_io_error(struct dvobj_priv *dvobj);
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+struct io_queue {
+	_lock	lock;
+	_list	free_ioreqs;
+	_list		pending;		/* The io_req list that will be served in the single protocol read/write.	 */
+	_list		processing;
+	u8	*free_ioreqs_buf; /* 4-byte aligned */
+	u8	*pallocated_free_ioreqs_buf;
+	struct	intf_hdl	intf;
+};
+
+struct io_priv {
+
+	_adapter *padapter;
+
+	struct intf_hdl intf;
+
+};
+
+extern uint ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq, struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(_adapter *adapter, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void _rtw_attrib_read(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_attrib_write(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern u8 _rtw_read8(_adapter *adapter, u32 addr);
+extern u16 _rtw_read16(_adapter *adapter, u32 addr);
+extern u32 _rtw_read32(_adapter *adapter, u32 addr);
+extern void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port_cancel(_adapter *adapter);
+
+
+extern int _rtw_write8(_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16(_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32(_adapter *adapter, u32 addr, u32 val);
+extern int _rtw_writeN(_adapter *adapter, u32 addr, u32 length, u8 *pdata);
+
+extern int _rtw_write8_async(_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16_async(_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32_async(_adapter *adapter, u32 addr, u32 val);
+
+extern void _rtw_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+u32 _rtw_write_port_and_wait(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms);
+extern void _rtw_write_port_cancel(_adapter *adapter);
+
+#ifdef DBG_IO
+bool match_read_sniff_ranges(u32 addr, u16 len);
+bool match_write_sniff_ranges(u32 addr, u16 len);
+bool match_rf_read_sniff_ranges(u8 path, u32 addr, u32 mask);
+bool match_rf_write_sniff_ranges(u8 path, u32 addr, u32 mask);
+
+extern u8 dbg_rtw_read8(_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u16 dbg_rtw_read16(_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u32 dbg_rtw_read32(_adapter *adapter, u32 addr, const char *caller, const int line);
+
+extern int dbg_rtw_write8(_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
+extern int dbg_rtw_write16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
+extern int dbg_rtw_write32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
+extern int dbg_rtw_writeN(_adapter *adapter, u32 addr , u32 length , u8 *data, const char *caller, const int line);
+
+#define rtw_read8(adapter, addr) dbg_rtw_read8((adapter), (addr), __func__, __LINE__)
+#define rtw_read16(adapter, addr) dbg_rtw_read16((adapter), (addr), __func__, __LINE__)
+#define rtw_read32(adapter, addr) dbg_rtw_read32((adapter), (addr), __func__, __LINE__)
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) dbg_rtw_write8((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_write16(adapter, addr, val) dbg_rtw_write16((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_write32(adapter, addr, val) dbg_rtw_write32((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_writeN(adapter, addr, length, data) dbg_rtw_writeN((adapter), (addr), (length), (data), __func__, __LINE__)
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), addr, cnt, mem)
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port(adapter, addr, cnt, mem)
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel(adapter)
+
+#else /* DBG_IO */
+#define match_read_sniff_ranges(addr, len) false
+#define match_write_sniff_ranges(addr, len) false
+#define match_rf_read_sniff_ranges(path, addr, mask) false
+#define match_rf_write_sniff_ranges(path, addr, mask) false
+#define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
+#define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
+#define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) _rtw_write8((adapter), (addr), (val))
+#define  rtw_write16(adapter, addr, val) _rtw_write16((adapter), (addr), (val))
+#define  rtw_write32(adapter, addr, val) _rtw_write32((adapter), (addr), (val))
+#define  rtw_writeN(adapter, addr, length, data) _rtw_writeN((adapter), (addr), (length), (data))
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), (addr), (cnt), (mem))
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))
+
+#endif /* DBG_IO */
+
+extern void rtw_write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);
+
+/* ioreq */
+extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
+extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);
+extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
+extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
+extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
+extern void ioreq_write32(_adapter *adapter, u32 addr, u32 val);
+
+
+extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern void async_write8(_adapter *adapter, u32 addr, u8 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write16(_adapter *adapter, u32 addr, u16 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write32(_adapter *adapter, u32 addr, u32 val,
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_write_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+
+int rtw_init_io_priv(_adapter *padapter, void (*set_intf_ops)(_adapter *padapter, struct _io_ops *pops));
+
+
+extern uint alloc_io_queue(_adapter *adapter);
+extern void free_io_queue(_adapter *adapter);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(_adapter *Adapter, u8 bpwrup);
+
+/*
+#define RTL_R8(reg)		rtw_read8(padapter, reg)
+#define RTL_R16(reg)            rtw_read16(padapter, reg)
+#define RTL_R32(reg)            rtw_read32(padapter, reg)
+#define RTL_W8(reg, val8)       rtw_write8(padapter, reg, val8)
+#define RTL_W16(reg, val16)     rtw_write16(padapter, reg, val16)
+#define RTL_W32(reg, val32)     rtw_write32(padapter, reg, val32)
+*/
+
+/*
+#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(padapter, reg, val8)
+#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(padapter, reg, val16)
+#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(padapter, reg, val32)
+
+#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
+#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
+*/
+
+#define PlatformEFIOWrite1Byte(_a, _b, _c)		\
+	rtw_write8(_a, _b, _c)
+#define PlatformEFIOWrite2Byte(_a, _b, _c)		\
+	rtw_write16(_a, _b, _c)
+#define PlatformEFIOWrite4Byte(_a, _b, _c)		\
+	rtw_write32(_a, _b, _c)
+
+#define PlatformEFIORead1Byte(_a, _b)		\
+	rtw_read8(_a, _b)
+#define PlatformEFIORead2Byte(_a, _b)		\
+	rtw_read16(_a, _b)
+#define PlatformEFIORead4Byte(_a, _b)		\
+	rtw_read32(_a, _b)
+
+#endif /* _RTL8711_IO_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_ioctl.h b/drivers/staging/rtl8188eu/include/rtw_ioctl.h
new file mode 100644
index 000000000000..0fb73d887a01
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ioctl.h
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_IOCTL_H_
+#define _RTW_IOCTL_H_
+
+/*	00 - Success
+*	11 - Error */
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define NDIS_STATUS_SUCCESS			((NDIS_STATUS)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING			((NDIS_STATUS)STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED		((NDIS_STATUS)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED			((NDIS_STATUS)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED		((NDIS_STATUS)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE			((NDIS_STATUS)0x00010007L)
+
+#define NDIS_STATUS_FAILURE			((NDIS_STATUS)STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES			((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING			((NDIS_STATUS)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION			((NDIS_STATUS)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS		((NDIS_STATUS)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND		((NDIS_STATUS)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED			((NDIS_STATUS)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED		((NDIS_STATUS)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL		((NDIS_STATUS)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS		((NDIS_STATUS)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND		((NDIS_STATUS)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED		((NDIS_STATUS)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS		((NDIS_STATUS)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING		((NDIS_STATUS)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED		((NDIS_STATUS)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET		((NDIS_STATUS)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL		((NDIS_STATUS)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY		((NDIS_STATUS)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN		((NDIS_STATUS)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING		((NDIS_STATUS)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH		((NDIS_STATUS)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA		((NDIS_STATUS)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT		((NDIS_STATUS)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID			((NDIS_STATUS)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED		((NDIS_STATUS)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA		((NDIS_STATUS)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((NDIS_STATUS)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND		((NDIS_STATUS)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE		((NDIS_STATUS)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED		((NDIS_STATUS)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT		((NDIS_STATUS)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE			((NDIS_STATUS)0xC001001FL)
+
+#define NDIS_STATUS_INVALID_SAP			((NDIS_STATUS)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE			((NDIS_STATUS)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS		((NDIS_STATUS)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED		((NDIS_STATUS)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER		((NDIS_STATUS)0xC0010024L)  /* cause 27 */
+#define NDIS_STATUS_VC_NOT_AVAILABLE		((NDIS_STATUS)0xC0010025L)  /* cause 35, 45 */
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((NDIS_STATUS)0xC0010026L)  /* cause 37 */
+#define NDIS_STATUS_INCOMPATABLE_QOS		((NDIS_STATUS)0xC0010027L)  /* cause 49 */
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((NDIS_STATUS)0xC0010028L)  /* cause 93 */
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((NDIS_STATUS)0xC0010029L)  /* cause 3 */
+
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+/* For DDK-defined OIDs */
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+/* For Realtek-defined OIDs */
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+enum oid_type {
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; /* the starting number for OID */
+	unsigned int oid_end; /* the ending number for OID */
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; /* the size of node_array */
+	int query_counter; /* count the number of query hits for this segment  */
+	int set_counter; /* count the number of set hits for this segment  */
+};
+
+struct oid_par_priv {
+	void		*adapter_context;
+	NDIS_OID	oid;
+	void		*information_buf;
+	u32		information_buf_len;
+	u32		*bytes_rw;
+	u32		*bytes_needed;
+	enum oid_type	type_of_oid;
+	u32		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; /* 0: without OID debug message  1: with OID debug message */
+	NDIS_STATUS(*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+#if (defined(CONFIG_MP_INCLUDED) && defined(_RTW_MP_IOCTL_C_))
+static NDIS_STATUS oid_null_function(struct oid_par_priv *poid_par_priv)
+{
+	return NDIS_STATUS_SUCCESS;
+}
+#endif
+
+#if defined(CONFIG_WIRELESS_EXT)
+extern struct iw_handler_def  rtw_handlers_def;
+#endif
+
+extern void rtw_request_wps_pbc_event(_adapter *padapter);
+
+extern	NDIS_STATUS drv_query_info(
+	_nic_hdl		MiniportAdapterContext,
+	NDIS_OID		Oid,
+	void			*InformationBuffer,
+	u32			InformationBufferLength,
+	u32			*BytesWritten,
+	u32			*BytesNeeded
+);
+
+extern	NDIS_STATUS	drv_set_info(
+	_nic_hdl		MiniportAdapterContext,
+	NDIS_OID		Oid,
+	void			*InformationBuffer,
+	u32			InformationBufferLength,
+	u32			*BytesRead,
+	u32			*BytesNeeded
+);
+
+#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
+extern int rtw_vendor_ie_get_data(struct net_device*, int , char*);
+extern int rtw_vendor_ie_get(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);
+extern int rtw_vendor_ie_set(struct net_device*, struct iw_request_info*, union iwreq_data*, char*);
+#endif
+
+#endif /*  #ifndef __INC_CEINFO_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_ioctl_query.h b/drivers/staging/rtl8188eu/include/rtw_ioctl_query.h
new file mode 100644
index 000000000000..0ae178a9ef91
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ioctl_query.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_IOCTL_QUERY_H_
+#define _RTW_IOCTL_QUERY_H_
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_ioctl_rtl.h b/drivers/staging/rtl8188eu/include/rtw_ioctl_rtl.h
new file mode 100644
index 000000000000..ff935c5a3359
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ioctl_rtl.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_IOCTL_RTL_H_
+#define _RTW_IOCTL_RTL_H_
+
+
+/* ************** oid_rtl_seg_01_01 ************** */
+NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv *poid_par_priv);/* 84 */
+NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv *poid_par_priv);	/* 8a */
+NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv *poid_par_priv);	/* 8b */
+
+NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv *poid_par_priv);/* 93 */
+NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_bcn_intvl_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_dedicate_probe_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_current_tx_power_level_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_forced_data_rate_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv *poid_par_priv);
+
+/* **************  oid_rtl_seg_01_03 section start ************** */
+NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv *poid_par_priv);
+
+/* oid_rtl_seg_01_11 */
+NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv *poid_par_priv);
+
+/* **************  oid_rtl_seg_03_00 section start **************  */
+NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv *poid_par_priv);
+
+
+
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_ioctl_set.h b/drivers/staging/rtl8188eu/include/rtw_ioctl_set.h
new file mode 100644
index 000000000000..da87a90983d4
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_ioctl_set.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_IOCTL_SET_H_
+#define __RTW_IOCTL_SET_H_
+
+
+typedef u8 NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSIDInfo {
+	NDIS_802_11_MAC_ADDRESS  BSSID;
+	NDIS_802_11_PMKID_VALUE  PMKID;
+} BSSIDInfo, *PBSSIDInfo;
+
+u8 rtw_set_802_11_add_key(_adapter *padapter, NDIS_802_11_KEY *key);
+u8 rtw_set_802_11_authentication_mode(_adapter *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
+u8 rtw_set_802_11_bssid(_adapter *padapter, u8 *bssid);
+u8 rtw_set_802_11_add_wep(_adapter *padapter, NDIS_802_11_WEP *wep);
+u8 rtw_set_802_11_disassociate(_adapter *padapter);
+u8 rtw_set_802_11_bssid_list_scan(_adapter *padapter, NDIS_802_11_SSID *pssid, int ssid_max_num, struct rtw_ieee80211_channel *ch, int ch_num);
+u8 rtw_set_802_11_infrastructure_mode(_adapter *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 rtw_set_802_11_remove_wep(_adapter *padapter, u32 keyindex);
+u8 rtw_set_802_11_ssid(_adapter *padapter, NDIS_802_11_SSID *ssid);
+u8 rtw_set_802_11_connect(_adapter *padapter, u8 *bssid, NDIS_802_11_SSID *ssid);
+u8 rtw_set_802_11_remove_key(_adapter *padapter, NDIS_802_11_REMOVE_KEY *key);
+
+u8 rtw_validate_bssid(u8 *bssid);
+u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
+
+u16 rtw_get_cur_max_rate(_adapter *adapter);
+int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
+int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
+int rtw_set_country(_adapter *adapter, const char *country_code);
+int rtw_set_band(_adapter *adapter, u8 band);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_iol.h b/drivers/staging/rtl8188eu/include/rtw_iol.h
new file mode 100644
index 000000000000..89a1a0c1c0f8
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_iol.h
@@ -0,0 +1,120 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_IOL_H_
+#define __RTW_IOL_H_
+
+
+struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter);
+int rtw_IOL_append_cmds(struct xmit_frame *xmit_frame, u8 *IOL_cmds, u32 cmd_len);
+int rtw_IOL_append_LLT_cmd(struct xmit_frame *xmit_frame, u8 page_boundary);
+int rtw_IOL_exec_cmds_sync(ADAPTER *adapter, struct xmit_frame *xmit_frame, u32 max_wating_ms, u32 bndy_cnt);
+bool rtw_IOL_applied(ADAPTER *adapter);
+int rtw_IOL_append_DELAY_US_cmd(struct xmit_frame *xmit_frame, u16 us);
+int rtw_IOL_append_DELAY_MS_cmd(struct xmit_frame *xmit_frame, u16 ms);
+int rtw_IOL_append_END_cmd(struct xmit_frame *xmit_frame);
+
+
+#ifdef CONFIG_IOL_NEW_GENERATION
+#define IOREG_CMD_END_LEN	4
+
+struct ioreg_cfg {
+	u8	length;
+	u8	cmd_id;
+	__le16	address;
+	__le32	data;
+	__le32  mask;
+};
+enum ioreg_cmd {
+	IOREG_CMD_LLT			= 0x01,
+	IOREG_CMD_REFUSE		= 0x02,
+	IOREG_CMD_EFUSE_PATH = 0x03,
+	IOREG_CMD_WB_REG		= 0x04,
+	IOREG_CMD_WW_REG	= 0x05,
+	IOREG_CMD_WD_REG	= 0x06,
+	IOREG_CMD_W_RF		= 0x07,
+	IOREG_CMD_DELAY_US	= 0x10,
+	IOREG_CMD_DELAY_MS	= 0x11,
+	IOREG_CMD_END		= 0xFF,
+};
+void read_efuse_from_txpktbuf(ADAPTER *adapter, int bcnhead, u8 *content, u16 *size);
+
+int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, u8 mask);
+int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, u16 mask);
+int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, u32 mask);
+int _rtw_IOL_append_WRF_cmd(struct xmit_frame *xmit_frame, u8 rf_path, u16 addr, u32 value, u32 mask);
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value), (mask))
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value), (mask))
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value, mask) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value), (mask))
+#define rtw_IOL_append_WRF_cmd(xmit_frame, rf_path, addr, value, mask) _rtw_IOL_append_WRF_cmd((xmit_frame), (rf_path), (addr), (value), (mask))
+
+u8 rtw_IOL_cmd_boundary_handle(struct xmit_frame *pxmit_frame);
+void  rtw_IOL_cmd_buf_dump(ADAPTER *Adapter, int buf_len, u8 *pbuf);
+
+#ifdef CONFIG_IOL_IOREG_CFG_DBG
+struct cmd_cmp {
+	u16 addr;
+	u32 value;
+};
+#endif
+
+#else /* CONFIG_IOL_NEW_GENERATION */
+
+typedef struct _io_offload_cmd {
+	u8 rsvd0;
+	u8 cmd;
+	__le16 address;
+	__le32 value;
+} IO_OFFLOAD_CMD, IOL_CMD;
+
+#define IOL_CMD_LLT			0x00
+/* #define IOL_CMD_R_EFUSE	0x01 */
+#define IOL_CMD_WB_REG		0x02
+#define IOL_CMD_WW_REG	0x03
+#define IOL_CMD_WD_REG		0x04
+/* #define IOL_CMD_W_RF		0x05 */
+#define IOL_CMD_DELAY_US	0x80
+#define IOL_CMD_DELAY_MS	0x81
+/* #define IOL_CMD_DELAY_S	0x82 */
+#define IOL_CMD_END			0x83
+
+/*****************************************************
+CMD					Address			Value
+(B1)					(B2/B3:H/L addr)	(B4:B7 : MSB:LSB)
+******************************************************
+IOL_CMD_LLT			-				B7: PGBNDY
+IOL_CMD_R_EFUSE	-				-
+IOL_CMD_WB_REG		0x0~0xFFFF		B7
+IOL_CMD_WW_REG	0x0~0xFFFF		B6~B7
+IOL_CMD_WD_REG	0x0~0xFFFF		B4~B7
+IOL_CMD_W_RF		RF Reg			B5~B7
+IOL_CMD_DELAY_US	-				B6~B7
+IOL_CMD_DELAY_MS	-				B6~B7
+IOL_CMD_DELAY_S	-				B6~B7
+IOL_CMD_END		-				-
+******************************************************/
+int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value);
+int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value);
+int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value);
+
+
+int rtw_IOL_exec_cmd_array_sync(PADAPTER adapter, u8 *IOL_cmds, u32 cmd_num, u32 max_wating_ms);
+int rtw_IOL_exec_empty_cmds_sync(ADAPTER *adapter, u32 max_wating_ms);
+
+#ifdef DBG_IO
+int dbg_rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value, const char *caller, const int line);
+int dbg_rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value, const char *caller, const int line);
+int dbg_rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value, const char *caller, const int line);
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value), __func__, __LINE__)
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value), __func__, __LINE__)
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) dbg_rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value), __func__, __LINE__)
+#else
+#define rtw_IOL_append_WB_cmd(xmit_frame, addr, value) _rtw_IOL_append_WB_cmd((xmit_frame), (addr), (value))
+#define rtw_IOL_append_WW_cmd(xmit_frame, addr, value) _rtw_IOL_append_WW_cmd((xmit_frame), (addr), (value))
+#define rtw_IOL_append_WD_cmd(xmit_frame, addr, value) _rtw_IOL_append_WD_cmd((xmit_frame), (addr), (value))
+#endif /* DBG_IO */
+#endif /* CONFIG_IOL_NEW_GENERATION */
+
+
+
+#endif /* __RTW_IOL_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_mcc.h b/drivers/staging/rtl8188eu/include/rtw_mcc.h
new file mode 100644
index 000000000000..e4cabd0a95fa
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mcc.h
@@ -0,0 +1,205 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifdef CONFIG_MCC_MODE
+
+#ifndef _RTW_MCC_H_
+#define _RTW_MCC_H_
+
+#include <drv_types.h> /* PADAPTER */
+
+#define MCC_STATUS_PROCESS_MCC_START_SETTING BIT0
+#define MCC_STATUS_PROCESS_MCC_STOP_SETTING BIT1
+#define MCC_STATUS_NEED_MCC BIT2
+#define MCC_STATUS_DOING_MCC BIT3
+
+
+#define MCC_SWCH_FW_EARLY_TIME 10 /* ms */
+#define MCC_EXPIRE_TIME 50 /* ms */
+#define MCC_TOLERANCE_TIME 2 /* 2*2 = 4s */
+
+#define MCC_ROLE_STA_GC_MGMT_QUEUE_MACID 0
+#define MCC_ROLE_SOFTAP_GO_MGMT_QUEUE_MACID 1
+
+/* Lower for stop, Higher for start */
+#define MCC_SETCMD_STATUS_STOP_DISCONNECT 0x0
+#define MCC_SETCMD_STATUS_STOP_SCAN_START 0x1
+#define MCC_SETCMD_STATUS_START_CONNECT 0x80
+#define MCC_SETCMD_STATUS_START_SCAN_DONE 0x81
+
+/*
+* depenad platform or customer requirement(TP unit:Mbps),
+* must be provided by PM or sales or product document
+* too large value means not to limit tx bytes (current for ap mode)
+* NOTE: following values ref from test results
+*/
+#define MCC_AP_BW20_TARGET_TX_TP (300)
+#define MCC_AP_BW40_TARGET_TX_TP (300)
+#define MCC_AP_BW80_TARGET_TX_TP (300)
+#define MCC_STA_BW20_TARGET_TX_TP (35)
+#define MCC_STA_BW40_TARGET_TX_TP (70)
+#define MCC_STA_BW80_TARGET_TX_TP (140)
+#define MCC_SINGLE_TX_CRITERIA 5 /* Mbps */
+
+#define MAX_MCC_NUM 2
+
+#define MCC_STOP(adapter) (adapter->mcc_adapterpriv.mcc_tx_stop)
+#define MCC_EN(adapter) (adapter->registrypriv.en_mcc)
+
+/* Represent Channel Tx Null setting */
+enum mcc_channel_tx_null {
+	MCC_ENABLE_TX_NULL = 0,
+	MCC_DISABLE_TX_NULL = 1,
+};
+
+/* Represent C2H Report setting */
+enum mcc_c2h_report {
+	MCC_C2H_REPORT_DISABLE = 0,
+	MCC_C2H_REPORT_FAIL_STATUS = 1,
+	MCC_C2H_REPORT_ALL_STATUS = 2,
+};
+
+/* Represent Channel Scan */
+enum mcc_channel_scan {
+	MCC_CHIDX = 0,
+	MCC_SCANCH_RSVD_LOC = 1,
+};
+
+/* Represent FW status report of channel switch */
+enum mcc_status_rpt {
+	MCC_RPT_SUCCESS = 0,
+	MCC_RPT_TXNULL_FAIL = 1,
+	MCC_RPT_STOPMCC = 2,
+	MCC_RPT_READY = 3,
+	MCC_RPT_SWICH_CHANNEL_NOTIFY = 7,
+	MCC_RPT_UPDATE_NOA_START_TIME = 8,
+	MCC_RPT_MAX,
+};
+
+enum MCC_ROLE {
+	MCC_ROLE_STA = 0,
+	MCC_ROLE_AP = 1,
+	MCC_ROLE_GC = 2,
+	MCC_ROLE_GO = 3,
+	MCC_ROLE_MAX,
+};
+
+struct mcc_iqk_backup {
+	u16 TX_X;
+	u16 TX_Y;
+	u16 RX_X;
+	u16 RX_Y;
+};
+
+/*  mcc data for adapter */
+struct mcc_adapter_priv {
+	u8 order;		/* FW document, softap/AP must be 0 */
+	u8 role;			/* MCC role(AP,STA,GO,GC) */
+	u8 mcc_duration; /* channel stay period, UNIT:1TU */
+
+	/* flow control */
+	u8 mcc_tx_stop;				/* check if tp stop or not */
+	u8 mcc_tp_limit;				/* check if tp limit or not */
+	u32 mcc_target_tx_bytes_to_port;		/* customer require  */
+	u32 mcc_tx_bytes_to_port;	/* already tx to tx fifo (write port) */
+
+	/* data from kernel to check if enqueue data or netif stop queue */
+	u32 mcc_tp;
+	u64 mcc_tx_bytes_from_kernel;
+	u64 mcc_last_tx_bytes_from_kernel;
+
+	/* Backup IQK value for MCC */
+	struct mcc_iqk_backup mcc_iqk_arr[MAX_RF_PATH];
+
+	/* mgmt queue macid to avoid RA issue */
+	u8 mgmt_queue_macid;
+
+	/* set macid bitmap to let fw know which macid should be tx pause */
+	/* all interface share total 16 macid */
+	u16 mcc_macid_bitmap;
+
+	/* use for NoA start time (unit: mircoseconds) */
+	u32 noa_start_time;
+
+	u8 p2p_go_noa_ie[MAX_P2P_IE_LEN];
+	u32 p2p_go_noa_ie_len;
+};
+
+struct mcc_obj_priv {
+	u8 duration; /* channel stay period, UNIT:1TU */
+	u8 mcc_c2h_status;
+	u8 cur_mcc_success_cnt; /* used for check mcc switch channel success */
+	u8 prev_mcc_success_cnt; /* used for check mcc switch channel success */
+	u8 mcc_tolerance_time; /* used for detect mcc switch channel success */
+	u8 mcc_loc_rsvd_paga[MAX_MCC_NUM];  /* mcc rsvd page */
+	u8 mcc_status; /* mcc status stop or start .... */
+	u8 policy_index;
+	u32 mcc_launch_time; /* mcc launch time, used for starting detect mcc switch channel success */
+	_mutex mcc_mutex;
+	_lock mcc_lock;
+	PADAPTER iface[MAX_MCC_NUM]; /* by order, use for mcc parameter cmd */
+	struct submit_ctx mcc_sctx;
+};
+
+/* backup IQK val */
+void rtw_hal_mcc_restore_iqk_val(PADAPTER padapter);
+
+/* check mcc status */
+u8 rtw_hal_check_mcc_status(PADAPTER padapter, u8 mcc_status);
+
+/* set mcc status */
+void rtw_hal_set_mcc_status(PADAPTER padapter, u8 mcc_status);
+
+/* clear mcc status */
+void rtw_hal_clear_mcc_status(PADAPTER padapter, u8 mcc_status);
+
+/* dl mcc rsvd page */
+u8 rtw_hal_dl_mcc_fw_rsvd_page(_adapter *adapter, u8 *pframe, u16 *index
+	, u8 tx_desc, u32 page_size, u8 *page_num, u32 *total_pkt_len, RSVDPAGE_LOC *rsvd_page_loc);
+
+/* handle C2H */
+void rtw_hal_mcc_c2h_handler(PADAPTER padapter, u8 buflen, u8 *tmpBuf);
+
+/* switch channel successfully or not */
+void rtw_hal_mcc_sw_status_check(PADAPTER padapter);
+
+/* change some scan flags under site survey */
+u8 rtw_hal_mcc_change_scan_flag(PADAPTER padapter, u8 *ch, u8 *bw, u8 *offset);
+
+/* record data kernel TX to driver to check MCC concurrent TX  */
+void rtw_hal_mcc_calc_tx_bytes_from_kernel(PADAPTER padapter, u32 len);
+
+/* record data to port to let driver do flow ctrl  */
+void rtw_hal_mcc_calc_tx_bytes_to_port(PADAPTER padapter, u32 len);
+
+/* check stop write port or not  */
+u8 rtw_hal_mcc_stop_tx_bytes_to_port(PADAPTER padapter);
+
+u8 rtw_hal_set_mcc_setting_scan_start(PADAPTER padapter);
+
+u8 rtw_hal_set_mcc_setting_scan_complete(PADAPTER padapter);
+
+u8 rtw_hal_set_mcc_setting_start_bss_network(PADAPTER padapter, u8 chbw_grouped);
+
+u8 rtw_hal_set_mcc_setting_disconnect(PADAPTER padapter);
+
+u8 rtw_hal_set_mcc_setting_join_done_chk_ch(PADAPTER padapter);
+
+u8 rtw_hal_set_mcc_setting_chk_start_clnt_join(PADAPTER padapter, u8 *ch, u8 *bw, u8 *offset, u8 chbw_allow);
+
+void rtw_hal_dump_mcc_info(void *sel, struct dvobj_priv *dvobj);
+
+void update_mcc_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+
+u8 rtw_hal_mcc_link_status_chk(_adapter *padapter, const char *msg);
+
+void rtw_hal_mcc_issue_null_data(_adapter *padapter, u8 chbw_allow, u8 ps_mode);
+
+u8 *rtw_hal_mcc_append_go_p2p_ie(PADAPTER padapter, u8 *pframe, u32 *len);
+
+void rtw_hal_mcc_update_switch_channel_policy_table(PADAPTER padapter);
+
+void rtw_hal_dump_mcc_policy_table(void *sel);
+
+#endif /* _RTW_MCC_H_ */
+#endif /* CONFIG_MCC_MODE */
diff --git a/drivers/staging/rtl8188eu/include/rtw_mem.h b/drivers/staging/rtl8188eu/include/rtw_mem.h
new file mode 100644
index 000000000000..88625a0533c4
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mem.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_MEM_H__
+#define __RTW_MEM_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+
+#ifdef CONFIG_PLATFORM_MSTAR_HIGH
+	#define MAX_RTKM_RECVBUF_SZ (31744) /* 31k */
+#else
+	#define MAX_RTKM_RECVBUF_SZ (15360) /* 15k */
+#endif /* CONFIG_PLATFORM_MSTAR_HIGH */
+#define MAX_RTKM_NR_PREALLOC_RECV_SKB 16
+
+u16 rtw_rtkm_get_buff_size(void);
+u8 rtw_rtkm_get_nr_recv_skb(void);
+struct u8 *rtw_alloc_revcbuf_premem(void);
+struct sk_buff *rtw_alloc_skb_premem(u16 in_size);
+int rtw_free_skb_premem(struct sk_buff *pskb);
+
+
+#endif /* __RTW_MEM_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_mi.h b/drivers/staging/rtl8188eu/include/rtw_mi.h
new file mode 100644
index 000000000000..e66870f3e9d7
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mi.h
@@ -0,0 +1,220 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_MI_H_
+#define __RTW_MI_H_
+
+void rtw_mi_update_union_chan_inf(_adapter *adapter, u8 ch, u8 offset , u8 bw);
+int rtw_mi_get_ch_setting_union(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);
+int rtw_mi_get_ch_setting_union_no_self(_adapter *adapter, u8 *ch, u8 *bw, u8 *offset);
+
+struct mi_state {
+	u8 sta_num;			/*WIFI_FW_STATION_STATE*/
+	u8 ld_sta_num;		/*WIFI_FW_STATION_STATE |_FW_LINKED*/
+	u8 lg_sta_num;		/*WIFI_FW_STATION_STATE |_FW_UNDER_LINKING*/
+	u8 ap_num;			/*WIFI_FW_AP_STATE|_FW_LINKED*/
+	u8 ld_ap_num;		/*WIFI_FW_AP_STATE|_FW_LINKED && asoc_sta_count > 2*/
+	u8 adhoc_num;		/* WIFI_FW_ADHOC_STATE */
+	u8 ld_adhoc_num;	/* WIFI_FW_ADHOC_STATE && asoc_sta_count > 2 */
+	u8 uwps_num;		/*WIFI_UNDER_WPS*/
+
+#ifdef CONFIG_IOCTL_CFG80211
+	#ifdef CONFIG_P2P
+	u8 roch_num;
+	#endif
+	u8 mgmt_tx_num;
+#endif
+
+	u8 union_ch;
+	u8 union_bw;
+	u8 union_offset;
+};
+
+#define MSTATE_STA_NUM(_mstate)			((_mstate)->sta_num)
+#define MSTATE_STA_LD_NUM(_mstate)		((_mstate)->ld_sta_num)
+#define MSTATE_STA_LG_NUM(_mstate)		((_mstate)->lg_sta_num)
+#define MSTATE_AP_NUM(_mstate)			((_mstate)->ap_num)
+#define MSTATE_AP_LD_NUM(_mstate)		((_mstate)->ld_ap_num)
+#define MSTATE_ADHOC_NUM(_mstate)		((_mstate)->adhoc_num)
+#define MSTATE_ADHOC_LD_NUM(_mstate)	((_mstate)->ld_adhoc_num)
+#define MSTATE_WPS_NUM(_mstate)			((_mstate)->uwps_num)
+
+#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
+#define MSTATE_ROCH_NUM(_mstate)		((_mstate)->roch_num)
+#else
+#define MSTATE_ROCH_NUM(_mstate)		0
+#endif
+
+#if defined(CONFIG_IOCTL_CFG80211)
+#define MSTATE_MGMT_TX_NUM(_mstate)		((_mstate)->mgmt_tx_num)
+#else
+#define MSTATE_MGMT_TX_NUM(_mstate)		0
+#endif
+
+#define MSTATE_U_CH(_mstate)			((_mstate)->union_ch)
+#define MSTATE_U_BW(_mstate)			((_mstate)->union_bw)
+#define MSTATE_U_OFFSET(_mstate)		((_mstate)->union_offset)
+
+#define rtw_mi_get_union_chan(adapter)	adapter_to_dvobj(adapter)->iface_state.union_ch
+#define rtw_mi_get_union_bw(adapter)		adapter_to_dvobj(adapter)->iface_state.union_bw
+#define rtw_mi_get_union_offset(adapter)	adapter_to_dvobj(adapter)->iface_state.union_offset
+
+#define rtw_mi_get_assoced_sta_num(adapter)	DEV_STA_LD_NUM(adapter_to_dvobj(adapter))
+#define rtw_mi_get_ap_num(adapter)			DEV_AP_NUM(adapter_to_dvobj(adapter))
+
+/* For now, not return union_ch/bw/offset */
+void rtw_mi_status(_adapter *adapter, struct mi_state *mstate);
+void rtw_mi_status_no_self(_adapter *adapter, struct mi_state *mstate);
+
+void rtw_mi_update_iface_status(struct mlme_priv *pmlmepriv, sint state);
+
+u8 rtw_mi_mp_mode_check(_adapter *padapter);
+
+u8 rtw_mi_netif_stop_queue(_adapter *padapter, bool carrier_off);
+u8 rtw_mi_buddy_netif_stop_queue(_adapter *padapter, bool carrier_off);
+
+u8 rtw_mi_netif_wake_queue(_adapter *padapter);
+u8 rtw_mi_buddy_netif_wake_queue(_adapter *padapter);
+
+u8 rtw_mi_netif_carrier_on(_adapter *padapter);
+u8 rtw_mi_buddy_netif_carrier_on(_adapter *padapter);
+
+void rtw_mi_scan_abort(_adapter *adapter, bool bwait);
+void rtw_mi_buddy_scan_abort(_adapter *adapter, bool bwait);
+void rtw_mi_start_drv_threads(_adapter *adapter);
+void rtw_mi_buddy_start_drv_threads(_adapter *adapter);
+void rtw_mi_stop_drv_threads(_adapter *adapter);
+void rtw_mi_buddy_stop_drv_threads(_adapter *adapter);
+void rtw_mi_cancel_all_timer(_adapter *adapter);
+void rtw_mi_buddy_cancel_all_timer(_adapter *adapter);
+void rtw_mi_reset_drv_sw(_adapter *adapter);
+void rtw_mi_buddy_reset_drv_sw(_adapter *adapter);
+
+extern void rtw_intf_start(_adapter *adapter);
+extern void rtw_intf_stop(_adapter *adapter);
+void rtw_mi_intf_start(_adapter *adapter);
+void rtw_mi_buddy_intf_start(_adapter *adapter);
+void rtw_mi_intf_stop(_adapter *adapter);
+void rtw_mi_buddy_intf_stop(_adapter *adapter);
+
+void rtw_mi_suspend_free_assoc_resource(_adapter *adapter);
+void rtw_mi_buddy_suspend_free_assoc_resource(_adapter *adapter);
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+void rtw_mi_set_scan_deny(_adapter *adapter, u32 ms);
+void rtw_mi_buddy_set_scan_deny(_adapter *adapter, u32 ms);
+#else
+#define rtw_mi_set_scan_deny(adapter, ms) do {} while (0)
+#define rtw_mi_buddy_set_scan_deny(adapter, ms) do {} while (0)
+#endif
+
+u8 rtw_mi_is_scan_deny(_adapter *adapter);
+u8 rtw_mi_buddy_is_scan_deny(_adapter *adapter);
+
+u8 rtw_mi_issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+u8 rtw_mi_buddy_issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+
+void rtw_mi_beacon_update(_adapter *padapter);
+void rtw_mi_buddy_beacon_update(_adapter *padapter);
+
+void rtw_mi_hal_dump_macaddr(_adapter *padapter);
+void rtw_mi_buddy_hal_dump_macaddr(_adapter *padapter);
+
+#ifdef CONFIG_PCI_HCI
+void rtw_mi_xmit_tasklet_schedule(_adapter *padapter);
+void rtw_mi_buddy_xmit_tasklet_schedule(_adapter *padapter);
+#endif
+
+u8 rtw_mi_busy_traffic_check(_adapter *padapter, bool check_sc_interval);
+u8 rtw_mi_buddy_busy_traffic_check(_adapter *padapter, bool check_sc_interval);
+
+u8 rtw_mi_check_mlmeinfo_state(_adapter *padapter, u32 state);
+u8 rtw_mi_buddy_check_mlmeinfo_state(_adapter *padapter, u32 state);
+
+u8 rtw_mi_check_fwstate(_adapter *padapter, sint state);
+u8 rtw_mi_buddy_check_fwstate(_adapter *padapter, sint state);
+enum {
+	MI_LINKED,
+	MI_ASSOC,
+	MI_UNDER_WPS,
+	MI_AP_MODE,
+	MI_AP_ASSOC,
+	MI_ADHOC,
+	MI_ADHOC_ASSOC,
+	MI_STA_NOLINK, /* this is misleading, but not used now */
+	MI_STA_LINKED,
+	MI_STA_LINKING,
+};
+u8 rtw_mi_check_status(_adapter *adapter, u8 type);
+
+void dump_dvobj_mi_status(void *sel, const char *fun_name, _adapter *adapter);
+#ifdef DBG_IFACE_STATUS
+#define DBG_IFACE_STATUS_DUMP(adapter)	dump_dvobj_mi_status(RTW_DBGDUMP, __func__, adapter)
+#endif
+void dump_mi_status(void *sel, struct dvobj_priv *dvobj);
+
+u8 rtw_mi_traffic_statistics(_adapter *padapter);
+u8 rtw_mi_check_miracast_enabled(_adapter *padapter);
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+u8 rtw_mi_check_pending_xmitbuf(_adapter *padapter);
+u8 rtw_mi_buddy_check_pending_xmitbuf(_adapter *padapter);
+#endif
+
+#if defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
+	extern s32 _dequeue_writeport(PADAPTER padapter);
+u8 rtw_mi_dequeue_writeport(_adapter *padapter);
+u8 rtw_mi_buddy_dequeue_writeport(_adapter *padapter);
+#endif
+
+void rtw_mi_adapter_reset(_adapter *padapter);
+void rtw_mi_buddy_adapter_reset(_adapter *padapter);
+
+u8 rtw_mi_dynamic_check_timer_handler(_adapter *padapter);
+u8 rtw_mi_buddy_dynamic_check_timer_handler(_adapter *padapter);
+
+u8 rtw_mi_dev_unload(_adapter *padapter);
+u8 rtw_mi_buddy_dev_unload(_adapter *padapter);
+
+extern void rtw_iface_dynamic_chk_wk_hdl(_adapter *padapter);
+u8 rtw_mi_dynamic_chk_wk_hdl(_adapter *padapter);
+u8 rtw_mi_buddy_dynamic_chk_wk_hdl(_adapter *padapter);
+
+u8 rtw_mi_os_xmit_schedule(_adapter *padapter);
+u8 rtw_mi_buddy_os_xmit_schedule(_adapter *padapter);
+
+u8 rtw_mi_report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
+u8 rtw_mi_buddy_report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
+
+extern void sreset_start_adapter(_adapter *padapter);
+extern void sreset_stop_adapter(_adapter *padapter);
+u8 rtw_mi_sreset_adapter_hdl(_adapter *padapter, u8 bstart);
+u8 rtw_mi_buddy_sreset_adapter_hdl(_adapter *padapter, u8 bstart);
+
+u8 rtw_mi_tx_beacon_hdl(_adapter *padapter);
+u8 rtw_mi_buddy_tx_beacon_hdl(_adapter *padapter);
+
+u8 rtw_mi_set_tx_beacon_cmd(_adapter *padapter);
+u8 rtw_mi_buddy_set_tx_beacon_cmd(_adapter *padapter);
+
+#ifdef CONFIG_P2P
+u8 rtw_mi_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
+u8 rtw_mi_buddy_p2p_chk_state(_adapter *padapter, enum P2P_STATE p2p_state);
+u8 rtw_mi_stay_in_p2p_mode(_adapter *padapter);
+u8 rtw_mi_buddy_stay_in_p2p_mode(_adapter *padapter);
+#endif
+
+_adapter *rtw_get_iface_by_id(_adapter *padapter, u8 iface_id);
+_adapter *rtw_get_iface_by_macddr(_adapter *padapter, u8 *mac_addr);
+_adapter *rtw_get_iface_by_hwport(_adapter *padapter, u8 hw_port);
+
+void rtw_mi_buddy_clone_bcmc_packet(_adapter *padapter, union recv_frame *precvframe, u8 *pphy_status);
+
+#ifdef CONFIG_PCI_HCI
+/*API be create temporary for MI, caller is interrupt-handler, PCIE's interrupt handler cannot apply to multi-AP*/
+_adapter *rtw_mi_get_ap_adapter(_adapter *padapter);
+#endif
+
+void rtw_mi_update_ap_bmc_camid(_adapter *padapter, u8 camid_a, u8 camid_b);
+
+#endif /*__RTW_MI_H_*/
diff --git a/drivers/staging/rtl8188eu/include/rtw_mlme.h b/drivers/staging/rtl8188eu/include/rtw_mlme.h
new file mode 100644
index 000000000000..2f75bf27eec8
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mlme.h
@@ -0,0 +1,1176 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_MLME_H_
+#define __RTW_MLME_H_
+
+
+#define	MAX_BSS_CNT	128
+/* #define   MAX_JOIN_TIMEOUT	2000 */
+/* #define   MAX_JOIN_TIMEOUT	2500 */
+#define   MAX_JOIN_TIMEOUT	6500
+
+/*	Commented by Albert 20101105
+ *	Increase the scanning timeout because of increasing the SURVEY_TO value. */
+
+#define SCANNING_TIMEOUT 8000
+#ifdef CONFIG_SCAN_BACKOP
+#define CONC_SCANNING_TIMEOUT_SINGLE_BAND 10000
+#define CONC_SCANNING_TIMEOUT_DUAL_BAND 15000
+#endif
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 /* unit:us */
+#else
+#define	SCANQUEUE_LIFETIME 20000 /* 20sec, unit:msec */
+#endif
+
+#define WIFI_NULL_STATE					0x00000000
+#define WIFI_ASOC_STATE					0x00000001 /* Linked */
+#define WIFI_REASOC_STATE				0x00000002
+#define WIFI_SLEEP_STATE				0x00000004
+#define WIFI_STATION_STATE				0x00000008
+#define WIFI_AP_STATE					0x00000010
+#define WIFI_ADHOC_STATE				0x00000020
+#define WIFI_ADHOC_MASTER_STATE			0x00000040
+#define WIFI_UNDER_LINKING				0x00000080
+#define WIFI_UNDER_WPS					0x00000100
+/*#define WIFI_UNDEFINED_STATE			0x00000200*/
+#define WIFI_STA_ALIVE_CHK_STATE		0x00000400
+#define WIFI_SITE_MONITOR				0x00000800 /* under site surveying */
+#define WIFI_WDS						0x00001000
+#define WIFI_WDS_RX_BEACON				0x00002000 /* already rx WDS AP beacon */
+#define WIFI_AUTOCONF					0x00004000
+#define WIFI_AUTOCONF_IND				0x00008000
+#define WIFI_MP_STATE					0x00010000
+#define WIFI_MP_CTX_BACKGROUND			0x00020000 /* in continuous tx background */
+#define WIFI_MP_CTX_ST					0x00040000 /* in continuous tx with single-tone */
+#define WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000 /* pending in continuous tx background due to out of skb */
+#define WIFI_MP_CTX_CCK_HW				0x00100000 /* in continuous tx */
+#define WIFI_MP_CTX_CCK_CS				0x00200000 /* in continuous tx with carrier suppression */
+#define WIFI_MP_LPBK_STATE				0x00400000
+#define WIFI_OP_CH_SWITCHING			0x00800000
+/*#define WIFI_UNDEFINED_STATE			0x01000000*/
+/*#define WIFI_UNDEFINED_STATE			0x02000000*/
+/*#define WIFI_UNDEFINED_STATE			0x04000000*/
+/*#define WIFI_UNDEFINED_STATE			0x08000000*/
+/*#define WIFI_UNDEFINED_STATE			0x10000000*/
+/*#define WIFI_UNDEFINED_STATE			0x20000000*/
+/*#define WIFI_UNDEFINED_STATE			0x40000000*/
+#define WIFI_MONITOR_STATE				0x80000000
+
+#define MIRACAST_DISABLED	0
+#define MIRACAST_SOURCE		BIT0
+#define MIRACAST_SINK		BIT1
+
+#define MIRACAST_MODE_REVERSE(mode) \
+	((((mode) & MIRACAST_SOURCE) ? MIRACAST_SINK : 0) | (((mode) & MIRACAST_SINK) ? MIRACAST_SOURCE : 0))
+
+bool is_miracast_enabled(_adapter *adapter);
+bool rtw_chk_miracast_mode(_adapter *adapter, u8 mode);
+const char *get_miracast_mode_str(int mode);
+void rtw_wfd_st_switch(struct sta_info *sta, bool on);
+
+#define MLME_STATE(adapter) get_fwstate(&((adapter)->mlmepriv))
+
+#define MLME_IS_STA(adapter) (MLME_STATE((adapter)) & WIFI_STATION_STATE)
+#define MLME_IS_AP(adapter) (MLME_STATE((adapter)) & WIFI_AP_STATE)
+#define MLME_IS_ADHOC(adapter) (MLME_STATE((adapter)) & WIFI_ADHOC_STATE)
+#define MLME_IS_ADHOC_MASTER(adapter) (MLME_STATE((adapter)) & WIFI_ADHOC_MASTER_STATE)
+#define MLME_IS_MONITOR(adapter) (MLME_STATE((adapter)) & WIFI_MONITOR_STATE)
+#define MLME_IS_MP(adapter) (MLME_STATE((adapter)) & WIFI_MP_STATE)
+#ifdef CONFIG_P2P
+	#define MLME_IS_PD(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_DEVICE)
+	#define MLME_IS_GC(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_CLIENT)
+	#define MLME_IS_GO(adapter) rtw_p2p_chk_role(&(adapter)->wdinfo, P2P_ROLE_GO)
+#else /* !CONFIG_P2P */
+	#define MLME_IS_PD(adapter) 0
+	#define MLME_IS_GC(adapter) 0
+	#define MLME_IS_GO(adapter) 0
+#endif /* !CONFIG_P2P */
+
+#if defined(CONFIG_IOCTL_CFG80211) && defined(CONFIG_P2P)
+#define MLME_IS_ROCH(adapter) (rtw_cfg80211_get_is_roch(adapter) == true)
+#else
+#define MLME_IS_ROCH(adapter) 0
+#endif
+
+#define MLME_IS_MSRC(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SOURCE)
+#define MLME_IS_MSINK(adapter) rtw_chk_miracast_mode((adapter), MIRACAST_SINK)
+
+#ifdef CONFIG_IOCTL_CFG80211
+#define MLME_IS_MGMT_TX(adapter) rtw_cfg80211_get_is_mgmt_tx(adapter)
+#else
+#define MLME_IS_MGMT_TX(adapter) 0
+#endif
+
+#define MLME_STATE_FMT "%s%s%s%s%s%s%s%s%s%s%s%s"
+#define MLME_STATE_ARG(adapter) \
+	MLME_IS_STA((adapter)) ? (MLME_IS_GC((adapter)) ? " GC" : " STA") : \
+	MLME_IS_AP((adapter)) ? (MLME_IS_GO((adapter)) ? " GO" : " AP") : \
+	MLME_IS_ADHOC((adapter)) ? " ADHOC" : \
+	MLME_IS_ADHOC_MASTER((adapter)) ? " ADHOC_M" : \
+	MLME_IS_MONITOR((adapter)) ? " MONITOR" : \
+	MLME_IS_MP((adapter)) ? " MP" : "", \
+	MLME_IS_PD((adapter)) ? " PD" : "", \
+	MLME_IS_MSRC((adapter)) ? " MSRC" : "", \
+	MLME_IS_MSINK((adapter)) ? " MSINK" : "", \
+	(MLME_STATE((adapter)) & WIFI_SITE_MONITOR) ? " SCAN" : "", \
+	(MLME_STATE((adapter)) & WIFI_UNDER_LINKING) ? " LINKING" : "", \
+	(MLME_STATE((adapter)) & WIFI_ASOC_STATE) ? " ASOC" : "", \
+	(MLME_STATE((adapter)) & WIFI_OP_CH_SWITCHING) ? " OP_CH_SW" : "", \
+	(MLME_STATE((adapter)) & WIFI_UNDER_WPS) ? " WPS" : "", \
+	MLME_IS_ROCH((adapter)) ? " ROCH" : "", \
+	MLME_IS_MGMT_TX((adapter)) ? " MGMT_TX" : "", \
+	(MLME_STATE((adapter)) & WIFI_SLEEP_STATE) ? " SLEEP" : ""
+
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED			WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+
+enum dot11AuthAlgrthmNum {
+	dot11AuthAlgrthm_Open = 0,
+	dot11AuthAlgrthm_Shared,
+	dot11AuthAlgrthm_8021X,
+	dot11AuthAlgrthm_Auto,
+	dot11AuthAlgrthm_WAPI,
+	dot11AuthAlgrthm_MaxNum
+};
+
+/* Scan type including active and passive scan. */
+typedef enum _RT_SCAN_TYPE {
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+} RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+#define WIFI_FREQUENCY_BAND_AUTO 0
+#define WIFI_FREQUENCY_BAND_5GHZ 1
+#define WIFI_FREQUENCY_BAND_2GHZ 2
+
+#define rtw_band_valid(band) ((band) <= WIFI_FREQUENCY_BAND_2GHZ)
+
+enum DriverInterface {
+	DRIVER_WEXT =  1,
+	DRIVER_CFG80211 = 2
+};
+
+enum SCAN_RESULT_TYPE {
+	SCAN_RESULT_P2P_ONLY = 0,		/*	Will return all the P2P devices. */
+	SCAN_RESULT_ALL = 1,			/*	Will return all the scanned device, include AP. */
+	SCAN_RESULT_WFD_TYPE = 2		/*	Will just return the correct WFD device. */
+									/*	If this device is Miracast sink device, it will just return all the Miracast source devices. */
+};
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	sint	traffic_busy;
+	struct timer_list sitesurvey_ctrl_timer;
+};
+
+typedef struct _RT_LINK_DETECT_T {
+	u32				NumTxOkInPeriod;
+	u32				NumRxOkInPeriod;
+	u32				NumRxUnicastOkInPeriod;
+	bool			bBusyTraffic;
+	bool			bTxBusyTraffic;
+	bool			bRxBusyTraffic;
+	bool			bHigherBusyTraffic; /* For interrupt migration purpose. */
+	bool			bHigherBusyRxTraffic; /* We may disable Tx interrupt according as Rx traffic. */
+	bool			bHigherBusyTxTraffic; /* We may disable Tx interrupt according as Tx traffic. */
+	/* u8 TrafficBusyState; */
+	u8 TrafficTransitionCount;
+	u32 LowPowerTransitionCount;
+} RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;
+
+struct profile_info {
+	u8	ssidlen;
+	u8	ssid[WLAN_SSID_MAXLEN];
+	u8	peermac[ETH_ALEN];
+};
+
+struct tx_invite_req_info {
+	u8					token;
+	u8					benable;
+	u8					go_ssid[WLAN_SSID_MAXLEN];
+	u8					ssidlen;
+	u8					go_bssid[ETH_ALEN];
+	u8					peer_macaddr[ETH_ALEN];
+	u8					operating_ch;	/*	This information will be set by using the p2p_set op_ch=x */
+	u8					peer_ch;		/*	The listen channel for peer P2P device */
+
+};
+
+struct tx_invite_resp_info {
+	u8					token;	/*	Used to record the dialog token of p2p invitation request frame. */
+};
+
+#ifdef CONFIG_WFD
+
+struct wifi_display_info {
+	u16							wfd_enable;			/*	Eanble/Disable the WFD function. */
+	u16							init_rtsp_ctrlport;	/* init value of rtsp_ctrlport when WFD enable */
+	u16							rtsp_ctrlport;		/* TCP port number at which the this WFD device listens for RTSP messages, 0 when WFD disable */
+	u16							tdls_rtsp_ctrlport;	/* rtsp_ctrlport used by tdls, will sync when rtsp_ctrlport is changed by user */
+	u16							peer_rtsp_ctrlport;	/*	TCP port number at which the peer WFD device listens for RTSP messages */
+													/*	This filed should be filled when receiving the gropu negotiation request */
+
+	u8							peer_session_avail;	/*	WFD session is available or not for the peer wfd device. */
+													/*	This variable will be set when sending the provisioning discovery request to peer WFD device. */
+													/*	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command. */
+	u8							ip_address[4];
+	u8							peer_ip_address[4];
+	u8							wfd_pc;				/*	WFD preferred connection */
+													/*	0 -> Prefer to use the P2P for WFD connection on peer side. */
+													/*	1 -> Prefer to use the TDLS for WFD connection on peer side. */
+
+	u8							wfd_device_type;	/*	WFD Device Type */
+													/*	0 -> WFD Source Device */
+													/*	1 -> WFD Primary Sink Device */
+	enum	SCAN_RESULT_TYPE	scan_result_type;	/*	Used when P2P is enable. This parameter will impact the scan result. */
+	u8 op_wfd_mode;
+	u8 stack_wfd_mode;
+};
+#endif /* CONFIG_WFD */
+
+struct tx_provdisc_req_info {
+	u16					wps_config_method_request;	/*	Used when sending the provisioning request frame */
+	u16					peer_channel_num[2];		/*	The channel number which the receiver stands. */
+	NDIS_802_11_SSID	ssid;
+	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
+	u8					peerIFAddr[ETH_ALEN];		/*	Peer interface address */
+	u8					benable;					/*	This provision discovery request frame is trigger to send or not */
+};
+
+struct rx_provdisc_req_info {	/* When peer device issue prov_disc_req first, we should store the following informations */
+	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
+	u8					strconfig_method_desc_of_prov_disc_req[4];	/*	description for the config method located in the provisioning discovery request frame.	 */
+																	/*	The UI must know this information to know which config method the remote p2p device is requiring. */
+};
+
+struct tx_nego_req_info {
+	u16					peer_channel_num[2];		/*	The channel number which the receiver stands. */
+	u8					peerDevAddr[ETH_ALEN];		/*	Peer device address */
+	u8					benable;					/*	This negoitation request frame is trigger to send or not */
+	u8					peer_ch;					/*	The listen channel for peer P2P device */
+};
+
+struct group_id_info {
+	u8					go_device_addr[ETH_ALEN];	/*	The GO's device address of this P2P group */
+	u8					ssid[WLAN_SSID_MAXLEN];		/*	The SSID of this P2P group */
+};
+
+struct scan_limit_info {
+	u8					scan_op_ch_only;			/*	When this flag is set, the driver should just scan the operation channel */
+#ifndef CONFIG_P2P_OP_CHK_SOCIAL_CH
+	u8					operation_ch[2];				/*	Store the operation channel of invitation request frame */
+#else
+	u8					operation_ch[5];				/*	Store additional channel 1,6,11  for Android 4.2 IOT & Nexus 4 */
+#endif /* CONFIG_P2P_OP_CHK_SOCIAL_CH */
+};
+
+#ifdef CONFIG_IOCTL_CFG80211
+struct cfg80211_wifidirect_info {
+	struct timer_list 				remain_on_ch_timer;
+	u8						restore_channel;
+	struct ieee80211_channel	remain_on_ch_channel;
+	enum nl80211_channel_type	remain_on_ch_type;
+	ATOMIC_T ro_ch_cookie_gen;
+	u64 remain_on_ch_cookie;
+	bool is_ro_ch;
+	struct wireless_dev *ro_ch_wdev;
+	u32 last_ro_ch_time; /* this will be updated at the beginning and end of ro_ch */
+};
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+#ifdef CONFIG_P2P_WOWLAN
+
+enum P2P_WOWLAN_RECV_FRAME_TYPE {
+	P2P_WOWLAN_RECV_NEGO_REQ = 0,
+	P2P_WOWLAN_RECV_INVITE_REQ = 1,
+	P2P_WOWLAN_RECV_PROVISION_REQ = 2,
+};
+
+struct p2p_wowlan_info {
+
+	u8						is_trigger;
+	enum P2P_WOWLAN_RECV_FRAME_TYPE	wowlan_recv_frame_type;
+	u8						wowlan_peer_addr[ETH_ALEN];
+	u16						wowlan_peer_wpsconfig;
+	u8						wowlan_peer_is_persistent;
+	u8						wowlan_peer_invitation_type;
+};
+
+#endif /* CONFIG_P2P_WOWLAN */
+
+struct wifidirect_info {
+	_adapter				*padapter;
+	struct timer_list 				find_phase_timer;
+	struct timer_list 				restore_p2p_state_timer;
+
+	/*	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer. */
+	struct timer_list 				pre_tx_scan_timer;
+	struct timer_list 				reset_ch_sitesurvey;
+	struct timer_list 				reset_ch_sitesurvey2;	/*	Just for resetting the scan limit function by using p2p nego */
+#ifdef CONFIG_CONCURRENT_MODE
+	/*	Used to switch the channel between legacy AP and listen state. */
+	struct timer_list 				ap_p2p_switch_timer;
+#endif
+	struct tx_provdisc_req_info	tx_prov_disc_info;
+	struct rx_provdisc_req_info rx_prov_disc_info;
+	struct tx_invite_req_info	invitereq_info;
+	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	/*	Store the profile information of persistent group */
+	struct tx_invite_resp_info	inviteresp_info;
+	struct tx_nego_req_info	nego_req_info;
+	struct group_id_info		groupid_info;	/*	Store the group id information when doing the group negotiation handshake. */
+	struct scan_limit_info		rx_invitereq_info;	/*	Used for get the limit scan channel from the Invitation procedure */
+	struct scan_limit_info		p2p_info;		/*	Used for get the limit scan channel from the P2P negotiation handshake */
+#ifdef CONFIG_WFD
+	struct wifi_display_info		*wfd_info;
+#endif
+
+#ifdef CONFIG_P2P_WOWLAN
+	struct p2p_wowlan_info		p2p_wow_info;
+#endif /* CONFIG_P2P_WOWLAN */
+
+	enum P2P_ROLE			role;
+	enum P2P_STATE			pre_p2p_state;
+	enum P2P_STATE			p2p_state;
+	u8						device_addr[ETH_ALEN];	/*	The device address should be the mac address of this device. */
+	u8						interface_addr[ETH_ALEN];
+	u8						social_chan[4];
+	u8						listen_channel;
+	u8						operating_channel;
+	u8						listen_dwell;		/*	This value should be between 1 and 3 */
+	u8						support_rate[8];
+	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
+	u8						intent;		/*	should only include the intent value. */
+	u8						p2p_peer_interface_addr[ETH_ALEN];
+	u8						p2p_peer_device_addr[ETH_ALEN];
+	u8						peer_intent;	/*	Included the intent value and tie breaker value. */
+	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	/*	Device name for displaying on searching device screen */
+	u8						device_name_len;
+	u8						profileindex;	/*	Used to point to the index of profileinfo array */
+	u8						peer_operating_ch;
+	u8						find_phase_state_exchange_cnt;
+	u16						device_password_id_for_nego;	/*	The device password ID for group negotation */
+	u8						negotiation_dialog_token;
+	u8						nego_ssid[WLAN_SSID_MAXLEN];	/*	SSID information for group negotitation */
+	u8						nego_ssidlen;
+	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
+	u8						p2p_group_ssid_len;
+	u8						persistent_supported;		/*	Flag to know the persistent function should be supported or not. */
+														/*	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
+														/*	0: disable */
+														/*	1: enable */
+	u8						session_available;			/*	Flag to set the WFD session available to enable or disable "by Sigma" */
+														/*	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
+														/*	0: disable */
+														/*	1: enable */
+
+	u8						wfd_tdls_enable;			/*	Flag to enable or disable the TDLS by WFD Sigma */
+														/*	0: disable */
+														/*	1: enable */
+	u8						wfd_tdls_weaksec;			/*	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
+														/*	0: disable */
+														/*	In this case, the driver can't issue the tdsl setup request frame. */
+														/*	1: enable */
+														/*	In this case, the driver can issue the tdls setup request frame */
+														/*	even the current security is weak security. */
+
+	enum	P2P_WPSINFO		ui_got_wps_info;			/*	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
+	u16						supported_wps_cm;			/*	This field describes the WPS config method which this driver supported. */
+														/*	The value should be the combination of config method defined in page104 of WPS v2.0 spec.	 */
+	u8						external_uuid;				/* UUID flag */
+	u8						uuid[16];					/* UUID */
+	uint						channel_list_attr_len;	/*	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
+	u8						channel_list_attr[100];		/*	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
+														/*	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
+	u8						driver_interface;			/*	Indicate DRIVER_WEXT or DRIVER_CFG80211 */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	u16						ext_listen_interval;	/*	The interval to be available with legacy AP (ms) */
+	u16						ext_listen_period;	/*	The time period to be available for P2P listen state (ms) */
+#endif
+#ifdef CONFIG_P2P_PS
+	enum P2P_PS_MODE		p2p_ps_mode; /* indicate p2p ps mode */
+	enum P2P_PS_STATE		p2p_ps_state; /* indicate p2p ps state */
+	u8						noa_index; /* Identifies and instance of Notice of Absence timing. */
+	u8						ctwindow; /* Client traffic window. A period of time in TU after TBTT. */
+	u8						opp_ps; /* opportunistic power save. */
+	u8						noa_num; /* number of NoA descriptor in P2P IE. */
+	u8						noa_count[P2P_MAX_NOA_NUM]; /* Count for owner, Type of client. */
+	u32						noa_duration[P2P_MAX_NOA_NUM]; /* Max duration for owner, preferred or min acceptable duration for client. */
+	u32						noa_interval[P2P_MAX_NOA_NUM]; /* Length of interval for owner, preferred or max acceptable interval of client. */
+	u32						noa_start_time[P2P_MAX_NOA_NUM]; /* schedule expressed in terms of the lower 4 bytes of the TSF timer. */
+#endif /* CONFIG_P2P_PS */
+};
+
+struct tdls_ss_record {	/* signal strength record */
+	u8		macaddr[ETH_ALEN];
+	u8		RxPWDBAll;
+	u8		is_tdls_sta;	/* true: direct link sta, false: else */
+};
+
+struct tdls_temp_mgmt {
+	u8	initiator;	/* 0: None, 1: we initiate, 2: peer initiate */
+	u8	peer_addr[ETH_ALEN];
+};
+
+#ifdef CONFIG_TDLS_CH_SW
+struct tdls_ch_switch {
+	u32	ch_sw_state;
+	ATOMIC_T	chsw_on;
+	u8	addr[ETH_ALEN];
+	u8	off_ch_num;
+	u8	ch_offset;
+	u32	cur_time;
+	u8	delay_switch_back;
+	u8	dump_stack;
+	struct submit_ctx	chsw_sctx;
+};
+#endif
+
+struct tdls_info {
+	u8					ap_prohibited;
+	u8					ch_switch_prohibited;
+	u8					link_established;
+	u8					sta_cnt;
+	u8					sta_maximum;	/* 1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else; */
+	struct tdls_ss_record	ss_record;
+#ifdef CONFIG_TDLS_CH_SW
+	struct tdls_ch_switch	chsw_info;
+#endif
+
+	u8					ch_sensing;
+	u8					cur_channel;
+	u8					collect_pkt_num[MAX_CHANNEL_NUM];
+	_lock				cmd_lock;
+	_lock				hdl_lock;
+	u8					watchdog_count;
+	u8					dev_discovered;		/* WFD_TDLS: for sigma test */
+	u8					tdls_enable;
+
+	/* Let wpa_supplicant to setup*/
+	u8					driver_setup;
+#ifdef CONFIG_WFD
+	struct wifi_display_info		*wfd_info;
+#endif
+};
+
+struct tdls_txmgmt {
+	u8 peer[ETH_ALEN];
+	u8 action_code;
+	u8 dialog_token;
+	u16 status_code;
+	u8 *buf;
+	size_t len;
+};
+
+/* used for mlme_priv.roam_flags */
+enum {
+	RTW_ROAM_ON_EXPIRED = BIT0,
+	RTW_ROAM_ON_RESUME = BIT1,
+	RTW_ROAM_ACTIVE = BIT2,
+};
+
+struct beacon_keys {
+	u8 ssid[IW_ESSID_MAX_SIZE];
+	u32 ssid_len;
+	u8 bcn_channel;
+	u16 ht_cap_info;
+	u8 ht_info_infos_0_sco; /* bit0 & bit1 in infos[0] is second channel offset */
+	int encryp_protocol;
+	int pairwise_cipher;
+	int group_cipher;
+	int is_8021x;
+};
+#ifdef CONFIG_RTW_80211R
+#define FT_ACTION_REQ_LIMIT	4
+
+typedef enum _RTW_WIFI_FT_STA_STATUS {
+	RTW_FT_UNASSOCIATED_STA = 0,
+	RTW_FT_AUTHENTICATING_STA,
+	RTW_FT_AUTHENTICATED_STA,
+	RTW_FT_ASSOCIATING_STA,
+	RTW_FT_ASSOCIATED_STA,
+	RTW_FT_REQUESTING_STA,
+	RTW_FT_REQUESTED_STA,
+	RTW_FT_CONFIRMED_STA,
+	RTW_FT_UNSPECIFIED_STA
+} RTW_WIFI_FT_STA_STATUS;
+
+#define rtw_chk_ft_status(adapter, status) ((adapter)->mlmepriv.ftpriv.ft_status == status)
+#define rtw_set_ft_status(adapter, status) \
+	do { \
+		((adapter)->mlmepriv.ftpriv.ft_status = status); \
+	} while (0)
+
+#define rtw_reset_ft_status(adapter) \
+	do { \
+		((adapter)->mlmepriv.ftpriv.ft_status = RTW_FT_UNASSOCIATED_STA); \
+	} while (0)
+
+typedef enum _RTW_WIFI_FT_CAPABILITY {
+	RTW_FT_STA_SUPPORTED = BIT0,
+	RTW_FT_STA_OVER_DS_SUPPORTED = BIT1,
+	RTW_FT_SUPPORTED = BIT2,
+	RTW_FT_OVER_DS_SUPPORTED = BIT3,
+} RTW_WIFI_FT_CAPABILITY;
+
+#define rtw_chk_ft_flags(adapter, flags) ((adapter)->mlmepriv.ftpriv.ft_flags & (flags))
+#define rtw_set_ft_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.ftpriv.ft_flags |= (flags)); \
+	} while (0)
+
+#define rtw_clr_ft_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.ftpriv.ft_flags &= ~(flags)); \
+	} while (0)
+
+#define RTW_MAX_FTIE_SZ	256
+typedef struct _ft_priv {
+	u16	mdid;
+	u8	ft_cap;	/*b0: FT over DS, b1: Resource Req Protocol Cap, b2~b7: Reserved*/
+	u8	updated_ft_ies[RTW_MAX_FTIE_SZ];
+	u16	updated_ft_ies_len;
+	u8	ft_action[RTW_MAX_FTIE_SZ];
+	u16	ft_action_len;
+	struct cfg80211_ft_event_params ft_event;
+	u8	ft_roam_on_expired;
+	u8	ft_flags;
+	u32 ft_status;
+	u32 ft_req_retry_cnt;
+} ft_priv;
+#endif
+
+struct mlme_priv {
+
+	_lock	lock;
+	sint	fw_state;	/* shall we protect this variable? maybe not necessarily... */
+	u8 bScanInProcess;
+	u8	to_join; /* flag */
+#ifdef CONFIG_LAYER2_ROAMING
+	u8 to_roam; /* roaming trying times */
+	struct wlan_network *roam_network; /* the target of active roam */
+	u8 roam_flags;
+	u8 roam_rssi_diff_th; /* rssi difference threshold for active scan candidate selection */
+	u32 roam_scan_int_ms; /* scan interval for active roam */
+	u32 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
+	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
+	u8 roam_rssi_threshold;
+	bool need_to_roam;
+#endif
+
+	u8	*nic_hdl;
+
+#ifdef SUPPLICANT_RTK_VERSION_LOWER_THAN_JB42
+	u8	not_indic_disco;
+#endif
+	_list		*pscanned;
+	_queue	free_bss_pool;
+	_queue	scanned_queue;
+	u8		*free_bss_buf;
+	u32	num_of_scanned;
+
+	NDIS_802_11_SSID	assoc_ssid;
+	u8	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+	struct wlan_network *cur_network_scanned;
+
+	/* bcn check info */
+	struct beacon_keys cur_beacon_keys; /* save current beacon keys */
+	struct beacon_keys new_beacon_keys; /* save new beacon keys */
+	u8 new_beacon_cnts; /* if new_beacon_cnts >= threshold, ap beacon is changed */
+
+#ifdef CONFIG_ARP_KEEP_ALIVE
+	/* for arp offload keep alive */
+	u8 bGetGateway;
+	u8	GetGatewayTryCnt;
+	u8	gw_mac_addr[6];
+	u8	gw_ip[4];
+#endif
+
+	/* uint wireless_mode; no used, remove it */
+
+	u32	auto_scan_int_ms;
+
+	struct timer_list assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	struct timer_list scan_to_timer; /* driver itself handles scan_timeout status. */
+	u32 scan_start_time; /* used to evaluate the time spent in scanning */
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	struct timer_list set_scan_deny_timer;
+	ATOMIC_T set_scan_deny; /* 0: allowed, 1: deny */
+#endif
+
+	struct qos_priv qospriv;
+
+	/* Number of non-HT AP/stations */
+	int num_sta_no_ht;
+
+	/* Number of HT AP/stations 20 MHz */
+	/* int num_sta_ht_20mhz; */
+
+
+	int num_FortyMHzIntolerant;
+
+	struct ht_priv	htpriv;
+
+#ifdef CONFIG_BEAMFORMING
+#ifndef RTW_BEAMFORMING_VERSION_2
+#if (BEAMFORMING_SUPPORT == 0)/*for driver beamforming*/
+	struct beamforming_info	beamforming_info;
+#endif
+#endif /* !RTW_BEAMFORMING_VERSION_2 */
+#endif
+
+#ifdef CONFIG_DFS
+	u8	handle_dfs;
+#endif
+#ifdef CONFIG_DFS_MASTER
+	/* TODO: move to rfctl */
+	struct timer_list dfs_master_timer;
+#endif
+#ifdef CONFIG_RTW_80211R
+	ft_priv ftpriv;
+#endif
+
+	RT_LINK_DETECT_T	LinkDetectInfo;
+
+	u8	acm_mask; /* for wmm acm mask */
+	const struct country_chplan *country_ent;
+	u8	ChannelPlan;
+	RT_SCAN_TYPE	scan_mode; /* active: 1, passive: 0 */
+
+	u8 *wps_probe_req_ie;
+	u32 wps_probe_req_ie_len;
+
+	u8 ext_capab_ie_data[8];/*currently for ap mode only*/
+	u8 ext_capab_ie_len;
+
+#if defined(CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
+	 * in 802.11g BSS) */
+	int num_sta_non_erp;
+
+	/* Number of associated stations that do not support Short Slot Time */
+	int num_sta_no_short_slot_time;
+
+	/* Number of associated stations that do not support Short Preamble */
+	int num_sta_no_short_preamble;
+
+	ATOMIC_T olbc; /* Overlapping Legacy BSS Condition (Legacy b/g)*/
+
+	/* Number of HT associated stations that do not support greenfield */
+	int num_sta_ht_no_gf;
+
+	/* Number of associated non-HT stations */
+	/* int num_sta_no_ht; */
+
+	/* Number of HT associated stations 20 MHz */
+	int num_sta_ht_20mhz;
+
+	/* number of associated stations 40MHz intolerant */
+	int num_sta_40mhz_intolerant;
+
+	/* Overlapping BSS information */
+	ATOMIC_T olbc_ht;
+
+	int ht_20mhz_width_req;
+	int ht_intolerant_ch_reported;
+	u16 ht_op_mode;
+	u8 sw_to_20mhz; /*switch to 20Mhz BW*/
+
+#ifdef CONFIG_RTW_80211R
+	u8 *auth_rsp;
+	u32 auth_rsp_len;
+#endif
+	u8 *assoc_req;
+	u32 assoc_req_len;
+
+	u8 *assoc_rsp;
+	u32 assoc_rsp_len;
+
+	/* u8 *wps_probe_req_ie; */
+	/* u32 wps_probe_req_ie_len; */
+
+	u8 *wps_beacon_ie;
+	u32 wps_beacon_ie_len;
+
+	u8 *wps_probe_resp_ie;
+	u32 wps_probe_resp_ie_len;
+
+	u8 *wps_assoc_resp_ie;
+	u32 wps_assoc_resp_ie_len;
+
+	u8 *p2p_beacon_ie;
+	u32 p2p_beacon_ie_len;
+
+	u8 *p2p_probe_req_ie;
+	u32 p2p_probe_req_ie_len;
+
+	u8 *p2p_probe_resp_ie;
+	u32 p2p_probe_resp_ie_len;
+
+	u8 *p2p_go_probe_resp_ie;		/* for GO */
+	u32 p2p_go_probe_resp_ie_len;	/* for GO */
+
+	u8 *p2p_assoc_req_ie;
+	u32 p2p_assoc_req_ie_len;
+
+	u8 *p2p_assoc_resp_ie;
+	u32 p2p_assoc_resp_ie_len;
+
+	_lock	bcn_update_lock;
+	u8		update_bcn;
+
+	u8 ori_ch;
+	u8 ori_bw;
+	u8 ori_offset;
+#endif /* #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
+
+#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
+	u8 *wfd_beacon_ie;
+	u32 wfd_beacon_ie_len;
+
+	u8 *wfd_probe_req_ie;
+	u32 wfd_probe_req_ie_len;
+
+	u8 *wfd_probe_resp_ie;
+	u32 wfd_probe_resp_ie_len;
+
+	u8 *wfd_go_probe_resp_ie;		/* for GO */
+	u32 wfd_go_probe_resp_ie_len;	/* for GO */
+
+	u8 *wfd_assoc_req_ie;
+	u32 wfd_assoc_req_ie_len;
+
+	u8 *wfd_assoc_resp_ie;
+	u32 wfd_assoc_resp_ie_len;
+#endif
+
+#ifdef RTK_DMP_PLATFORM
+	/* DMP kobject_hotplug function  signal need in passive level */
+	_workitem	Linkup_workitem;
+	_workitem	Linkdown_workitem;
+#endif
+
+#ifdef CONFIG_INTEL_WIDI
+	int	widi_state;
+	int	listen_state;
+	struct timer_list listen_timer;
+	ATOMIC_T	rx_probe_rsp; /* 1:receive probe respone from RDS source. */
+	u8	*l2sdTaBuffer;
+	u8	channel_idx;
+	u8	group_cnt;	/* In WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed */
+	u8	sa_ext[L2SDTA_SERVICE_VE_LEN];
+
+	u8	widi_enable;
+	/**
+	 * For WiDi 4; upper layer would set
+	 * p2p_primary_device_type_category_id
+	 * p2p_primary_device_type_sub_category_id
+	 * p2p_secondary_device_type_category_id
+	 * p2p_secondary_device_type_sub_category_id
+	 */
+	u16	p2p_pdt_cid;
+	u16	p2p_pdt_scid;
+	u8	num_p2p_sdt;
+	u16	p2p_sdt_cid[MAX_NUM_P2P_SDT];
+	u16	p2p_sdt_scid[MAX_NUM_P2P_SDT];
+	u8	p2p_reject_disable;	/* When starting NL80211 wpa_supplicant/hostapd, it will call netdev_close */
+							/* such that it will cause p2p disabled. Use this flag to reject. */
+#endif /* CONFIG_INTEL_WIDI */
+	u32 lastscantime;
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	scanning_via_buddy_intf;
+#endif
+
+#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
+	u32 vendor_ie_mask[WLAN_MAX_VENDOR_IE_NUM];
+	u8 vendor_ie[WLAN_MAX_VENDOR_IE_NUM][WLAN_MAX_VENDOR_IE_LEN];
+	u32 vendor_ielen[WLAN_MAX_VENDOR_IE_NUM];
+#endif
+};
+
+#define mlme_set_scan_to_timer(mlme, ms) \
+	do { \
+		/* RTW_INFO("%s set_scan_to_timer(%p, %d)\n", __func__, (mlme), (ms)); */ \
+		_set_timer(&(mlme)->scan_to_timer, (ms)); \
+	} while (0)
+
+#define rtw_mlme_set_auto_scan_int(adapter, ms) \
+	do { \
+		adapter->mlmepriv.auto_scan_int_ms = ms; \
+	} while (0)
+
+#define RTW_AUTO_SCAN_REASON_UNSPECIFIED	0
+#define RTW_AUTO_SCAN_REASON_2040_BSS		BIT0
+#define RTW_AUTO_SCAN_REASON_ACS			BIT1
+#define RTW_AUTO_SCAN_REASON_ROAM			BIT2
+
+void rtw_mlme_reset_auto_scan_int(_adapter *adapter, u8 *reason);
+
+#ifdef CONFIG_AP_MODE
+
+struct hostapd_priv {
+	_adapter *padapter;
+
+#ifdef CONFIG_HOSTAPD_MLME
+	struct net_device *pmgnt_netdev;
+	struct usb_anchor anchored;
+#endif
+
+};
+
+extern int hostapd_mode_init(_adapter *padapter);
+extern void hostapd_mode_unload(_adapter *padapter);
+#endif
+
+
+extern void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf);
+extern void rtw_survey_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_surveydone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf);
+void rtw_sta_mstatus_report(_adapter *adapter);
+extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
+extern void rtw_wmm_event_callback(PADAPTER padapter, u8 *pbuf);
+#ifdef CONFIG_IEEE80211W
+void rtw_sta_timeout_event_callback(_adapter *adapter, u8 *pbuf);
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_RTW_80211R
+void rtw_update_ft_stainfo(_adapter *padapter, WLAN_BSSID_EX *pnetwork);
+void rtw_ft_reassoc_event_callback(_adapter *padapter, u8 *pbuf);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+extern void rtw_join_timeout_handler(RTW_TIMER_HDL_ARGS);
+extern void _rtw_scan_timeout_handler(RTW_TIMER_HDL_ARGS);
+#else
+void rtw_join_timeout_handler(struct timer_list *t);
+void _rtw_scan_timeout_handler(struct timer_list *t);
+#endif
+
+thread_return event_thread(thread_context context);
+
+extern void rtw_free_network_queue(_adapter *adapter, u8 isfreeall);
+extern int rtw_init_mlme_priv(_adapter *adapter);/* (struct mlme_priv *pmlmepriv); */
+
+extern void rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+
+extern sint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern sint rtw_set_key(_adapter *adapter, struct security_priv *psecuritypriv, sint keyid, u8 set_tx, bool enqueue);
+extern sint rtw_set_auth(_adapter *adapter, struct security_priv *psecuritypriv);
+
+__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{
+	/* if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid */
+	/* if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address */
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+__inline static sint check_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	if ((state == WIFI_NULL_STATE) &&
+		(pmlmepriv->fw_state == WIFI_NULL_STATE))
+		return true;
+
+	if (pmlmepriv->fw_state & state)
+		return true;
+
+	return false;
+}
+
+__inline static sint get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+extern void rtw_mi_update_iface_status(struct mlme_priv *pmlmepriv, sint state);
+
+static inline void set_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state |= state;
+
+	/*bScanInProcess hook in phydm*/
+	if (_FW_UNDER_SURVEY == state)
+		pmlmepriv->bScanInProcess = true;
+
+	rtw_mi_update_iface_status(pmlmepriv, state);
+}
+static inline void init_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state = state;
+
+	/*bScanInProcess hook in phydm*/
+	if (_FW_UNDER_SURVEY == state)
+		pmlmepriv->bScanInProcess = true;
+
+	rtw_mi_update_iface_status(pmlmepriv, state);
+}
+
+static inline void _clr_fwstate_(struct mlme_priv *pmlmepriv, sint state)
+{
+	pmlmepriv->fw_state &= ~state;
+
+	/*bScanInProcess hook in phydm*/
+	if (_FW_UNDER_SURVEY == state)
+		pmlmepriv->bScanInProcess = false;
+
+	rtw_mi_update_iface_status(pmlmepriv, state);
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+static inline void clr_fwstate(struct mlme_priv *pmlmepriv, sint state)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	_clr_fwstate_(pmlmepriv, state);
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+static inline void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+u8 rtw_is_adapter_up(_adapter *padapter);
+
+__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint val)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned = val;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
+extern void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target);
+extern void rtw_disconnect_hdl_under_linked(_adapter *adapter, struct sta_info *psta, u8 free_assoc);
+extern void rtw_generate_random_ibss(u8 *pibss);
+extern struct wlan_network *rtw_find_network(_queue *scanned_queue, u8 *addr);
+extern struct wlan_network *rtw_get_oldest_wlan_network(_queue *scanned_queue);
+struct wlan_network *_rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
+struct wlan_network *rtw_find_same_network(_queue *scanned_queue, struct wlan_network *network);
+
+extern void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue);
+extern void rtw_indicate_disconnect(_adapter *adapter, u16 reason, u8 locally_generated);
+extern void rtw_indicate_connect(_adapter *adapter);
+void rtw_indicate_scan_done(_adapter *padapter, bool aborted);
+
+void rtw_drv_scan_by_self(_adapter *padapter, u8 reason);
+void rtw_scan_wait_completed(_adapter *adapter);
+u32 rtw_scan_abort_timeout(_adapter *adapter, u32 timeout_ms);
+void rtw_scan_abort_no_wait(_adapter *adapter);
+void rtw_scan_abort(_adapter *adapter);
+
+extern int rtw_restruct_sec_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len);
+extern int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
+extern void rtw_init_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_update_registrypriv_dev_network(_adapter *adapter);
+
+extern void rtw_get_encrypt_decrypt_from_registrypriv(_adapter *adapter);
+
+extern void _rtw_join_timeout_handler(_adapter *adapter);
+extern void rtw_scan_timeout_handler(_adapter *adapter);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void _dynamic_check_timer_handler (void *FunctionContext);
+#else
+void _dynamic_check_timer_handler(struct timer_list *t);
+#endif
+extern void rtw_dynamic_check_timer_handler(_adapter *adapter);
+extern void rtw_iface_dynamic_check_timer_handler(_adapter *adapter);
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+bool rtw_is_scan_deny(_adapter *adapter);
+void rtw_clear_scan_deny(_adapter *adapter);
+void rtw_set_scan_deny_timer_hdl(_adapter *adapter);
+void rtw_set_scan_deny(_adapter *adapter, u32 ms);
+#else
+#define rtw_is_scan_deny(adapter) false
+#define rtw_clear_scan_deny(adapter) do {} while (0)
+#define rtw_set_scan_deny_timer_hdl(adapter) do {} while (0)
+#define rtw_set_scan_deny(adapter, ms) do {} while (0)
+#endif
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);
+
+#define MLME_BEACON_IE			0
+#define MLME_PROBE_REQ_IE		1
+#define MLME_PROBE_RESP_IE		2
+#define MLME_GO_PROBE_RESP_IE	3
+#define MLME_ASSOC_REQ_IE		4
+#define MLME_ASSOC_RESP_IE		5
+
+#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
+int rtw_mlme_update_wfd_ie_data(struct mlme_priv *mlme, u8 type, u8 *ie, u32 ie_len);
+#endif
+
+
+/* extern struct wlan_network* _rtw_dequeue_network(_queue *queue); */
+
+extern struct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
+extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+
+
+extern struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr);
+
+extern void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall);
+
+extern sint rtw_if_up(_adapter *padapter);
+
+sint rtw_linked_check(_adapter *padapter);
+
+u8 *rtw_get_capability_from_ie(u8 *ie);
+u8 *rtw_get_timestampe_from_ie(u8 *ie);
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
+
+void rtw_joinbss_reset(_adapter *padapter);
+
+void	rtw_ht_use_default_setting(_adapter *padapter);
+void rtw_build_wmm_ie_ht(_adapter *padapter, u8 *out_ie, uint *pout_len);
+unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel);
+void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel);
+void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtw_append_exented_cap(_adapter *padapter, u8 *out_ie, uint *pout_len);
+
+int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork);
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst, u8 feature);
+
+#ifdef CONFIG_LAYER2_ROAMING
+#define rtw_roam_flags(adapter) ((adapter)->mlmepriv.roam_flags)
+#define rtw_chk_roam_flags(adapter, flags) ((adapter)->mlmepriv.roam_flags & flags)
+#define rtw_clr_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags &= ~flags); \
+	} while (0)
+
+#define rtw_set_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags |= flags); \
+	} while (0)
+
+#define rtw_assign_roam_flags(adapter, flags) \
+	do { \
+		((adapter)->mlmepriv.roam_flags = flags); \
+	} while (0)
+
+void _rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_set_to_roam(_adapter *adapter, u8 to_roam);
+u8 rtw_dec_to_roam(_adapter *adapter);
+u8 rtw_to_roam(_adapter *adapter);
+int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
+#else
+#define rtw_roam_flags(adapter) 0
+#define rtw_chk_roam_flags(adapter, flags) 0
+#define rtw_clr_roam_flags(adapter, flags) do {} while (0)
+#define rtw_set_roam_flags(adapter, flags) do {} while (0)
+#define rtw_assign_roam_flags(adapter, flags) do {} while (0)
+#define _rtw_roaming(adapter, tgt_network) do {} while (0)
+#define rtw_roaming(adapter, tgt_network) do {} while (0)
+#define rtw_set_to_roam(adapter, to_roam) do {} while (0)
+#define rtw_dec_to_roam(adapter) 0
+#define rtw_to_roam(adapter) 0
+#define rtw_select_roaming_candidate(mlme) _FAIL
+#endif /* CONFIG_LAYER2_ROAMING */
+
+bool rtw_adjust_chbw(_adapter *adapter, u8 req_ch, u8 *req_bw, u8 *req_offset);
+
+struct sta_media_status_rpt_cmd_parm {
+	struct sta_info *sta;
+	bool connected;
+};
+
+void rtw_sta_media_status_rpt(_adapter *adapter, struct sta_info *sta, bool connected);
+u8 rtw_sta_media_status_rpt_cmd(_adapter *adapter, struct sta_info *sta, bool connected);
+void rtw_sta_media_status_rpt_cmd_hdl(_adapter *adapter, struct sta_media_status_rpt_cmd_parm *parm);
+void rtw_indicate_wx_assoc_event(_adapter *padapter);
+void rtw_indicate_wx_disassoc_event(_adapter *padapter);
+void indicate_wx_scan_complete_event(_adapter *padapter);
+
+#ifdef CONFIG_INTEL_PROXIM
+void rtw_proxim_enable(_adapter *padapter);
+void rtw_proxim_disable(_adapter *padapter);
+void rtw_proxim_send_packet(_adapter *padapter, u8 *pbuf, u16 len, u8 m_rate);
+#endif /* CONFIG_INTEL_PROXIM */
+
+#define IPV4_SRC(_iphdr)			(((u8 *)(_iphdr)) + 12)
+#define IPV4_DST(_iphdr)			(((u8 *)(_iphdr)) + 16)
+#define GET_IPV4_IHL(_iphdr)		BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 0, 0, 4)
+#define GET_IPV4_PROTOCOL(_iphdr)	BE_BITS_TO_1BYTE(((u8 *)(_iphdr)) + 9, 0, 8)
+#define GET_IPV4_SRC(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 12, 0, 32)
+#define GET_IPV4_DST(_iphdr)		BE_BITS_TO_4BYTE(((u8 *)(_iphdr)) + 16, 0, 32)
+
+#define GET_UDP_SRC(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 0, 0, 16)
+#define GET_UDP_DST(_udphdr)			BE_BITS_TO_2BYTE(((u8 *)(_udphdr)) + 2, 0, 16)
+
+#define TCP_SRC(_tcphdr)				(((u8 *)(_tcphdr)) + 0)
+#define TCP_DST(_tcphdr)				(((u8 *)(_tcphdr)) + 2)
+#define GET_TCP_SRC(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 0, 0, 16)
+#define GET_TCP_DST(_tcphdr)			BE_BITS_TO_2BYTE(((u8 *)(_tcphdr)) + 2, 0, 16)
+#define GET_TCP_SEQ(_tcphdr)			BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 4, 0, 32)
+#define GET_TCP_ACK_SEQ(_tcphdr)		BE_BITS_TO_4BYTE(((u8 *)(_tcphdr)) + 8, 0, 32)
+#define GET_TCP_DOFF(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 12, 4, 4)
+#define GET_TCP_FIN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 0, 1)
+#define GET_TCP_SYN(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 1, 1)
+#define GET_TCP_RST(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 2, 1)
+#define GET_TCP_PSH(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 3, 1)
+#define GET_TCP_ACK(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 4, 1)
+#define GET_TCP_URG(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 5, 1)
+#define GET_TCP_ECE(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 6, 1)
+#define GET_TCP_CWR(_tcphdr)			BE_BITS_TO_1BYTE(((u8 *)(_tcphdr)) + 13, 7, 1)
+
+#endif /* __RTL871X_MLME_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_mlme_ext.h b/drivers/staging/rtl8188eu/include/rtw_mlme_ext.h
new file mode 100644
index 000000000000..14ffc6ce68d3
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mlme_ext.h
@@ -0,0 +1,1257 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_MLME_EXT_H_
+#define __RTW_MLME_EXT_H_
+
+
+/*	Commented by Albert 20101105
+ *	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
+ *	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
+ *	So, this driver tried to extend the dwell time for each scanning channel.
+ *	This will increase the chance to receive the probe response from SoftAP. */
+
+#define SURVEY_TO		(100)
+#define REAUTH_TO		(300) /* (50) */
+#define REASSOC_TO		(300) /* (50) */
+/* #define DISCONNECT_TO	(3000) */
+#define ADDBA_TO			(2000)
+
+#define LINKED_TO (1) /* unit:2 sec, 1x2 = 2 sec */
+
+#define REAUTH_LIMIT	(4)
+#define REASSOC_LIMIT	(4)
+#define READDBA_LIMIT	(2)
+
+#ifdef CONFIG_GSPI_HCI
+	#define ROAMING_LIMIT	5
+#else
+	#define ROAMING_LIMIT	8
+#endif
+/* #define	IOCMD_REG0		0x10250370 */
+/* #define	IOCMD_REG1		0x10250374 */
+/* #define	IOCMD_REG2		0x10250378 */
+
+/* #define	FW_DYNAMIC_FUN_SWITCH	0x10250364 */
+
+/* #define	WRITE_BB_CMD		0xF0000001 */
+/* #define	SET_CHANNEL_CMD	0xF3000000 */
+/* #define	UPDATE_RA_CMD	0xFD0000A2 */
+
+#define _HW_STATE_NOLINK_		0x00
+#define _HW_STATE_ADHOC_		0x01
+#define _HW_STATE_STATION_	0x02
+#define _HW_STATE_AP_			0x03
+#define _HW_STATE_MONITOR_ 0x04
+
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+/********************************************************
+MCS rate definitions
+*********************************************************/
+#define MCS_RATE_1R	(0x000000ff)
+#define MCS_RATE_2R	(0x0000ffff)
+#define MCS_RATE_3R	(0x00ffffff)
+#define MCS_RATE_4R	(0xffffffff)
+#define MCS_RATE_2R_13TO15_OFF	(0x00001fff)
+
+
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WMM_OUI[];
+extern unsigned char WPS_OUI[];
+extern unsigned char WFD_OUI[];
+extern unsigned char P2P_OUI[];
+
+extern unsigned char WMM_INFO_OUI[];
+extern unsigned char WMM_PARA_OUI[];
+
+typedef enum _RT_CHANNEL_DOMAIN {
+	/* ===== 0x00 ~ 0x1F, legacy channel plan ===== */
+	RTW_CHPLAN_FCC = 0x00,
+	RTW_CHPLAN_IC = 0x01,
+	RTW_CHPLAN_ETSI = 0x02,
+	RTW_CHPLAN_SPAIN = 0x03,
+	RTW_CHPLAN_FRANCE = 0x04,
+	RTW_CHPLAN_MKK = 0x05,
+	RTW_CHPLAN_MKK1 = 0x06,
+	RTW_CHPLAN_ISRAEL = 0x07,
+	RTW_CHPLAN_TELEC = 0x08,
+	RTW_CHPLAN_GLOBAL_DOAMIN = 0x09,
+	RTW_CHPLAN_WORLD_WIDE_13 = 0x0A,
+	RTW_CHPLAN_TAIWAN = 0x0B,
+	RTW_CHPLAN_CHINA = 0x0C,
+	RTW_CHPLAN_SINGAPORE_INDIA_MEXICO = 0x0D,
+	RTW_CHPLAN_KOREA = 0x0E,
+	RTW_CHPLAN_TURKEY = 0x0F,
+	RTW_CHPLAN_JAPAN = 0x10,
+	RTW_CHPLAN_FCC_NO_DFS = 0x11,
+	RTW_CHPLAN_JAPAN_NO_DFS = 0x12,
+	RTW_CHPLAN_WORLD_WIDE_5G = 0x13,
+	RTW_CHPLAN_TAIWAN_NO_DFS = 0x14,
+
+	/* ===== 0x20 ~ 0x7F, new channel plan ===== */
+	RTW_CHPLAN_WORLD_NULL = 0x20,
+	RTW_CHPLAN_ETSI1_NULL = 0x21,
+	RTW_CHPLAN_FCC1_NULL = 0x22,
+	RTW_CHPLAN_MKK1_NULL = 0x23,
+	RTW_CHPLAN_ETSI2_NULL = 0x24,
+	RTW_CHPLAN_FCC1_FCC1 = 0x25,
+	RTW_CHPLAN_WORLD_ETSI1 = 0x26,
+	RTW_CHPLAN_MKK1_MKK1 = 0x27,
+	RTW_CHPLAN_WORLD_KCC1 = 0x28,
+	RTW_CHPLAN_WORLD_FCC2 = 0x29,
+	RTW_CHPLAN_FCC2_NULL = 0x2A,
+	RTW_CHPLAN_WORLD_FCC3 = 0x30,
+	RTW_CHPLAN_WORLD_FCC4 = 0x31,
+	RTW_CHPLAN_WORLD_FCC5 = 0x32,
+	RTW_CHPLAN_WORLD_FCC6 = 0x33,
+	RTW_CHPLAN_FCC1_FCC7 = 0x34,
+	RTW_CHPLAN_WORLD_ETSI2 = 0x35,
+	RTW_CHPLAN_WORLD_ETSI3 = 0x36,
+	RTW_CHPLAN_MKK1_MKK2 = 0x37,
+	RTW_CHPLAN_MKK1_MKK3 = 0x38,
+	RTW_CHPLAN_FCC1_NCC1 = 0x39,
+	RTW_CHPLAN_FCC1_NCC2 = 0x40,
+	RTW_CHPLAN_GLOBAL_NULL = 0x41,
+	RTW_CHPLAN_ETSI1_ETSI4 = 0x42,
+	RTW_CHPLAN_FCC1_FCC2 = 0x43,
+	RTW_CHPLAN_FCC1_NCC3 = 0x44,
+	RTW_CHPLAN_WORLD_ETSI5 = 0x45,
+	RTW_CHPLAN_FCC1_FCC8 = 0x46,
+	RTW_CHPLAN_WORLD_ETSI6 = 0x47,
+	RTW_CHPLAN_WORLD_ETSI7 = 0x48,
+	RTW_CHPLAN_WORLD_ETSI8 = 0x49,
+	RTW_CHPLAN_WORLD_ETSI9 = 0x50,
+	RTW_CHPLAN_WORLD_ETSI10 = 0x51,
+	RTW_CHPLAN_WORLD_ETSI11 = 0x52,
+	RTW_CHPLAN_FCC1_NCC4 = 0x53,
+	RTW_CHPLAN_WORLD_ETSI12 = 0x54,
+	RTW_CHPLAN_FCC1_FCC9 = 0x55,
+	RTW_CHPLAN_WORLD_ETSI13 = 0x56,
+	RTW_CHPLAN_FCC1_FCC10 = 0x57,
+	RTW_CHPLAN_MKK2_MKK4 = 0x58,
+	RTW_CHPLAN_WORLD_ETSI14 = 0x59,
+	RTW_CHPLAN_FCC1_FCC5 = 0x60,
+	RTW_CHPLAN_FCC2_FCC7 = 0x61,
+	RTW_CHPLAN_FCC2_FCC1 = 0x62,
+
+	RTW_CHPLAN_MAX,
+	RTW_CHPLAN_REALTEK_DEFINE = 0x7F,
+} RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+typedef enum _RT_CHANNEL_DOMAIN_2G {
+	RTW_RD_2G_NULL = 0,
+	RTW_RD_2G_WORLD = 1,	/* Worldwird 13 */
+	RTW_RD_2G_ETSI1 = 2,	/* Europe */
+	RTW_RD_2G_FCC1 = 3,		/* US */
+	RTW_RD_2G_MKK1 = 4,		/* Japan */
+	RTW_RD_2G_ETSI2 = 5,	/* France */
+	RTW_RD_2G_GLOBAL = 6,	/* Global domain */
+	RTW_RD_2G_MKK2 = 7,		/* Japan */
+	RTW_RD_2G_FCC2 = 8,		/* US */
+
+	RTW_RD_2G_MAX,
+} RT_CHANNEL_DOMAIN_2G, *PRT_CHANNEL_DOMAIN_2G;
+
+typedef enum _RT_CHANNEL_DOMAIN_5G {
+	RTW_RD_5G_NULL = 0,		/*	*/
+	RTW_RD_5G_ETSI1 = 1,	/* Europe */
+	RTW_RD_5G_ETSI2 = 2,	/* Australia, New Zealand */
+	RTW_RD_5G_ETSI3 = 3,	/* Russia */
+	RTW_RD_5G_FCC1 = 4,		/* US */
+	RTW_RD_5G_FCC2 = 5,		/* FCC w/o DFS Channels */
+	RTW_RD_5G_FCC3 = 6,		/* Bolivia, Chile, El Salvador, Venezuela */
+	RTW_RD_5G_FCC4 = 7,		/* Venezuela */
+	RTW_RD_5G_FCC5 = 8,		/* China */
+	RTW_RD_5G_FCC6 = 9,		/*	*/
+	RTW_RD_5G_FCC7 = 10,	/* US Canada(w/o Weather radar) */
+	RTW_RD_5G_KCC1 = 11,	/* Korea */
+	RTW_RD_5G_MKK1 = 12,	/* Japan */
+	RTW_RD_5G_MKK2 = 13,	/* Japan (W52, W53) */
+	RTW_RD_5G_MKK3 = 14,	/* Japan (W56) */
+	RTW_RD_5G_NCC1 = 15,	/* Taiwan, (w/o Weather radar) */
+	RTW_RD_5G_NCC2 = 16,	/* Taiwan, Band2, Band4 */
+	RTW_RD_5G_NCC3 = 17,	/* Taiwan w/o DFS, Band4 only */
+	RTW_RD_5G_ETSI4 = 18,	/* Europe w/o DFS, Band1 only */
+	RTW_RD_5G_ETSI5 = 19,	/* Australia, New Zealand(w/o Weather radar) */
+	RTW_RD_5G_FCC8 = 20,	/* Latin America */
+	RTW_RD_5G_ETSI6 = 21,	/* Israel, Bahrain, Egypt, India, China, Malaysia */
+	RTW_RD_5G_ETSI7 = 22,	/* China */
+	RTW_RD_5G_ETSI8 = 23,	/* Jordan */
+	RTW_RD_5G_ETSI9 = 24,	/* Lebanon */
+	RTW_RD_5G_ETSI10 = 25,	/* Qatar */
+	RTW_RD_5G_ETSI11 = 26,	/* Russia */
+	RTW_RD_5G_NCC4 = 27,	/* Taiwan, (w/o Weather radar) */
+	RTW_RD_5G_ETSI12 = 28,	/* Indonesia */
+	RTW_RD_5G_FCC9 = 29,	/* (w/o Weather radar) */
+	RTW_RD_5G_ETSI13 = 30,	/* (w/o Weather radar) */
+	RTW_RD_5G_FCC10 = 31,	/* Argentina(w/o Weather radar) */
+	RTW_RD_5G_MKK4 = 32,	/* Japan (W52) */
+	RTW_RD_5G_ETSI14 = 33,	/* Russia */
+	RTW_RD_5G_FCC11 = 34,	/* US(include CH144) */
+
+	/* === Below are driver defined for legacy channel plan compatible, DON'T assign index ==== */
+	RTW_RD_5G_OLD_FCC1,
+	RTW_RD_5G_OLD_NCC1,
+	RTW_RD_5G_OLD_KCC1,
+
+	RTW_RD_5G_MAX,
+} RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
+
+bool rtw_chplan_is_empty(u8 id);
+#define rtw_is_channel_plan_valid(chplan) (((chplan) < RTW_CHPLAN_MAX || (chplan) == RTW_CHPLAN_REALTEK_DEFINE) && !rtw_chplan_is_empty(chplan))
+#define rtw_is_legacy_channel_plan(chplan) ((chplan) < 0x20)
+
+typedef struct _RT_CHANNEL_PLAN {
+	unsigned char	Channel[MAX_CHANNEL_NUM];
+	unsigned char	Len;
+} RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;
+
+struct ch_list_t {
+	u8 *len_ch;
+};
+
+#define CH_LIST_ENT(_len, arg...) \
+	{.len_ch = (u8[_len + 1]) {_len, ##arg}, }
+
+#define CH_LIST_LEN(_ch_list) (_ch_list.len_ch[0])
+#define CH_LIST_CH(_ch_list, _i) (_ch_list.len_ch[_i + 1])
+
+typedef struct _RT_CHANNEL_PLAN_MAP {
+	u8 Index2G;
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+	u8 Index5G;
+#endif
+	u8 regd; /* value of REGULATION_TXPWR_LMT */
+} RT_CHANNEL_PLAN_MAP, *PRT_CHANNEL_PLAN_MAP;
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+#define CHPLAN_ENT(i2g, i5g, regd) {i2g, i5g, regd}
+#else
+#define CHPLAN_ENT(i2g, i5g, regd) {i2g, regd}
+#endif
+
+enum Associated_AP {
+	atherosAP	= 0,
+	broadcomAP	= 1,
+	ciscoAP		= 2,
+	marvellAP	= 3,
+	ralinkAP	= 4,
+	realtekAP	= 5,
+	airgocapAP	= 6,
+	unknownAP	= 7,
+	maxAP,
+};
+
+typedef enum _HT_IOT_PEER {
+	HT_IOT_PEER_UNKNOWN			= 0,
+	HT_IOT_PEER_REALTEK			= 1,
+	HT_IOT_PEER_REALTEK_92SE		= 2,
+	HT_IOT_PEER_BROADCOM		= 3,
+	HT_IOT_PEER_RALINK			= 4,
+	HT_IOT_PEER_ATHEROS			= 5,
+	HT_IOT_PEER_CISCO				= 6,
+	HT_IOT_PEER_MERU				= 7,
+	HT_IOT_PEER_MARVELL			= 8,
+	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,/* peer is RealTek SOFT_AP, by Bohn, 2009.12.17 */
+	HT_IOT_PEER_SELF_SOFTAP 		= 10, /* Self is SoftAP */
+	HT_IOT_PEER_AIRGO				= 11,
+	HT_IOT_PEER_INTEL				= 12,
+	HT_IOT_PEER_RTK_APCLIENT		= 13,
+	HT_IOT_PEER_REALTEK_81XX		= 14,
+	HT_IOT_PEER_REALTEK_WOW		= 15,
+	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	HT_IOT_PEER_MAX				= 18
+} HT_IOT_PEER_E, *PHTIOT_PEER_E;
+
+struct mlme_handler {
+	unsigned int   num;
+	char *str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+struct action_handler {
+	unsigned int   num;
+	char *str;
+	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
+};
+
+enum SCAN_STATE {
+	SCAN_DISABLE = 0,
+	SCAN_START = 1,
+	SCAN_PS_ANNC_WAIT = 2,
+	SCAN_ENTER = 3,
+	SCAN_PROCESS = 4,
+
+	/* backop */
+	SCAN_BACKING_OP = 5,
+	SCAN_BACK_OP = 6,
+	SCAN_LEAVING_OP = 7,
+	SCAN_LEAVE_OP = 8,
+
+	/* SW antenna diversity (before linked) */
+	SCAN_SW_ANTDIV_BL = 9,
+
+	/* legacy p2p */
+	SCAN_TO_P2P_LISTEN = 10,
+	SCAN_P2P_LISTEN = 11,
+
+	SCAN_COMPLETE = 12,
+	SCAN_STATE_MAX,
+};
+
+const char *scan_state_str(u8 state);
+
+enum ss_backop_flag {
+	SS_BACKOP_EN = BIT0, /* backop when linked */
+	SS_BACKOP_EN_NL = BIT1, /* backop even when no linked */
+
+	SS_BACKOP_PS_ANNC = BIT4,
+	SS_BACKOP_TX_RESUME = BIT5,
+};
+
+struct ss_res {
+	u8 state;
+	u8 next_state; /* will set to state on next cmd hdl */
+	int	bss_cnt;
+	int	channel_idx;
+	int	scan_mode;
+	u16 scan_ch_ms;
+	u8 rx_ampdu_accept;
+	u8 rx_ampdu_size;
+	u8 igi_scan;
+	u8 igi_before_scan; /* used for restoring IGI value without enable DIG & FA_CNT */
+#ifdef CONFIG_SCAN_BACKOP
+	u8 backop_flags_sta; /* policy for station mode*/
+	u8 backop_flags_ap; /* policy for ap mode */
+	u8 backop_flags; /* per backop runtime decision */
+	u8 scan_cnt;
+	u8 scan_cnt_max;
+	u32 backop_time; /* the start time of backop */
+	u16 backop_ms;
+#endif
+#if defined(CONFIG_ANTENNA_DIVERSITY) || defined(DBG_SCAN_SW_ANTDIV_BL)
+	u8 is_sw_antdiv_bl_scan;
+#endif
+	u8 ssid_num;
+	u8 ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/* #define AP_MODE				0x0C */
+/* #define STATION_MODE	0x08 */
+/* #define AD_HOC_MODE		0x04 */
+/* #define NO_LINK_MODE	0x00 */
+
+#define	WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
+#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
+#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
+#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_
+
+#define WIFI_FW_PRE_LINK			0x00000800
+#define	WIFI_FW_AUTH_NULL			0x00000100
+#define	WIFI_FW_AUTH_STATE			0x00000200
+#define	WIFI_FW_AUTH_SUCCESS			0x00000400
+
+#define	WIFI_FW_ASSOC_STATE			0x00002000
+#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
+
+#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)
+
+#ifdef CONFIG_TDLS
+enum TDLS_option {
+	TDLS_ESTABLISHED = 1,
+	TDLS_ISSUE_PTI,
+	TDLS_CH_SW_RESP,
+	TDLS_CH_SW_PREPARE,
+	TDLS_CH_SW_START,
+	TDLS_CH_SW_TO_OFF_CHNL,
+	TDLS_CH_SW_TO_BASE_CHNL_UNSOLICITED,
+	TDLS_CH_SW_TO_BASE_CHNL,
+	TDLS_CH_SW_END_TO_BASE_CHNL,
+	TDLS_CH_SW_END,
+	TDLS_RS_RCR,
+	TDLS_TEARDOWN_STA,
+	TDLS_TEARDOWN_STA_LOCALLY,
+	maxTDLS,
+};
+
+#endif /* CONFIG_TDLS */
+
+/*
+ * Usage:
+ * When one iface acted as AP mode and the other iface is STA mode and scanning,
+ * it should switch back to AP's operating channel periodically.
+ * Parameters info:
+ * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
+ * RTW_BACK_OP_CH_MS milliseconds.
+ * Example:
+ * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
+ * RTW_SCAN_NUM_OF_CH is 8, RTW_BACK_OP_CH_MS is 300
+ * When it's STA mode gets set_scan command,
+ * it would
+ * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
+ * 2. Back to channel 1 for 300 milliseconds
+ * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
+ * 4. Back to channel 1 for 300 milliseconds
+ * 5. ... and so on, till survey done.
+ */
+#if defined(CONFIG_ATMEL_RC_PATCH)
+	#define RTW_SCAN_NUM_OF_CH 2
+	#define RTW_BACK_OP_CH_MS 200
+#else
+	#define RTW_SCAN_NUM_OF_CH 3
+	#define RTW_BACK_OP_CH_MS 400
+#endif
+
+struct mlme_ext_info {
+	u32	state;
+#ifdef CONFIG_MI_WITH_MBSSID_CAM
+	u8	hw_media_state;
+#endif
+	u32	reauth_count;
+	u32	reassoc_count;
+	u32	link_count;
+	u32	auth_seq;
+	u32	auth_algo;	/* 802.11 auth, could be open, shared, auto */
+	u32	authModeToggle;
+	u32	enc_algo;/* encrypt algorithm; */
+	u32	key_index;	/* this is only valid for legendary wep, 0~3 for key id. */
+	u32	iv;
+	u8	chg_txt[128];
+	u16	aid;
+	u16	bcn_interval;
+	u16	capability;
+	u8	assoc_AP_vendor;
+	u8	slotTime;
+	u8	preamble_mode;
+	u8	WMM_enable;
+	u8	ERP_enable;
+	u8	ERP_IE;
+	u8	HT_enable;
+	u8	HT_caps_enable;
+	u8	HT_info_enable;
+	u8	HT_protection;
+	u8	turboMode_cts2self;
+	u8	turboMode_rtsen;
+	u8	SM_PS;
+	u8	agg_enable_bitmap;
+	u8	ADDBA_retry_count;
+	u8	candidate_tid_bitmap;
+	u8	dialogToken;
+	/* Accept ADDBA Request */
+	bool bAcceptAddbaReq;
+	u8	bwmode_updated;
+	u8	hidden_ssid_mode;
+	u8	VHT_enable;
+
+	struct ADDBA_request		ADDBA_req;
+	struct WMM_para_element	WMM_param;
+	struct HT_caps_element	HT_caps;
+	struct HT_info_element		HT_info;
+	WLAN_BSSID_EX			network;/* join network or bss_network, if in ap mode, it is the same to cur_network.network */
+};
+
+/* The channel information about this channel including joining, scanning, and power constraints. */
+typedef struct _RT_CHANNEL_INFO {
+	u8				ChannelNum;		/* The channel number. */
+	RT_SCAN_TYPE	ScanType;		/* Scan type such as passive or active scan. */
+	/* u16				ScanPeriod;		 */ /* Listen time in millisecond in this channel. */
+	/* s32				MaxTxPwrDbm;	 */ /* Max allowed tx power. */
+	/* u32				ExInfo;			 */ /* Extended Information for this channel. */
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	u32				rx_count;
+#endif
+#ifdef CONFIG_DFS_MASTER
+	u32 non_ocp_end_time;
+#endif
+} RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;
+
+#define DFS_MASTER_TIMER_MS 100
+#define CAC_TIME_MS (60*1000)
+#define CAC_TIME_CE_MS (10*60*1000)
+#define NON_OCP_TIME_MS (30*60*1000)
+
+void rtw_rfctl_init(_adapter *adapter);
+
+#ifdef CONFIG_DFS_MASTER
+struct rf_ctl_t;
+#define CH_IS_NON_OCP(rt_ch_info) (time_after((unsigned long)(rt_ch_info)->non_ocp_end_time, (unsigned long)jiffies))
+bool rtw_is_cac_reset_needed(_adapter *adapter, u8 ch, u8 bw, u8 offset);
+bool _rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl, u8 ch, u8 bw, u8 offset);
+bool rtw_rfctl_overlap_radar_detect_ch(struct rf_ctl_t *rfctl);
+bool rtw_rfctl_is_tx_blocked_by_ch_waiting(struct rf_ctl_t *rfctl);
+bool rtw_chset_is_ch_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
+void rtw_chset_update_non_ocp(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
+void rtw_chset_update_non_ocp_ms(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset, int ms);
+u32 rtw_get_ch_waiting_ms(_adapter *adapter, u8 ch, u8 bw, u8 offset, u32 *r_non_ocp_ms, u32 *r_cac_ms);
+void rtw_reset_cac(_adapter *adapter, u8 ch, u8 bw, u8 offset);
+#else
+#define CH_IS_NON_OCP(rt_ch_info) 0
+#define rtw_chset_is_ch_non_ocp(ch_set, ch, bw, offset) false
+#define rtw_rfctl_is_tx_blocked_by_ch_waiting(rfctl) false
+#endif
+
+enum {
+	RTW_CHF_2G = BIT0,
+	RTW_CHF_5G = BIT1,
+	RTW_CHF_DFS = BIT2,
+	RTW_CHF_LONG_CAC = BIT3,
+	RTW_CHF_NON_DFS = BIT4,
+	RTW_CHF_NON_LONG_CAC = BIT5,
+	RTW_CHF_NON_OCP = BIT6,
+};
+
+bool rtw_choose_shortest_waiting_ch(_adapter *adapter, u8 req_bw, u8 *dec_ch, u8 *dec_bw, u8 *dec_offset, u8 d_flags);
+
+void dump_country_chplan(void *sel, const struct country_chplan *ent);
+void dump_country_chplan_map(void *sel);
+void dump_chplan_id_list(void *sel);
+void dump_chplan_test(void *sel);
+void dump_chset(void *sel, RT_CHANNEL_INFO *ch_set);
+void dump_cur_chset(void *sel, _adapter *adapter);
+
+int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch);
+u8 rtw_chset_is_chbw_valid(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
+
+bool rtw_mlme_band_check(_adapter *adapter, const u32 ch);
+
+
+enum {
+	BAND_24G = BIT0,
+	BAND_5G = BIT1,
+};
+void RTW_SET_SCAN_BAND_SKIP(_adapter *padapter, int skip_band);
+void RTW_CLR_SCAN_BAND_SKIP(_adapter *padapter, int skip_band);
+int RTW_GET_SCAN_BAND_SKIP(_adapter *padapter);
+
+bool rtw_mlme_ignore_chan(_adapter *adapter, const u32 ch);
+
+/* P2P_MAX_REG_CLASSES - Maximum number of regulatory classes */
+#define P2P_MAX_REG_CLASSES 10
+
+/* P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class */
+#define P2P_MAX_REG_CLASS_CHANNELS 20
+
+/* struct p2p_channels - List of supported channels */
+struct p2p_channels {
+	/* struct p2p_reg_class - Supported regulatory class */
+	struct p2p_reg_class {
+		/* reg_class - Regulatory class (IEEE 802.11-2007, Annex J) */
+		u8 reg_class;
+
+		/* channel - Supported channels */
+		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];
+
+		/* channels - Number of channel entries in use */
+		size_t channels;
+	} reg_class[P2P_MAX_REG_CLASSES];
+
+	/* reg_classes - Number of reg_class entries in use */
+	size_t reg_classes;
+};
+
+struct p2p_oper_class_map {
+	enum hw_mode {IEEE80211G, IEEE80211A} mode;
+	u8 op_class;
+	u8 min_chan;
+	u8 max_chan;
+	u8 inc;
+	enum { BW20, BW40PLUS, BW40MINUS } bw;
+};
+
+struct mlme_ext_priv {
+	_adapter	*padapter;
+	u8	mlmeext_init;
+	ATOMIC_T		event_seq;
+	u16	mgnt_seq;
+#ifdef CONFIG_IEEE80211W
+	u16	sa_query_seq;
+	u64 mgnt_80211w_IPN;
+	u64 mgnt_80211w_IPN_rx;
+#endif /* CONFIG_IEEE80211W */
+	/* struct fw_priv 	fwpriv; */
+
+	unsigned char	cur_channel;
+	unsigned char	cur_bwmode;
+	unsigned char	cur_ch_offset;/* PRIME_CHNL_OFFSET */
+	unsigned char	cur_wireless_mode;	/* NETWORK_TYPE */
+
+	unsigned char	max_chan_nums;
+	RT_CHANNEL_INFO		channel_set[MAX_CHANNEL_NUM];
+	struct p2p_channels channel_list;
+	unsigned char	basicrate[NumRates];
+	unsigned char	datarate[NumRates];
+	unsigned char default_supported_mcs_set[16];
+	struct ss_res		sitesurvey_res;
+	struct mlme_ext_info	mlmext_info;/* for sta/adhoc mode, including current scanning/connecting/connected related info.
+                                                      * for ap mode, network includes ap's cap_info */
+	struct timer_list 	survey_timer;
+	struct timer_list 	link_timer;
+#ifdef CONFIG_RTW_80211R
+	struct timer_list 	ft_link_timer;
+	struct timer_list 	ft_roam_timer;
+#endif
+
+	/* struct timer_list 	ADDBA_timer; */
+	u32 last_scan_time;
+	u8	scan_abort;
+	u8	tx_rate; /* TXRATE when USERATE is set. */
+
+	u32	retry; /* retry for issue probereq */
+
+	u64 TSFValue;
+
+	/* for LPS-32K to adaptive bcn early and timeout */
+	u8 adaptive_tsf_done;
+	u32 bcn_delay_cnt[9];
+	u32 bcn_delay_ratio[9];
+	u32 bcn_cnt;
+	u8 DrvBcnEarly;
+	u8 DrvBcnTimeOut;
+
+#ifdef CONFIG_AP_MODE
+	unsigned char bstart_bss;
+#endif
+
+#ifdef CONFIG_80211D
+	u8 update_channel_plan_by_ap_done;
+#endif
+	/* recv_decache check for Action_public frame */
+	u8 action_public_dialog_token;
+	u16	 action_public_rxseq;
+
+	/* #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK */
+	u8 active_keep_alive_check;
+	/* #endif */
+#ifdef DBG_FIXED_CHAN
+	u8 fixed_chan;
+#endif
+	/* set hw sync bcn tsf register or not */
+	u8 en_hw_update_tsf;
+};
+
+static inline u8 check_mlmeinfo_state(struct mlme_ext_priv *plmeext, sint state)
+{
+	if ((plmeext->mlmext_info.state & 0x03) == state)
+		return true;
+
+	return false;
+}
+
+#define mlmeext_msr(mlmeext) ((mlmeext)->mlmext_info.state & 0x03)
+#define mlmeext_scan_state(mlmeext) ((mlmeext)->sitesurvey_res.state)
+#define mlmeext_scan_state_str(mlmeext) scan_state_str((mlmeext)->sitesurvey_res.state)
+#define mlmeext_chk_scan_state(mlmeext, _state) ((mlmeext)->sitesurvey_res.state == (_state))
+#define mlmeext_set_scan_state(mlmeext, _state) \
+	do { \
+		((mlmeext)->sitesurvey_res.state = (_state)); \
+		((mlmeext)->sitesurvey_res.next_state = (_state)); \
+		/* RTW_INFO("set_scan_state:%s\n", scan_state_str(_state)); */ \
+	} while (0)
+
+#define mlmeext_scan_next_state(mlmeext) ((mlmeext)->sitesurvey_res.next_state)
+#define mlmeext_set_scan_next_state(mlmeext, _state) \
+	do { \
+		((mlmeext)->sitesurvey_res.next_state = (_state)); \
+		/* RTW_INFO("set_scan_next_state:%s\n", scan_state_str(_state)); */ \
+	} while (0)
+
+#ifdef CONFIG_SCAN_BACKOP
+#define mlmeext_scan_backop_flags(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags)
+#define mlmeext_chk_scan_backop_flags(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags & (flags))
+#define mlmeext_assign_scan_backop_flags(mlmeext, flags) \
+	do { \
+		((mlmeext)->sitesurvey_res.backop_flags = (flags)); \
+		RTW_INFO("assign_scan_backop_flags:0x%02x\n", (mlmeext)->sitesurvey_res.backop_flags); \
+	} while (0)
+
+#define mlmeext_scan_backop_flags_sta(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_sta)
+#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_sta & (flags))
+#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) \
+	do { \
+		((mlmeext)->sitesurvey_res.backop_flags_sta = (flags)); \
+	} while (0)
+
+#define mlmeext_scan_backop_flags_ap(mlmeext) ((mlmeext)->sitesurvey_res.backop_flags_ap)
+#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) ((mlmeext)->sitesurvey_res.backop_flags_ap & (flags))
+#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) \
+	do { \
+		((mlmeext)->sitesurvey_res.backop_flags_ap = (flags)); \
+	} while (0)
+#else
+#define mlmeext_scan_backop_flags(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags(mlmeext, flags) do {} while (0)
+
+#define mlmeext_scan_backop_flags_sta(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags_sta(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags_sta(mlmeext, flags) do {} while (0)
+
+#define mlmeext_scan_backop_flags_ap(mlmeext) (0)
+#define mlmeext_chk_scan_backop_flags_ap(mlmeext, flags) (0)
+#define mlmeext_assign_scan_backop_flags_ap(mlmeext, flags) do {} while (0)
+#endif
+
+void init_mlme_default_rate_set(_adapter *padapter);
+int init_mlme_ext_priv(_adapter *padapter);
+int init_hw_mlme_ext(_adapter *padapter);
+void free_mlme_ext_priv(struct mlme_ext_priv *pmlmeext);
+extern void init_mlme_ext_timer(_adapter *padapter);
+extern void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
+extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv);
+
+/* void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv); */
+#ifdef CONFIG_GET_RAID_BY_DRV
+unsigned char networktype_to_raid(_adapter *adapter, struct sta_info *psta);
+unsigned char networktype_to_raid_ex(_adapter *adapter, struct sta_info *psta);
+#endif
+u8 judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen);
+void get_rate_set(_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
+void set_mcs_rate_by_mask(u8 *mcs_set, u32 mask);
+void UpdateBrateTbl(_adapter *padapter, u8 *mBratesOS);
+void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
+void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 ch);
+
+void Set_MSR(_adapter *padapter, u8 type);
+
+u8 rtw_get_oper_ch(_adapter *adapter);
+void rtw_set_oper_ch(_adapter *adapter, u8 ch);
+u8 rtw_get_oper_bw(_adapter *adapter);
+void rtw_set_oper_bw(_adapter *adapter, u8 bw);
+u8 rtw_get_oper_choffset(_adapter *adapter);
+void rtw_set_oper_choffset(_adapter *adapter, u8 offset);
+u8	rtw_get_center_ch(u8 channel, u8 chnl_bw, u8 chnl_offset);
+u32 rtw_get_on_oper_ch_time(_adapter *adapter);
+u32 rtw_get_on_cur_ch_time(_adapter *adapter);
+
+u8 rtw_get_offset_by_chbw(u8 ch, u8 bw, u8 *r_offset);
+u8 rtw_get_offset_by_ch(u8 channel);
+
+void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
+
+void _clear_cam_entry(_adapter *padapter, u8 entry);
+void write_cam_from_cache(_adapter *adapter, u8 id);
+void rtw_sec_cam_swap(_adapter *adapter, u8 cam_id_a, u8 cam_id_b);
+void rtw_clean_dk_section(_adapter *adapter);
+void rtw_clean_hw_dk_cam(_adapter *adapter);
+
+/* modify both HW and cache */
+void write_cam(_adapter *padapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_entry(_adapter *padapter, u8 id);
+
+/* modify cache only */
+void write_cam_cache(_adapter *adapter, u8 id, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_cache(_adapter *adapter, u8 id);
+
+void invalidate_cam_all(_adapter *padapter);
+void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
+
+void flush_all_cam_entry(_adapter *padapter);
+
+bool IsLegal5GChannel(PADAPTER Adapter, u8 channel);
+
+void site_survey(_adapter *padapter, u8 survey_channel, RT_SCAN_TYPE ScanType);
+u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
+void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter *padapter, bool update_ie);
+
+int get_bsstype(unsigned short capability);
+u8 *get_my_bssid(WLAN_BSSID_EX *pnetwork);
+u16 get_beacon_interval(WLAN_BSSID_EX *bss);
+
+int is_client_associated_to_ap(_adapter *padapter);
+int is_client_associated_to_ibss(_adapter *padapter);
+int is_IBSS_empty(_adapter *padapter);
+
+unsigned char check_assoc_AP(u8 *pframe, uint len);
+
+int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE);
+#ifdef CONFIG_WFD
+void rtw_process_wfd_ie(_adapter *adapter, u8 *ie, u8 ie_len, const char *tag);
+void rtw_process_wfd_ies(_adapter *adapter, u8 *ies, u8 ies_len, const char *tag);
+#endif
+void WMMOnAssocRsp(_adapter *padapter);
+
+void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HTOnAssocRsp(_adapter *padapter);
+
+void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void VCS_update(_adapter *padapter, struct sta_info *psta);
+void	update_ldpc_stbc_cap(struct sta_info *psta);
+
+int rtw_get_bcn_keys(ADAPTER *Adapter, u8 *pframe, u32 packet_len,
+		struct beacon_keys *recv_beacon);
+int validate_beacon_len(u8 *pframe, uint len);
+void rtw_dump_bcn_keys(struct beacon_keys *recv_beacon);
+int rtw_check_bcn_info(ADAPTER *Adapter, u8 *pframe, u32 packet_len);
+void update_beacon_info(_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
+#ifdef CONFIG_DFS
+void process_csa_ie(_adapter *padapter, u8 *pframe, uint len);
+#endif /* CONFIG_DFS */
+void update_capinfo(PADAPTER Adapter, u16 updateCap);
+void update_wireless_mode(_adapter *padapter);
+void update_tx_basic_rate(_adapter *padapter, u8 modulation);
+void update_sta_basic_rate(struct sta_info *psta, u8 wireless_mode);
+int rtw_ies_get_supported_rate(u8 *ies, uint ies_len, u8 *rate_set, u8 *rate_num);
+
+/* for sta/adhoc mode */
+void update_sta_info(_adapter *padapter, struct sta_info *psta);
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
+void Update_RA_Entry(_adapter *padapter, struct sta_info *psta);
+void set_sta_rate(_adapter *padapter, struct sta_info *psta);
+
+unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr, unsigned short reason, u8 locally_generated);
+
+unsigned char get_highest_rate_idx(u32 mask);
+int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode);
+unsigned int is_ap_in_tkip(_adapter *padapter);
+unsigned int is_ap_in_wep(_adapter *padapter);
+unsigned int should_forbid_n_rate(_adapter *padapter);
+
+bool _rtw_camctl_chk_cap(_adapter *adapter, u8 cap);
+void _rtw_camctl_set_flags(_adapter *adapter, u32 flags);
+void rtw_camctl_set_flags(_adapter *adapter, u32 flags);
+void _rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
+void rtw_camctl_clr_flags(_adapter *adapter, u32 flags);
+bool _rtw_camctl_chk_flags(_adapter *adapter, u32 flags);
+
+struct sec_cam_bmp;
+void dump_sec_cam_map(void *sel, struct sec_cam_bmp *map, u8 max_num);
+void rtw_sec_cam_map_clr_all(struct sec_cam_bmp *map);
+
+bool _rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
+bool rtw_camid_is_gk(_adapter *adapter, u8 cam_id);
+s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk);
+s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid, bool *used);
+void rtw_camid_free(_adapter *adapter, u8 cam_id);
+u8 rtw_get_sec_camid(_adapter *adapter, u8 max_bk_key_num, u8 *sec_key_id);
+
+struct macid_bmp;
+struct macid_ctl_t;
+void dump_macid_map(void *sel, struct macid_bmp *map, u8 max_num);
+bool rtw_macid_is_set(struct macid_bmp *map, u8 id);
+bool rtw_macid_is_used(struct macid_ctl_t *macid_ctl, u8 id);
+bool rtw_macid_is_bmc(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_if_g(struct macid_ctl_t *macid_ctl, u8 id);
+s8 rtw_macid_get_ch_g(struct macid_ctl_t *macid_ctl, u8 id);
+void rtw_alloc_macid(_adapter *padapter, struct sta_info *psta);
+void rtw_release_macid(_adapter *padapter, struct sta_info *psta);
+u8 rtw_search_max_mac_id(_adapter *padapter);
+void rtw_macid_ctl_set_h2c_msr(struct macid_ctl_t *macid_ctl, u8 id, u8 h2c_msr);
+void rtw_macid_ctl_set_bw(struct macid_ctl_t *macid_ctl, u8 id, u8 bw);
+void rtw_macid_ctl_set_vht_en(struct macid_ctl_t *macid_ctl, u8 id, u8 en);
+void rtw_macid_ctl_set_rate_bmp0(struct macid_ctl_t *macid_ctl, u8 id, u32 bmp);
+void rtw_macid_ctl_set_rate_bmp1(struct macid_ctl_t *macid_ctl, u8 id, u32 bmp);
+void rtw_macid_ctl_init(struct macid_ctl_t *macid_ctl);
+void rtw_macid_ctl_deinit(struct macid_ctl_t *macid_ctl);
+u8 rtw_iface_bcmc_id_get(_adapter *padapter);
+
+u32 report_join_res(_adapter *padapter, int res);
+void report_survey_event(_adapter *padapter, union recv_frame *precv_frame);
+void report_surveydone_event(_adapter *padapter);
+u32 report_del_sta_event(_adapter *padapter, unsigned char *MacAddr, unsigned short reason, bool enqueue, u8 locally_generated);
+void report_add_sta_event(_adapter *padapter, unsigned char *MacAddr);
+bool rtw_port_switch_chk(_adapter *adapter);
+void report_wmm_edca_update(_adapter *padapter);
+
+void beacon_timing_control(_adapter *padapter);
+u8 chk_bmc_sleepq_cmd(_adapter *padapter);
+extern u8 set_tx_beacon_cmd(_adapter *padapter);
+unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
+void update_mgnt_tx_rate(_adapter *padapter, u8 rate);
+void update_monitor_frame_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+void update_mgntframe_attrib_addr(_adapter *padapter, struct xmit_frame *pmgntframe);
+void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
+s32 dump_mgntframe_and_wait(_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
+s32 dump_mgntframe_and_wait_ack(_adapter *padapter, struct xmit_frame *pmgntframe);
+s32 dump_mgntframe_and_wait_ack_timeout(_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
+
+#ifdef CONFIG_P2P
+void issue_probersp_p2p(_adapter *padapter, unsigned char *da);
+void issue_p2p_provision_request(_adapter *padapter, u8 *pssid, u8 ussidlen, u8 *pdev_raddr);
+void issue_p2p_GO_request(_adapter *padapter, u8 *raddr);
+void issue_probereq_p2p(_adapter *padapter, u8 *da);
+int issue_probereq_p2p_ex(_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
+void issue_p2p_invitation_response(_adapter *padapter, u8 *raddr, u8 dialogToken, u8 success);
+void issue_p2p_invitation_request(_adapter *padapter, u8 *raddr);
+#endif /* CONFIG_P2P */
+void issue_beacon(_adapter *padapter, int timeout_ms);
+void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
+void _issue_assocreq(_adapter *padapter, u8 is_assoc);
+void issue_assocreq(_adapter *padapter);
+void issue_reassocreq(_adapter *padapter);
+void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
+void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
+void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da);
+s32 issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, u8 ch, bool append_wps, int try_cnt, int wait_ms);
+int issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+s32 issue_nulldata_in_interrupt(PADAPTER padapter, u8 *da, unsigned int power_mode);
+int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
+int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason);
+int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
+void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset);
+void issue_addba_req(_adapter *adapter, unsigned char *ra, u8 tid);
+void issue_addba_rsp(_adapter *adapter, unsigned char *ra, u8 tid, u16 status, u8 size);
+u8 issue_addba_rsp_wait_ack(_adapter *adapter, unsigned char *ra, u8 tid, u16 status, u8 size, int try_cnt, int wait_ms);
+void issue_del_ba(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator);
+int issue_del_ba_ex(_adapter *adapter, unsigned char *ra, u8 tid, u16 reason, u8 initiator, int try_cnt, int wait_ms);
+
+#ifdef CONFIG_IEEE80211W
+void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid, u8 key_type);
+int issue_deauth_11w(_adapter *padapter, unsigned char *da, unsigned short reason, u8 key_type);
+extern void init_dot11w_expire_timer(_adapter *padapter, struct sta_info *psta);
+#endif /* CONFIG_IEEE80211W */
+int issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode);
+int issue_action_SM_PS_wait_ack(_adapter *padapter, unsigned char *raddr, u8 NewMimoPsMode, int try_cnt, int wait_ms);
+
+unsigned int send_delba_sta_tid(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);
+unsigned int send_delba_sta_tid_wait_ack(_adapter *adapter, u8 initiator, struct sta_info *sta, u8 tid, u8 force);
+
+unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
+unsigned int send_beacon(_adapter *padapter);
+
+void start_clnt_assoc(_adapter *padapter);
+void start_clnt_auth(_adapter *padapter);
+void start_clnt_join(_adapter *padapter);
+void start_create_ibss(_adapter *padapter);
+
+unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame);
+
+unsigned int on_action_spct(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame);
+#ifdef CONFIG_RTW_WNM
+unsigned int on_action_wnm(_adapter *adapter, union recv_frame *rframe);
+#endif
+
+#define RX_AMPDU_ACCEPT_INVALID 0xFF
+#define RX_AMPDU_SIZE_INVALID 0xFF
+
+enum rx_ampdu_reason {
+	RX_AMPDU_DRV_FIXED = 1,
+	RX_AMPDU_BTCOEX = 2, /* not used, because BTCOEX has its own variable management */
+	RX_AMPDU_DRV_SCAN = 3,
+};
+u8 rtw_rx_ampdu_size(_adapter *adapter);
+bool rtw_rx_ampdu_is_accept(_adapter *adapter);
+bool rtw_rx_ampdu_set_size(_adapter *adapter, u8 size, u8 reason);
+bool rtw_rx_ampdu_set_accept(_adapter *adapter, u8 accept, u8 reason);
+u8 rx_ampdu_apply_sta_tid(_adapter *adapter, struct sta_info *sta, u8 tid, u8 accept, u8 size);
+u8 rx_ampdu_apply_sta(_adapter *adapter, struct sta_info *sta, u8 accept, u8 size);
+u16 rtw_rx_ampdu_apply(_adapter *adapter);
+
+unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int on_action_public(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_ft(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
+#ifdef CONFIG_IEEE80211W
+unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame);
+#endif /* CONFIG_IEEE80211W */
+unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_vht(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame);
+
+#ifdef CONFIG_RTW_80211R
+void start_clnt_ft_action(_adapter *padapter, u8 *pTargetAddr);
+void issue_action_ft_request(_adapter *padapter, u8 *pTargetAddr);
+void report_ft_event(_adapter *padapter);
+void report_ft_reassoc_event(_adapter *padapter, u8 *pMacAddr);
+void ft_link_timer_hdl(_adapter *padapter);
+void ft_roam_timer_hdl(_adapter *padapter);
+#endif
+void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
+void mlmeext_sta_del_event_callback(_adapter *padapter);
+void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);
+
+void linked_status_chk(_adapter *padapter, u8 from_timer);
+
+void _linked_info_dump(_adapter *padapter);
+
+void survey_timer_hdl(_adapter *padapter);
+void link_timer_hdl(_adapter *padapter);
+void addba_timer_hdl(struct sta_info *psta);
+#ifdef CONFIG_IEEE80211W
+void sa_query_timer_hdl(struct sta_info *psta);
+#endif /* CONFIG_IEEE80211W */
+
+#define set_survey_timer(mlmeext, ms) \
+	do { \
+		/*RTW_INFO("%s set_survey_timer(%p, %d)\n", __func__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->survey_timer, (ms)); \
+	} while (0)
+
+#define set_link_timer(mlmeext, ms) \
+	do { \
+		/*RTW_INFO("%s set_link_timer(%p, %d)\n", __func__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->link_timer, (ms)); \
+	} while (0)
+
+extern int cckrates_included(unsigned char *rate, int ratelen);
+extern int cckratesonly_included(unsigned char *rate, int ratelen);
+
+extern void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr);
+
+extern void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern void correct_TSF(_adapter *padapter, struct mlme_ext_priv *pmlmeext);
+extern void adaptive_early_32k(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern u8 traffic_status_watchdog(_adapter *padapter, u8 from_timer);
+
+
+void rtw_join_done_chk_ch(_adapter *padapter, int join_res);
+
+int rtw_chk_start_clnt_join(_adapter *padapter, u8 *ch, u8 *bw, u8 *offset);
+
+#ifdef CONFIG_PLATFORM_ARM_SUN8I
+	#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	8000
+#else
+	#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	12000
+#endif
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8(*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);
+};
+
+
+u8 read_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(_adapter *padapter, u8 *pbuf);
+
+
+u8 NULL_hdl(_adapter *padapter, u8 *pbuf);
+u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 disconnect_hdl(_adapter *padapter, u8 *pbuf);
+u8 createbss_hdl(_adapter *padapter, u8 *pbuf);
+u8 setopmode_hdl(_adapter *padapter, u8 *pbuf);
+u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 setauth_hdl(_adapter *padapter, u8 *pbuf);
+u8 setkey_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 del_assocsta_hdl(_adapter *padapter, u8 *pbuf);
+u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 add_ba_rsp_hdl(_adapter *padapter, unsigned char *pbuf);
+
+void rtw_ap_wep_pk_setting(_adapter *adapter, struct sta_info *psta);
+
+u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 chk_bmc_sleepq_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 set_ch_hdl(_adapter *padapter, u8 *pbuf);
+u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 led_blink_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 set_csa_hdl(_adapter *padapter, unsigned char *pbuf);	/* Kurt: Handling DFS channel switch announcement ie. */
+u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf);
+u8 run_in_thread_hdl(_adapter *padapter, u8 *pbuf);
+u8 rtw_getmacreg_hdl(_adapter *padapter, u8 *pbuf);
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},
+
+#ifdef _RTW_CMD_C_
+
+static struct cmd_hdl wlancmds[] = {
+	GEN_DRV_CMD_HANDLER(sizeof(struct readMAC_parm), rtw_getmacreg) /*0*/
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct joinbss_parm), join_cmd_hdl)  /*14*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct disconnect_parm), disconnect_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct createbss_parm), createbss_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setopmode_parm), setopmode_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct sitesurvey_parm), sitesurvey_cmd_hdl)  /*18*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct setauth_parm), setauth_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setkey_parm), setkey_hdl)  /*20*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_stakey_parm), set_stakey_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct del_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setstapwrstate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct getbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct getdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct setphyinfo_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct getphyinfo_parm), NULL)   /*30*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct setphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct getphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl) /* 46 */
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*50*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl) /*55*/
+
+	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl) /*56*/
+	GEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl) /*57*/
+
+	GEN_MLME_EXT_HANDLER(0, h2c_msg_hdl) /*58*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelPlan_param), set_chplan_hdl) /*59*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct LedBlink_param), led_blink_hdl) /*60*/
+
+	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl) /*61*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct TDLSoption_param), tdls_hdl) /*62*/
+	GEN_MLME_EXT_HANDLER(0, chk_bmc_sleepq_hdl) /*63*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct RunInThread_param), run_in_thread_hdl) /*64*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaRsp_parm), add_ba_rsp_hdl) /* 65 */
+};
+
+#endif
+
+struct C2HEvent_Header {
+#ifdef __LITTLE_ENDIAN
+	unsigned int len:16;
+	unsigned int ID:8;
+	unsigned int seq:8;
+#else
+	unsigned int seq:8;
+	unsigned int ID:8;
+	unsigned int len:16;
+
+#endif
+	unsigned int rsvd;
+};
+
+void rtw_dummy_event_callback(_adapter *adapter , u8 *pbuf);
+void rtw_fwdbg_event_callback(_adapter *adapter , u8 *pbuf);
+
+enum rtw_c2h_event {
+	GEN_EVT_CODE(_Read_MACREG) = 0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+	GEN_EVT_CODE(_Read_RFREG),
+	GEN_EVT_CODE(_Read_EEPROM),
+	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+	GEN_EVT_CODE(_Get_BasicRate),
+	GEN_EVT_CODE(_Get_DataRate),
+	GEN_EVT_CODE(_Survey),	 /*8*/
+	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+
+	GEN_EVT_CODE(_JoinBss) , /*10*/
+	GEN_EVT_CODE(_AddSTA),
+	GEN_EVT_CODE(_DelSTA),
+	GEN_EVT_CODE(_AtimDone) ,
+	GEN_EVT_CODE(_TX_Report),
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+	GEN_EVT_CODE(_DTM_Report),
+	GEN_EVT_CODE(_TX_Rate_Statistics),
+	GEN_EVT_CODE(_C2HLBK),
+	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		/* filen: only for PCIE, USB	 */
+	GEN_EVT_CODE(_CloseRF),				/* filen: only for PCIE, work around ASPM */
+	GEN_EVT_CODE(_WMM),					/*25*/
+#ifdef CONFIG_IEEE80211W
+	GEN_EVT_CODE(_TimeoutSTA),
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_RTW_80211R
+	GEN_EVT_CODE(_FT_REASSOC),
+#endif
+	MAX_C2HEVT
+};
+
+
+#ifdef _RTW_MLME_EXT_C_
+
+static struct fwevent wlanevents[] = {
+	{0, rtw_dummy_event_callback},	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof(struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
+	{0, &rtw_atimdone_event_callback},
+	{0, rtw_dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, rtw_fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_cpwm_event_callback},
+	{0, NULL},
+	{0, &rtw_wmm_event_callback}, /*25*/
+#ifdef CONFIG_IEEE80211W
+	{sizeof(struct stadel_event), &rtw_sta_timeout_event_callback},
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_RTW_80211R
+	{sizeof(struct stassoc_event), &rtw_ft_reassoc_event_callback},
+#endif
+};
+
+#endif/* _RTW_MLME_EXT_C_ */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_mp.h b/drivers/staging/rtl8188eu/include/rtw_mp.h
new file mode 100644
index 000000000000..bc8c7bc94a93
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mp.h
@@ -0,0 +1,823 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_MP_H_
+#define _RTW_MP_H_
+
+#define RTWPRIV_VER_INFO	1
+
+#define MAX_MP_XMITBUF_SZ	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame {
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int frame_tag;
+
+	_adapter *padapter;
+
+	/* insert urb, irp, and irpcnt info below... */
+	/* max frag_cnt = 8 */
+
+	u8 *mem_addr;
+	u32 sz[8];
+
+	PURB pxmit_urb[8];
+
+	u8 bpending[8];
+	sint ac_tag[8];
+	sint last[8];
+	uint irpcnt;
+	uint fragcnt;
+
+	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
+};
+
+struct mp_wiparam {
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+typedef void(*wi_act_func)(void *padapter);
+
+struct mp_tx {
+	u8 stop;
+	u32 count, sended;
+	u8 payload;
+	struct pkt_attrib attrib;
+	/* struct tx_desc desc; */
+	/* u8 resvdtx[7]; */
+	u8 desc[TXDESC_SIZE];
+	u8 *pallocated_buf;
+	u8 *buf;
+	u32 buf_size, write_size;
+	_thread_hdl_ PktTxThread;
+};
+
+#define MP_MAX_LINES		1000
+#define MP_MAX_LINES_BYTES	256
+
+typedef struct _RT_PMAC_PKT_INFO {
+	u8			MCS;
+	u8			Nss;
+	u8			Nsts;
+	u32			N_sym;
+	u8			SIGA2B3;
+} RT_PMAC_PKT_INFO, *PRT_PMAC_PKT_INFO;
+
+typedef struct _RT_PMAC_TX_INFO {
+	u8			bEnPMacTx:1;		/* 0: Disable PMac 1: Enable PMac */
+	u8			Mode:3;				/* 0: Packet TX 3:Continuous TX */
+	u8			Ntx:4;				/* 0-7 */
+	u8			TX_RATE;			/* MPT_RATE_E */
+	u8			TX_RATE_HEX;
+	u8			TX_SC;
+	u8			bSGI:1;
+	u8			bSPreamble:1;
+	u8			bSTBC:1;
+	u8			bLDPC:1;
+	u8			NDP_sound:1;
+	u8			BandWidth:3;		/* 0: 20 1:40 2:80Mhz */
+	u8			m_STBC;			/* bSTBC + 1 */
+	u16			PacketPeriod;
+	u32		PacketCount;
+	u32		PacketLength;
+	u8			PacketPattern;
+	u16			SFD;
+	u8			SignalField;
+	u8			ServiceField;
+	u16			LENGTH;
+	u8			CRC16[2];
+	u8			LSIG[3];
+	u8			HT_SIG[6];
+	u8			VHT_SIG_A[6];
+	u8			VHT_SIG_B[4];
+	u8			VHT_SIG_B_CRC;
+	u8			VHT_Delimiter[4];
+	u8			MacAddress[6];
+} RT_PMAC_TX_INFO, *PRT_PMAC_TX_INFO;
+
+
+typedef void (*MPT_WORK_ITEM_HANDLER)(void * Adapter);
+typedef struct _MPT_CONTEXT {
+	/* Indicate if we have started Mass Production Test. */
+	bool			bMassProdTest;
+
+	/* Indicate if the driver is unloading or unloaded. */
+	bool			bMptDrvUnload;
+
+	_sema			MPh2c_Sema;
+	struct timer_list 		MPh2c_timeout_timer;
+	/* Event used to sync H2c for BT control */
+
+	bool		MptH2cRspEvent;
+	bool		MptBtC2hEvent;
+	bool		bMPh2c_timeout;
+
+	/* 8190 PCI does not support NDIS_WORK_ITEM. */
+	/* Work Item for Mass Production Test. */
+	/* NDIS_WORK_ITEM	MptWorkItem;
+	*	RT_WORK_ITEM		MptWorkItem; */
+	/* Event used to sync the case unloading driver and MptWorkItem is still in progress.
+	*	NDIS_EVENT		MptWorkItemEvent; */
+	/* To protect the following variables.
+	*	NDIS_SPIN_LOCK		MptWorkItemSpinLock; */
+	/* Indicate a MptWorkItem is scheduled and not yet finished. */
+	bool			bMptWorkItemInProgress;
+	/* An instance which implements function and context of MptWorkItem. */
+	MPT_WORK_ITEM_HANDLER	CurrMptAct;
+
+	/* 1=Start, 0=Stop from UI. */
+	u32			MptTestStart;
+	/* _TEST_MODE, defined in MPT_Req2.h */
+	u32			MptTestItem;
+	/* Variable needed in each implementation of CurrMptAct. */
+	u32			MptActType;	/* Type of action performed in CurrMptAct. */
+	/* The Offset of IO operation is depend of MptActType. */
+	u32			MptIoOffset;
+	/* The Value of IO operation is depend of MptActType. */
+	u32			MptIoValue;
+	/* The RfPath of IO operation is depend of MptActType. */
+
+	u32			mpt_rf_path;
+
+
+	WIRELESS_MODE		MptWirelessModeToSw;	/* Wireless mode to switch. */
+	u8			MptChannelToSw;	/* Channel to switch. */
+	u8			MptInitGainToSet;	/* Initial gain to set. */
+	/* u32			bMptAntennaA;		 */ /* true if we want to use antenna A. */
+	u32			MptBandWidth;		/* bandwidth to switch. */
+
+	u32			mpt_rate_index;/* rate index. */
+
+	/* Register value kept for Single Carrier Tx test. */
+	u8			btMpCckTxPower;
+	/* Register value kept for Single Carrier Tx test. */
+	u8			btMpOfdmTxPower;
+	/* For MP Tx Power index */
+	u8			TxPwrLevel[4];	/* rf-A, rf-B*/
+	u32			RegTxPwrLimit;
+	/* Content of RCR Regsiter for Mass Production Test. */
+	u32			MptRCR;
+	/* true if we only receive packets with specific pattern. */
+	bool			bMptFilterPattern;
+	/* Rx OK count, statistics used in Mass Production Test. */
+	u32			MptRxOkCnt;
+	/* Rx CRC32 error count, statistics used in Mass Production Test. */
+	u32			MptRxCrcErrCnt;
+
+	bool			bCckContTx;	/* true if we are in CCK Continuous Tx test. */
+	bool			bOfdmContTx;	/* true if we are in OFDM Continuous Tx test. */
+		/* true if we have start Continuous Tx test. */
+	bool			is_start_cont_tx;
+
+	/* true if we are in Single Carrier Tx test. */
+	bool			bSingleCarrier;
+	/* true if we are in Carrier Suppression Tx Test. */
+
+	bool			is_carrier_suppression;
+
+	/* true if we are in Single Tone Tx test. */
+
+	bool			is_single_tone;
+
+
+	/* ACK counter asked by K.Y.. */
+	bool			bMptEnableAckCounter;
+	u32			MptAckCounter;
+
+	/* SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~! */
+	/* s8			BufOfLines[2][MAX_LINES_HWCONFIG_TXT][MAX_BYTES_LINE_HWCONFIG_TXT]; */
+	/* s8			BufOfLines[2][MP_MAX_LINES][MP_MAX_LINES_BYTES]; */
+	/* s32			RfReadLine[2]; */
+
+	u8		APK_bound[2];	/* for APK	path A/path B */
+	bool		bMptIndexEven;
+
+	u8		backup0xc50;
+	u8		backup0xc58;
+	u8		backup0xc30;
+	u8		backup0x52_RF_A;
+	u8		backup0x52_RF_B;
+
+	u32			backup0x58_RF_A;
+	u32			backup0x58_RF_B;
+
+	u8			h2cReqNum;
+	u8			c2hBuf[32];
+
+	u8          btInBuf[100];
+	u32			mptOutLen;
+	u8          mptOutBuf[100];
+	RT_PMAC_TX_INFO	PMacTxInfo;
+	RT_PMAC_PKT_INFO	PMacPktInfo;
+	u8 HWTxmode;
+
+	bool			bldpc;
+	bool			bstbc;
+} MPT_CONTEXT, *PMPT_CONTEXT;
+/* #endif */
+
+
+/* #define RTPRIV_IOCTL_MP					( SIOCIWFIRSTPRIV + 0x17) */
+enum {
+	WRITE_REG = 1,
+	READ_REG,
+	WRITE_RF,
+	READ_RF,
+	MP_START,
+	MP_STOP,
+	MP_RATE,
+	MP_CHANNEL,
+	MP_BANDWIDTH,
+	MP_TXPOWER,
+	MP_ANT_TX,
+	MP_ANT_RX,
+	MP_CTX,
+	MP_QUERY,
+	MP_ARX,
+	MP_PSD,
+	MP_PWRTRK,
+	MP_THER,
+	MP_IOCTL,
+	EFUSE_GET,
+	EFUSE_SET,
+	MP_RESET_STATS,
+	MP_DUMP,
+	MP_PHYPARA,
+	MP_SetRFPathSwh,
+	MP_QueryDrvStats,
+	CTA_TEST,
+	MP_DISABLE_BT_COEXIST,
+	MP_PwrCtlDM,
+	MP_GETVER,
+	MP_MON,
+	EFUSE_MASK,
+	EFUSE_FILE,
+	MP_TX,
+	MP_RX,
+	MP_IQK,
+	MP_LCK,
+	MP_HW_TX_MODE,
+	MP_GET_TXPOWER_INX,
+	MP_CUSTOMER_STR,
+	MP_NULL,
+	MP_SetBT,
+#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
+	VENDOR_IE_SET ,
+	VENDOR_IE_GET ,
+#endif
+#ifdef CONFIG_WOWLAN
+	MP_WOW_ENABLE,
+	MP_WOW_SET_PATTERN,
+#endif
+#ifdef CONFIG_AP_WOWLAN
+	MP_AP_WOW_ENABLE,
+#endif
+	MP_SD_IREAD,
+	MP_SD_IWRITE,
+};
+
+struct mp_priv {
+	_adapter *papdater;
+
+	/* Testing Flag */
+	u32 mode;/* 0 for normal type packet, 1 for loopback packet (16bytes TXCMD) */
+
+	u32 prev_fw_state;
+
+	/* OID cmd handler */
+	struct mp_wiparam workparam;
+	/*	u8 act_in_progress; */
+
+	/* Tx Section */
+	u8 TID;
+	u32 tx_pktcount;
+	u32 pktInterval;
+	u32 pktLength;
+	struct mp_tx tx;
+
+	/* Rx Section */
+	u32 rx_bssidpktcount;
+	u32 rx_pktcount;
+	u32 rx_pktcount_filter_out;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+	bool  rx_bindicatePkt;
+	struct recv_stat rxstat;
+
+	/* RF/BB relative */
+	u8 channel;
+	u8 bandwidth;
+	u8 prime_channel_offset;
+	u8 txpoweridx;
+	u8 rateidx;
+	u32 preamble;
+	/*	u8 modem; */
+	u32 CrystalCap;
+	/*	u32 curr_crystalcap; */
+
+	u16 antenna_tx;
+	u16 antenna_rx;
+	/*	u8 curr_rfpath; */
+
+	u8 check_mp_pkt;
+
+	u8 bSetTxPower;
+	/*	uint ForcedDataRate; */
+	u8 mp_dm;
+	u8 mac_filter[ETH_ALEN];
+	u8 bmac_filter;
+
+	struct wlan_network mp_network;
+	NDIS_802_11_MAC_ADDRESS network_macaddr;
+
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	_queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+	bool bSetRxBssid;
+	bool bTxBufCkFail;
+	bool bRTWSmbCfg;
+	bool bloopback;
+	bool bloadefusemap;
+
+	MPT_CONTEXT	mpt_ctx;
+
+
+	u8		*TXradomBuffer;
+};
+
+typedef struct _IOCMD_STRUCT_ {
+	u8	cmdclass;
+	u16	value;
+	u8	index;
+} IOCMD_STRUCT;
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+
+typedef struct _MP_FIRMWARE {
+	FIRMWARE_SOURCE eFWSource;
+#ifdef CONFIG_EMBEDDED_FWIMG
+	u8		*szFwBuffer;
+#else
+	u8			szFwBuffer[0x8000];
+#endif
+	u32		ulFwLength;
+} RT_MP_FIRMWARE, *PRT_MP_FIRMWARE;
+
+
+
+
+/* *********************************************************************** */
+
+#define LOWER	true
+#define RAISE	false
+
+/* Hardware Registers */
+#define BB_REG_BASE_ADDR		0x800
+
+/* MP variables */
+typedef enum _MP_MODE_ {
+	MP_OFF,
+	MP_ON,
+	MP_ERR,
+	MP_CONTINUOUS_TX,
+	MP_SINGLE_CARRIER_TX,
+	MP_CARRIER_SUPPRISSION_TX,
+	MP_SINGLE_TONE_TX,
+	MP_PACKET_TX,
+	MP_PACKET_RX
+} MP_MODE;
+
+typedef enum _TEST_MODE {
+	TEST_NONE                 ,
+	PACKETS_TX                ,
+	PACKETS_RX                ,
+	CONTINUOUS_TX             ,
+	OFDM_Single_Tone_TX       ,
+	CCK_Carrier_Suppression_TX
+} TEST_MODE;
+
+
+typedef enum _MPT_BANDWIDTH {
+	MPT_BW_20MHZ = 0,
+	MPT_BW_40MHZ_DUPLICATE = 1,
+	MPT_BW_40MHZ_ABOVE = 2,
+	MPT_BW_40MHZ_BELOW = 3,
+	MPT_BW_40MHZ = 4,
+	MPT_BW_80MHZ = 5,
+	MPT_BW_80MHZ_20_ABOVE = 6,
+	MPT_BW_80MHZ_20_BELOW = 7,
+	MPT_BW_80MHZ_20_BOTTOM = 8,
+	MPT_BW_80MHZ_20_TOP = 9,
+	MPT_BW_80MHZ_40_ABOVE = 10,
+	MPT_BW_80MHZ_40_BELOW = 11,
+} MPT_BANDWIDTHE, *PMPT_BANDWIDTH;
+
+#define MAX_RF_PATH_NUMS	RF_PATH_MAX
+
+
+extern u8 mpdatarate[NumRates];
+
+/* MP set force data rate base on the definition. */
+typedef enum _MPT_RATE_INDEX {
+	/* CCK rate. */
+	MPT_RATE_1M = 1 ,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_MCS16,
+	MPT_RATE_MCS17, /*  #29 */
+	MPT_RATE_MCS18,
+	MPT_RATE_MCS19,
+	MPT_RATE_MCS20,
+	MPT_RATE_MCS21,
+	MPT_RATE_MCS22, /*  #34 */
+	MPT_RATE_MCS23,
+	MPT_RATE_MCS24,
+	MPT_RATE_MCS25,
+	MPT_RATE_MCS26,
+	MPT_RATE_MCS27, /*  #39 */
+	MPT_RATE_MCS28, /*  #40 */
+	MPT_RATE_MCS29, /*  #41 */
+	MPT_RATE_MCS30, /*  #42 */
+	MPT_RATE_MCS31, /*  #43 */
+	/* VHT rate. Total: 20*/
+	MPT_RATE_VHT1SS_MCS0 = 100,/*  #44*/
+	MPT_RATE_VHT1SS_MCS1, /*  # */
+	MPT_RATE_VHT1SS_MCS2,
+	MPT_RATE_VHT1SS_MCS3,
+	MPT_RATE_VHT1SS_MCS4,
+	MPT_RATE_VHT1SS_MCS5,
+	MPT_RATE_VHT1SS_MCS6, /*  # */
+	MPT_RATE_VHT1SS_MCS7,
+	MPT_RATE_VHT1SS_MCS8,
+	MPT_RATE_VHT1SS_MCS9, /* #53 */
+	MPT_RATE_VHT2SS_MCS0, /* #54 */
+	MPT_RATE_VHT2SS_MCS1,
+	MPT_RATE_VHT2SS_MCS2,
+	MPT_RATE_VHT2SS_MCS3,
+	MPT_RATE_VHT2SS_MCS4,
+	MPT_RATE_VHT2SS_MCS5,
+	MPT_RATE_VHT2SS_MCS6,
+	MPT_RATE_VHT2SS_MCS7,
+	MPT_RATE_VHT2SS_MCS8,
+	MPT_RATE_VHT2SS_MCS9, /* #63 */
+	MPT_RATE_VHT3SS_MCS0,
+	MPT_RATE_VHT3SS_MCS1,
+	MPT_RATE_VHT3SS_MCS2,
+	MPT_RATE_VHT3SS_MCS3,
+	MPT_RATE_VHT3SS_MCS4,
+	MPT_RATE_VHT3SS_MCS5,
+	MPT_RATE_VHT3SS_MCS6, /*  #126 */
+	MPT_RATE_VHT3SS_MCS7,
+	MPT_RATE_VHT3SS_MCS8,
+	MPT_RATE_VHT3SS_MCS9,
+	MPT_RATE_VHT4SS_MCS0,
+	MPT_RATE_VHT4SS_MCS1, /*  #131 */
+	MPT_RATE_VHT4SS_MCS2,
+	MPT_RATE_VHT4SS_MCS3,
+	MPT_RATE_VHT4SS_MCS4,
+	MPT_RATE_VHT4SS_MCS5,
+	MPT_RATE_VHT4SS_MCS6, /*  #136 */
+	MPT_RATE_VHT4SS_MCS7,
+	MPT_RATE_VHT4SS_MCS8,
+	MPT_RATE_VHT4SS_MCS9,
+	MPT_RATE_LAST
+} MPT_RATE_E, *PMPT_RATE_E;
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	/* 0x3F */
+
+#define MPT_IS_CCK_RATE(_value)		(MPT_RATE_1M <= _value && _value <= MPT_RATE_11M)
+#define MPT_IS_OFDM_RATE(_value)	(MPT_RATE_6M <= _value && _value <= MPT_RATE_54M)
+#define MPT_IS_HT_RATE(_value)		(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS31)
+#define MPT_IS_HT_1S_RATE(_value)	(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS7)
+#define MPT_IS_HT_2S_RATE(_value)	(MPT_RATE_MCS8 <= _value && _value <= MPT_RATE_MCS15)
+#define MPT_IS_HT_3S_RATE(_value)	(MPT_RATE_MCS16 <= _value && _value <= MPT_RATE_MCS23)
+#define MPT_IS_HT_4S_RATE(_value)	(MPT_RATE_MCS24 <= _value && _value <= MPT_RATE_MCS31)
+
+#define MPT_IS_VHT_RATE(_value)		(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)
+#define MPT_IS_VHT_1S_RATE(_value)	(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT1SS_MCS9)
+#define MPT_IS_VHT_2S_RATE(_value)	(MPT_RATE_VHT2SS_MCS0 <= _value && _value <= MPT_RATE_VHT2SS_MCS9)
+#define MPT_IS_VHT_3S_RATE(_value)	(MPT_RATE_VHT3SS_MCS0 <= _value && _value <= MPT_RATE_VHT3SS_MCS9)
+#define MPT_IS_VHT_4S_RATE(_value)	(MPT_RATE_VHT4SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)
+
+#define MPT_IS_2SS_RATE(_rate) ((MPT_RATE_MCS8 <= _rate && _rate <= MPT_RATE_MCS15) || \
+	(MPT_RATE_VHT2SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT2SS_MCS9))
+#define MPT_IS_3SS_RATE(_rate) ((MPT_RATE_MCS16 <= _rate && _rate <= MPT_RATE_MCS23) || \
+	(MPT_RATE_VHT3SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT3SS_MCS9))
+#define MPT_IS_4SS_RATE(_rate) ((MPT_RATE_MCS24 <= _rate && _rate <= MPT_RATE_MCS31) || \
+	(MPT_RATE_VHT4SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT4SS_MCS9))
+
+typedef enum _POWER_MODE_ {
+	POWER_LOW = 0,
+	POWER_NORMAL
+} POWER_MODE;
+
+/* The following enumeration is used to define the value of Reg0xD00[30:28] or JaguarReg0x914[18:16]. */
+typedef enum _OFDM_TX_MODE {
+	OFDM_ALL_OFF		= 0,
+	OFDM_ContinuousTx	= 1,
+	OFDM_SingleCarrier	= 2,
+	OFDM_SingleTone	= 4,
+} OFDM_TX_MODE;
+
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+typedef enum _ENCRY_CTRL_STATE_ {
+	HW_CONTROL,		/* hw encryption& decryption */
+	SW_CONTROL,		/* sw encryption& decryption */
+	HW_ENCRY_SW_DECRY,	/* hw encryption & sw decryption */
+	SW_ENCRY_HW_DECRY	/* sw encryption & hw decryption */
+} ENCRY_CTRL_STATE;
+
+typedef enum	_MPT_TXPWR_DEF {
+	MPT_CCK,
+	MPT_OFDM, /* L and HT OFDM */
+	MPT_OFDM_AND_HT,
+	MPT_HT,
+	MPT_VHT
+} MPT_TXPWR_DEF;
+
+
+#define IS_MPT_HT_RATE(_rate)			(_rate >= MPT_RATE_MCS0 && _rate <= MPT_RATE_MCS31)
+#define IS_MPT_VHT_RATE(_rate)			(_rate >= MPT_RATE_VHT1SS_MCS0 && _rate <= MPT_RATE_VHT4SS_MCS9)
+#define IS_MPT_CCK_RATE(_rate)			(_rate >= MPT_RATE_1M && _rate <= MPT_RATE_11M)
+#define IS_MPT_OFDM_RATE(_rate)			(_rate >= MPT_RATE_6M && _rate <= MPT_RATE_54M)
+/*************************************************************************/
+
+extern s32 init_mp_priv(PADAPTER padapter);
+extern void free_mp_priv(struct mp_priv *pmp_priv);
+extern s32 MPT_InitializeAdapter(PADAPTER padapter, u8 Channel);
+extern void MPT_DeInitAdapter(PADAPTER padapter);
+extern s32 mp_start_test(PADAPTER padapter);
+extern void mp_stop_test(PADAPTER padapter);
+
+extern u32 _read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask);
+extern void _write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+
+extern u32 read_macreg(_adapter *padapter, u32 addr, u32 sz);
+extern void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz);
+extern u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
+extern void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+extern u32 read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr);
+extern void write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 val);
+
+void	SetChannel(PADAPTER pAdapter);
+void	SetBandwidth(PADAPTER pAdapter);
+int	SetTxPower(PADAPTER pAdapter);
+void	SetAntenna(PADAPTER pAdapter);
+void	SetDataRate(PADAPTER pAdapter);
+void	SetAntenna(PADAPTER pAdapter);
+s32	SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
+void	GetThermalMeter(PADAPTER pAdapter, u8 *value);
+void	SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+void	SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+void	SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+void	SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+void	PhySetTxPowerLevel(PADAPTER pAdapter);
+void	fill_txdesc_for_mp(PADAPTER padapter, u8 *ptxdesc);
+void	SetPacketTx(PADAPTER padapter);
+void	SetPacketRx(PADAPTER pAdapter, u8 bStartRx, u8 bAB);
+void	ResetPhyRxPktCount(PADAPTER pAdapter);
+u32	GetPhyRxPktReceived(PADAPTER pAdapter);
+u32	GetPhyRxPktCRC32Error(PADAPTER pAdapter);
+s32	SetPowerTracking(PADAPTER padapter, u8 enable);
+void	GetPowerTracking(PADAPTER padapter, u8 *enable);
+u32	mp_query_psd(PADAPTER pAdapter, u8 *data);
+void	rtw_mp_trigger_iqk(PADAPTER padapter);
+void	rtw_mp_trigger_lck(PADAPTER padapter);
+
+
+
+void hal_mpt_SwitchRfSetting(PADAPTER pAdapter);
+s32 hal_mpt_SetPowerTracking(PADAPTER padapter, u8 enable);
+void hal_mpt_GetPowerTracking(PADAPTER padapter, u8 *enable);
+void hal_mpt_CCKTxPowerAdjust(PADAPTER Adapter, bool bInCH14);
+void hal_mpt_SetChannel(PADAPTER pAdapter);
+void hal_mpt_SetBandwidth(PADAPTER pAdapter);
+void hal_mpt_SetTxPower(PADAPTER pAdapter);
+void hal_mpt_SetDataRate(PADAPTER pAdapter);
+void hal_mpt_SetAntenna(PADAPTER pAdapter);
+s32 hal_mpt_SetThermalMeter(PADAPTER pAdapter, u8 target_ther);
+void hal_mpt_TriggerRFThermalMeter(PADAPTER pAdapter);
+u8 hal_mpt_ReadRFThermalMeter(PADAPTER pAdapter);
+void hal_mpt_GetThermalMeter(PADAPTER pAdapter, u8 *value);
+void hal_mpt_SetContinuousTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetSingleCarrierTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetSingleToneTx(PADAPTER pAdapter, u8 bStart);
+void hal_mpt_SetCarrierSuppressionTx(PADAPTER pAdapter, u8 bStart);
+void mpt_ProSetPMacTx(PADAPTER	Adapter);
+void MP_PHY_SetRFPathSwitch(PADAPTER pAdapter , bool bMain);
+u8 MP_PHY_QueryRFPathSwitch(PADAPTER pAdapter);
+u32 mpt_ProQueryCalTxPower(PADAPTER	pAdapter, u8 RfPath);
+void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
+u8 mpt_to_mgnt_rate(u32	MptRateIdx);
+u8 rtw_mpRateParseFunc(PADAPTER pAdapter, u8 *targetStr);
+u32 mp_join(PADAPTER padapter, u8 mode);
+u32 hal_mpt_query_phytxok(PADAPTER	pAdapter);
+
+void
+PMAC_Get_Pkt_Param(
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo
+);
+void
+CCK_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo
+);
+void
+PMAC_Nsym_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo
+);
+void
+L_SIG_generator(
+	u32	N_SYM,		/* Max: 750*/
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo
+);
+
+void HT_SIG_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo);
+
+void VHT_SIG_A_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo,
+	PRT_PMAC_PKT_INFO	pPMacPktInfo);
+
+void VHT_SIG_B_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo);
+
+void VHT_Delimiter_generator(
+	PRT_PMAC_TX_INFO	pPMacTxInfo);
+
+
+int rtw_mp_write_reg(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_read_reg(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_write_rf(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_read_rf(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_start(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_stop(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_rate(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_channel(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_bandwidth(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower_index(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_txpower(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_ant_tx(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_ant_rx(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_set_ctx_destAddr(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_ctx(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_disable_bt_coexist(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_disable_bt_coexist(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_arx(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_trx_query(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_pwrtrk(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_psd(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_thermal(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_reset_stats(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_dump(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_phypara(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_SetRFPath(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_QueryDrv(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_PwrCtlDM(struct net_device *dev,
+		struct iw_request_info *info,
+		struct iw_point *wrqu, char *extra);
+int rtw_mp_getver(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_mon(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_efuse_mask_file(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_efuse_file_map(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_SetBT(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_pretx_proc(PADAPTER padapter, u8 bStartTest, char *extra);
+int rtw_mp_tx(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_rx(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+int rtw_mp_hwtx(struct net_device *dev,
+		struct iw_request_info *info,
+		union iwreq_data *wrqu, char *extra);
+u8 HwRateToMPTRate(u8 rate);
+int rtw_mp_iqk(struct net_device *dev,
+		 struct iw_request_info *info,
+		 struct iw_point *wrqu, char *extra);
+int rtw_mp_lck(struct net_device *dev, 
+		struct iw_request_info *info, 
+		struct iw_point *wrqu, char *extra);
+#endif /* _RTW_MP_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_mp_ioctl.h b/drivers/staging/rtl8188eu/include/rtw_mp_ioctl.h
new file mode 100644
index 000000000000..301b1b0104d0
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mp_ioctl.h
@@ -0,0 +1,535 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_MP_IOCTL_H_
+#define _RTW_MP_IOCTL_H_
+
+#include <mp_custom_oid.h>
+#include <rtw_mp.h>
+
+/* ------------------------------------------------------------------------------ */
+typedef struct CFG_DBG_MSG_STRUCT {
+	u32 DebugLevel;
+	u32 DebugComponent_H32;
+	u32 DebugComponent_L32;
+} CFG_DBG_MSG_STRUCT, *PCFG_DBG_MSG_STRUCT;
+
+typedef struct _RW_REG {
+	u32 offset;
+	u32 width;
+	u32 value;
+} mp_rw_reg, RW_Reg, *pRW_Reg;
+
+/* for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM */
+typedef struct _EEPROM_RW_PARAM {
+	u32 offset;
+	u16 value;
+} eeprom_rw_param, EEPROM_RWParam, *pEEPROM_RWParam;
+
+typedef struct _EFUSE_ACCESS_STRUCT_ {
+	u16	start_addr;
+	u16	cnts;
+	u8	data[0];
+} EFUSE_ACCESS_STRUCT, *PEFUSE_ACCESS_STRUCT;
+
+typedef struct _BURST_RW_REG {
+	u32 offset;
+	u32 len;
+	u8 Data[256];
+} burst_rw_reg, Burst_RW_Reg, *pBurst_RW_Reg;
+
+typedef struct _USB_VendorReq {
+	u8	bRequest;
+	u16	wValue;
+	u16	wIndex;
+	u16	wLength;
+	u8	u8Dir;/* 0:OUT, 1:IN */
+	u8	u8InData;
+} usb_vendor_req, USB_VendorReq, *pUSB_VendorReq;
+
+typedef struct _DR_VARIABLE_STRUCT_ {
+	u8 offset;
+	u32 variable;
+} DR_VARIABLE_STRUCT;
+
+/* int mp_start_joinbss(_adapter *padapter, NDIS_802_11_SSID *pssid); */
+
+/* void _irqlevel_changed_(unsigned long *irqlevel, boolunsigned char bLower); */
+#define _irqlevel_changed_(a, b)
+
+/* oid_rtl_seg_81_80_00 */
+NDIS_STATUS oid_rt_pro_set_data_rate_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_start_test_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_stop_test_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_81_80_20 */
+NDIS_STATUS oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_modulation_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv *poid_par_priv);
+
+
+/* oid_rtl_seg_81_87 */
+NDIS_STATUS oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv *poid_par_priv);
+
+
+/* oid_rtl_seg_81_85 */
+NDIS_STATUS oid_rt_wireless_mode_hdl(struct oid_par_priv *poid_par_priv);
+
+
+/* oid_rtl_seg_87_11_00 */
+NDIS_STATUS oid_rt_pro8711_join_bss_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_register_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_register_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_read_register_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_burst_write_register_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write16_eeprom_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_rd_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_wr_attrib_mem_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_poll_rx_status_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_20 */
+NDIS_STATUS oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_read_tssi_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_50 */
+NDIS_STATUS oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv *poid_par_priv);
+/* oid_rtl_seg_87_11_F0 */
+NDIS_STATUS oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv *poid_par_priv);
+
+
+/* oid_rtl_seg_87_12_00 */
+NDIS_STATUS oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_add_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_set_bandwidth_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_crystal_cap_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_set_rx_packet_type_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_efuse_max_size_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_get_thermal_meter_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv *poid_par_priv);
+NDIS_STATUS oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_set_power_down_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv);
+
+NDIS_STATUS oid_rt_pro_trigger_gpio_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+const struct oid_obj_priv oid_rtl_seg_81_80_00[] = {
+	{1, &oid_null_function},			/* 0x00	OID_RT_PRO_RESET_DUT */
+	{1, &oid_rt_pro_set_data_rate_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_start_test_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_stop_test_hdl},			/* 0x03 */
+	{1, &oid_null_function},			/* 0x04	OID_RT_PRO_SET_PREAMBLE */
+	{1, &oid_null_function},			/* 0x05	OID_RT_PRO_SET_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x06	OID_RT_PRO_SET_FILTER_BB */
+	{1, &oid_null_function},			/* 0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB */
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	/* 0x08 */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL */
+	{1, &oid_null_function},			/* 0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL */
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		/* 0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL */
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	/* 0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS */
+	{1, &oid_null_function},			/* 0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB */
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F	OID_RT_PRO_SET_CR_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_SET_CR_NEW_FILTER */
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	/* 0x11	OID_RT_PRO_SET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x12	OID_RT_PRO_SET_CR_TX_CONFIG */
+	{1, &oid_null_function},			/* 0x13	OID_RT_PRO_GET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x15	OID_RT_PRO_SET_CR_SETPOINT */
+	{1, &oid_null_function},			/* 0x16	OID_RT_PRO_SET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x17	OID_RT_PRO_SET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x18	OID_RT_PRO_GET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x19	OID_RT_PRO_GET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE */
+	{1, &oid_null_function},			/* 0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1C	OID_RT_PRO_READ_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1D	OID_RT_PRO_WRITE_CIS_DATA */
+	{1, &oid_null_function},			/* 0x1E	OID_RT_PRO_READ_CIS_DATA */
+	{1, &oid_null_function}				/* 0x1F	OID_RT_PRO_WRITE_POWER_CONTROL */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_20[] = {
+	{1, &oid_null_function},			/* 0x20	OID_RT_PRO_READ_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x21	OID_RT_PRO_WRITE_EEPROM */
+	{1, &oid_null_function},			/* 0x22	OID_RT_PRO_READ_EEPROM */
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	/* 0x23 */
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	/* 0x24 */
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	/* 0x25 */
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	/* 0x26 */
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	/* 0x27 */
+	{1, &oid_null_function},			/* 0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS */
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},/* 0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX */
+	{1, &oid_null_function},			/* 0x2C	OID_RT_PRO_RECEIVE_PACKET */
+	{1, &oid_null_function},			/* 0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE */
+	{1, &oid_null_function},			/* 0x2E	OID_RT_PRO_READ_EEPROM_BYTE */
+	{1, &oid_rt_pro_set_modulation_hdl}		/* 0x2F */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_40[] = {
+	{1, &oid_null_function},			/* 0x40 */
+	{1, &oid_null_function},			/* 0x41 */
+	{1, &oid_null_function},			/* 0x42 */
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	/* 0x43 */
+	{1, &oid_null_function},			/* 0x44 */
+	{1, &oid_null_function}				/* 0x45 */
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_80[] = {
+	{1, &oid_null_function},			/* 0x80	OID_RT_DRIVER_OPTION */
+	{1, &oid_null_function},			/* 0x81	OID_RT_RF_OFF */
+	{1, &oid_null_function}				/* 0x82	OID_RT_AUTH_STATUS */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_85[] = {
+	{1, &oid_rt_wireless_mode_hdl}			/* 0x00	OID_RT_WIRELESS_MODE */
+};
+
+struct oid_obj_priv oid_rtl_seg_81_87[] = {
+	{1, &oid_null_function},			/* 0x80	OID_RT_PRO8187_WI_POLL */
+	{1, &oid_rt_pro_write_bb_reg_hdl},		/* 0x81 */
+	{1, &oid_rt_pro_read_bb_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_write_rf_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_read_rf_reg_hdl}		/* 0x83 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_00[] = {
+	{1, &oid_rt_pro8711_join_bss_hdl},		/* 0x00  */ /* S */
+	{1, &oid_rt_pro_read_register_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_write_register_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_burst_read_register_hdl},	/* 0x03 */
+	{1, &oid_rt_pro_burst_write_register_hdl},	/* 0x04 */
+	{1, &oid_rt_pro_write_txcmd_hdl},		/* 0x05 */
+	{1, &oid_rt_pro_read16_eeprom_hdl},		/* 0x06 */
+	{1, &oid_rt_pro_write16_eeprom_hdl},		/* 0x07 */
+	{1, &oid_null_function},			/* 0x08	OID_RT_PRO_H2C_SET_COMMAND */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_H2C_QUERY_RESULT */
+	{1, &oid_rt_pro8711_wi_poll_hdl},		/* 0x0A */
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		/* 0x0B */
+	{1, &oid_rt_rd_attrib_mem_hdl},			/* 0x0C */
+	{1, &oid_rt_wr_attrib_mem_hdl},			/* 0x0D */
+	{1, &oid_null_function},			/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_H2C_CMD_MODE */
+	{1, &oid_null_function},			/* 0x11	OID_RT_PRO_H2C_CMD_RSP_MODE */
+	{1, &oid_null_function},			/* 0X12	OID_RT_PRO_WAIT_C2H_EVENT */
+	{1, &oid_null_function},			/* 0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST */
+	{1, &oid_null_function},			/* 0X14	OID_RT_PRO_SCSI_ACCESS_TEST */
+	{1, &oid_null_function},			/* 0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT */
+	{1, &oid_null_function},			/* 0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN */
+	{1, &oid_null_function},			/* 0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X19	OID_RT_RPO_SET_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1A */
+	{1, &oid_null_function},			/* 0X1B	OID_RT_PRO_QRY_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1C	OID_RT_RPO_ASYNC_RWIO_TEST */
+	{1, &oid_null_function},			/* 0X1D	OID_RT_RPO_ASYNC_RWIO_POLL */
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		/* 0X1E */
+	{1, &oid_rt_poll_rx_status_hdl}			/* 0X1F */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_20[] = {
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		/* 0x20 */
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		/* 0x21 */
+	{1, &oid_rt_pro_set_basic_rate_hdl},		/* 0x22 */
+	{1, &oid_rt_pro_read_tssi_hdl},			/* 0x23 */
+	{1, &oid_rt_pro_set_power_tracking_hdl}		/* 0x24 */
+};
+
+
+struct oid_obj_priv oid_rtl_seg_87_11_50[] = {
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		/* 0x50 */
+	{1, &oid_rt_pro_set_pwrstate_hdl}		/* 0x51 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_80[] = {
+	{1, &oid_null_function}				/* 0x80 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_B0[] = {
+	{1, &oid_null_function}				/* 0xB0 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_F0[] = {
+	{1, &oid_null_function},			/* 0xF0 */
+	{1, &oid_null_function},			/* 0xF1 */
+	{1, &oid_null_function},			/* 0xF2 */
+	{1, &oid_null_function},			/* 0xF3 */
+	{1, &oid_null_function},			/* 0xF4 */
+	{1, &oid_null_function},			/* 0xF5 */
+	{1, &oid_null_function},			/* 0xF6 */
+	{1, &oid_null_function},			/* 0xF7 */
+	{1, &oid_null_function},			/* 0xF8 */
+	{1, &oid_null_function},			/* 0xF9 */
+	{1, &oid_null_function},			/* 0xFA */
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	/* 0xFB */
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	/* 0xFC */
+	{1, &oid_null_function},			/* 0xFD */
+	{1, &oid_null_function},			/* 0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST */
+	{1, &oid_null_function}				/* 0xFF */
+
+};
+
+struct oid_obj_priv oid_rtl_seg_87_12_00[] = {
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		/* 0x00	Q&S */
+	{1, &oid_rt_pro_add_sta_info_hdl},		/* 0x01	S */
+	{1, &oid_rt_pro_dele_sta_info_hdl},		/* 0x02	S */
+	{1, &oid_rt_pro_query_dr_variable_hdl},		/* 0x03	Q */
+	{1, &oid_rt_pro_rx_packet_type_hdl},		/* 0x04	Q,S */
+	{1, &oid_rt_pro_read_efuse_hdl},		/* 0x05	Q	OID_RT_PRO_READ_EFUSE */
+	{1, &oid_rt_pro_write_efuse_hdl},		/* 0x06	S	OID_RT_PRO_WRITE_EFUSE */
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		/* 0x07	Q,S */
+	{1, &oid_rt_get_efuse_current_size_hdl},	/* 0x08 	Q */
+	{1, &oid_rt_set_bandwidth_hdl},			/* 0x09 */
+	{1, &oid_rt_set_crystal_cap_hdl},		/* 0x0a */
+	{1, &oid_rt_set_rx_packet_type_hdl},		/* 0x0b	S */
+	{1, &oid_rt_get_efuse_max_size_hdl},		/* 0x0c */
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		/* 0x0d */
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		/* 0x0e */
+	{1, &oid_null_function},			/* 0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING */
+	{1, &oid_rt_get_thermal_meter_hdl},		/* 0x10	Q	OID_RT_PRO_GET_THERMAL_METER */
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	/* 0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT */
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	/* 0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED */
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	/* 0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR */
+	{1, &oid_rt_set_power_down_hdl},		/* 0x14	Q	OID_RT_SET_POWER_DOWN */
+	{1, &oid_rt_get_power_mode_hdl}			/* 0x15	Q	OID_RT_GET_POWER_MODE */
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+struct rwreg_param {
+	u32 offset;
+	u32 width;
+	u32 value;
+};
+
+struct bbreg_param {
+	u32 offset;
+	u32 phymask;
+	u32 value;
+};
+/*
+struct rfchannel_param{
+	u32 ch;
+	u32 modem;
+};
+*/
+struct txpower_param {
+	u32 pwr_index;
+};
+
+
+struct datarate_param {
+	u32 rate_index;
+};
+
+
+struct rfintfs_parm {
+	u32 rfintfs;
+};
+
+typedef struct _mp_xmit_parm_ {
+	u8 enable;
+	u32 count;
+	u16 length;
+	u8 payload_type;
+	u8 da[ETH_ALEN];
+} MP_XMIT_PARM, *PMP_XMIT_PARM;
+
+struct mp_xmit_packet {
+	u32 len;
+	u32 mem[MAX_MP_XMITBUF_SZ >> 2];
+};
+
+struct psmode_param {
+	u32 ps_mode;
+	u32 smart_ps;
+};
+
+/* for OID_RT_PRO_READ16_EEPROM & OID_RT_PRO_WRITE16_EEPROM */
+struct eeprom_rw_param {
+	u32 offset;
+	u16 value;
+};
+
+struct mp_ioctl_handler {
+	u32 paramsize;
+	u32(*handler)(struct oid_par_priv *poid_par_priv);
+	u32 oid;
+};
+
+struct mp_ioctl_param {
+	u32 subcode;
+	u32 len;
+	u8 data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START),			/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP),
+	GEN_MP_IOCTL_SUBCODE(READ_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*10*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),
+	GEN_MP_IOCTL_SUBCODE(SET_ANTENNA),
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),
+	GEN_MP_IOCTL_SUBCODE(SC_TX),
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*15*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*20*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(EFUSE),
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*30*/
+	GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO),
+	GEN_MP_IOCTL_SUBCODE(SET_DM_BT),		/*32*/
+	GEN_MP_IOCTL_SUBCODE(DEL_BA),			/*33*/
+	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*34*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+u32 mp_ioctl_xmit_packet_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+#define GEN_MP_IOCTL_HANDLER(sz, hdl, oid) {sz, hdl, oid},
+
+#define EXT_MP_IOCTL_HANDLER(sz, subcode, oid) {sz, mp_ioctl_ ## subcode ## _hdl, oid},
+
+
+struct mp_ioctl_handler mp_ioctl_hdl[] = {
+
+	/*0*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_start_test_hdl, OID_RT_PRO_START_TEST)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_stop_test_hdl, OID_RT_PRO_STOP_TEST)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_register_hdl, OID_RT_PRO_READ_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_register_hdl, OID_RT_PRO_WRITE_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_read_bb_reg_hdl, OID_RT_PRO_READ_BB_REG)
+	/*5*/	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_write_bb_reg_hdl, OID_RT_PRO_WRITE_BB_REG)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_read_rf_reg_hdl, OID_RT_PRO_RF_READ_REGISTRY)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_write_rf_reg_hdl, OID_RT_PRO_RF_WRITE_REGISTRY)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_channel_direct_call_hdl, OID_RT_PRO_SET_CHANNEL_DIRECT_CALL)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct txpower_param), oid_rt_pro_set_tx_power_control_hdl, OID_RT_PRO_SET_TX_POWER_CONTROL)
+	/*10*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_data_rate_hdl, OID_RT_PRO_SET_DATA_RATE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_bandwidth_hdl, OID_RT_SET_BANDWIDTH)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_antenna_bb_hdl, OID_RT_PRO_SET_ANTENNA_BB)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_continuous_tx_hdl, OID_RT_PRO_SET_CONTINUOUS_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl, OID_RT_PRO_SET_SINGLE_CARRIER_TX)
+	/*15*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl, OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl, OID_RT_PRO_SET_SINGLE_TONE_TX)
+
+	EXT_MP_IOCTL_HANDLER(0, xmit_packet, 0)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_rx_packet_type_hdl, OID_RT_SET_RX_PACKET_TYPE)
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_reset_phy_rx_packet_count_hdl, OID_RT_RESET_PHY_RX_PACKET_COUNT)
+	/*20*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl, OID_RT_GET_PHY_RX_PACKET_RECEIVED)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl, OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(EFUSE_ACCESS_STRUCT), oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE)
+	/*25*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_efuse_map_hdl, OID_RT_PRO_EFUSE_MAP)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_max_size_hdl, OID_RT_GET_EFUSE_MAX_SIZE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_current_size_hdl, OID_RT_GET_EFUSE_CURRENT_SIZE)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_thermal_meter_hdl, OID_RT_PRO_GET_THERMAL_METER)
+	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_pro_set_power_tracking_hdl, OID_RT_PRO_SET_POWER_TRACKING)
+	/*30*/	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_set_power_down_hdl, OID_RT_SET_POWER_DOWN)
+	/*31*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_trigger_gpio_hdl, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+	GEN_MP_IOCTL_HANDLER(0, NULL, 0)
+};
+
+#else /* _RTW_MP_IOCTL_C_ */
+
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+
+#endif /* _RTW_MP_IOCTL_C_ */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_mp_phy_regdef.h b/drivers/staging/rtl8188eu/include/rtw_mp_phy_regdef.h
new file mode 100644
index 000000000000..4d698f54fc3f
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_mp_phy_regdef.h
@@ -0,0 +1,1074 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+/*****************************************************************************
+ *
+ * Module:	__RTW_MP_PHY_REGDEF_H_
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *	Data			Who		Remark
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __RTW_MP_PHY_REGDEF_H_
+#define __RTW_MP_PHY_REGDEF_H_
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/* ************************************************************
+ * 8192S Regsiter offset definition
+ * ************************************************************ */
+
+/*
+ * BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+ * 3. RF register 0x00-2E
+ * 4. Bit Mask for BB/RF register
+ * 5. Other defintion for BB/RF R/W
+ *   */
+
+
+/*
+ * 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+ * 1. Page1(0x100)
+ *   */
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+/*
+ * 2. Page2(0x200)
+ *
+ * The following two definition are only used for USB interface.
+ * #define		RF_BB_CMD_ADDR				0x02c0 */	/* RF/BB read/write command address.
+ * #define		RF_BB_CMD_DATA				0x02c4 */	/* RF/BB read/write command data. */
+
+/*
+ * 3. Page8(0x800)
+ *   */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA0_TxInfo				0x804	/* Status report?? */
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	/* Set TX PWR init gain? */
+
+#define		rFPGA0_RFTiming1			0x810	/* Useless now */
+#define		rFPGA0_RFTiming2			0x814
+/* #define rFPGA0_XC_RFTiming		0x818 */
+/* #define rFPGA0_XD_RFTiming		0x81c */
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	/* RF 3 wire register */
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rFPGA0_XC_HSSIParameter1		0x830
+#define		rFPGA0_XC_HSSIParameter2		0x834
+#define		rFPGA0_XD_HSSIParameter1		0x838
+#define		rFPGA0_XD_HSSIParameter2		0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rFPGA0_XC_LSSIParameter		0x848
+#define		rFPGA0_XD_LSSIParameter		0x84c
+
+#define		rFPGA0_RFWakeUpParameter		0x850	/* Useless now */
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	/* RF Channel switch */
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/* RF Channel switch */
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XC_RFInterfaceOE		0x868
+#define		rFPGA0_XD_RFInterfaceOE		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/* RF Interface Software Control */
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	/* RF Parameter */
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	/* Crystal cap setting RF-R/W protection for parameter4?? */
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	/* Useless now */
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/* Tranceiver LSSI Readback */
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	/* Useless now */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/* Useless now */ /* RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/* Useless now */
+
+/*
+ * 4. Page9(0x900)
+ *   */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC */ /* RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/* Useless now */
+#define		rFPGA1_DebugSelect			0x908	/* Useless now */
+#define		rFPGA1_TxInfo				0x90c	/* Useless now */ /* Status report?? */
+#define	rS0S1_PathSwitch			0x948
+
+/*
+ * 5. PageA(0xA00)
+ *
+ * Set Control channel to upper or lower. These settings are required only for 40MHz */
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	/* Disable init gain now */ /* Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/* Disable init gain now */ /* Init gain */
+
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level  */ /* Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
+#define		rCCK0_TRSSIReport		0xa50
+#define		rCCK0_RxReport            		0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower      	0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper      	0xa58  /* 0xa5c */
+
+/*
+ * 6. PageC(0xC00)
+ *   */
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance    	0xc14  /* RxIQ imblance matrix */
+#define		rOFDM0_XBRxAFE		0xc18
+#define		rOFDM0_XBRxIQImbalance	0xc1c
+#define		rOFDM0_XCRxAFE		0xc20
+#define		rOFDM0_XCRxIQImbalance	0xc24
+#define		rOFDM0_XDRxAFE		0xc28
+#define		rOFDM0_XDRxIQImbalance	0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  /* PD, BW & SBD	 */ /* DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /* energy CCA */
+
+#define		rOFDM0_XAAGCCore1			0xc50	/* DIG  */
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	/* TX PWR TRACK and DIG */
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta			0xca0
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+/*
+ * 7. PageD(0xD00)
+ *   */
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	/* No setting now */
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
+
+#define		rOFDM_ShortCFOAB				0xdac	/* No setting now */
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1		0xdc4
+#define		rOFDM_PWMeasure2		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+/*
+ * 8. PageE(0xE00)
+ *   */
+#define		rTxAGC_Rate18_06				0xe00
+#define		rTxAGC_Rate54_24				0xe04
+#define		rTxAGC_CCK_Mcs32				0xe08
+#define		rTxAGC_Mcs03_Mcs00			0xe10
+#define		rTxAGC_Mcs07_Mcs04			0xe14
+#define		rTxAGC_Mcs11_Mcs08			0xe18
+#define		rTxAGC_Mcs15_Mcs12			0xe1c
+
+/* Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register] */
+#define		rRx_Wait_CCCA					0xe70
+#define		rAnapar_Ctrl_BB					0xee0
+
+/*
+ * 7. RF Register 0x00-0x2E (RF 8256)
+ * RF-0222D 0x00-3F
+ *
+ * Zebra1 */
+#define RTL92SE_FPGA_VERIFY 0
+#define		rZebra1_HSSIEnable				0x0	/* Useless now */
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+/* #if (RTL92SE_FPGA_VERIFY == 1) */
+#define		rZebra1_Channel				0x7	/* RF channel switch
+ * #else */
+
+/* #endif */
+#define		rZebra1_TxGain					0x8	/* Useless now */
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+/* Zebra4 */
+#define		rGlobalCtrl						0	/* Useless now */
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/* Useless now */
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+/*
+ * RL6052 Register definition
+ *   */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_BS_IQGEN				0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_TXBIAS					0x16
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/* RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/* RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x24	/*  */
+
+#define		RF_SYN_G1					0x25	/* RF TX Power control */
+#define		RF_SYN_G2					0x26	/* RF TX Power control */
+#define		RF_SYN_G3					0x27	/* RF TX Power control */
+#define		RF_SYN_G4					0x28	/* RF TX Power control */
+#define		RF_SYN_G5					0x29	/* RF TX Power control */
+#define		RF_SYN_G6					0x2A	/* RF TX Power control */
+#define		RF_SYN_G7					0x2B	/* RF TX Power control */
+#define		RF_SYN_G8					0x2C	/* RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/* RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/* RF TX PA control */
+#define		RF_TXPA_G2					0x32	/* RF TX PA control */
+#define		RF_TXPA_G3					0x33	/* RF TX PA control */
+
+/*
+ * Bit Mask
+ *
+ * 1. Page1(0x100) */
+#define		bBBResetB						0x100	/* Useless now? */
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define		IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+/* 2. Page8(0x800) */
+#define		bRFMOD							0x1	/* Reg 0x800 rFPGA0_RFMOD */
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase           		0x10000	/* Useless now */
+#define		bOFDMTxDACPhase		0x40000
+#define		bXATxAGC			0x3f
+
+#define		bXBTxAGC                  			0xf00	/* Reg 80c rFPGA0_TxGainStage */
+#define		bXCTxAGC			0xf000
+#define		bXDTxAGC			0xf0000
+
+#define		bPAStart                  			0xf0000000	/* Useless now */
+#define		bTRStart			0x00f00000
+#define		bRFStart			0x0000f000
+#define		bBBStart			0x000000f0
+#define		bBBCCKStart		0x0000000f
+#define		bPAEnd                    			0xf          /* Reg0x814 */
+#define		bTREnd			0x0f000000
+#define		bRFEnd			0x000f0000
+#define		bCCAMask                  			0x000000f0   /* T2R */
+#define		bR2RCCAMask		0x00000f00
+#define		bHSSI_R2TDelay		0xf8000000
+#define		bHSSI_T2RDelay		0xf80000
+#define		bContTxHSSI               		0x400     /* chane gain at continue Tx */
+#define		bIGFromCCK		0x200
+#define		bAGCAddress		0x3f
+#define		bRxHPTx			0x7000
+#define		bRxHPT2R			0x38000
+#define		bRxHPCCKIni		0xc0000
+#define		bAGCTxCode		0xc00000
+#define		bAGCRxCode		0x300000
+
+#define		b3WireDataLength          		0x800	/* Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
+#define		b3WireAddressLength		0x400
+
+#define		b3WireRFPowerDown         		0x1	/* Useless now
+ * #define bHWSISelect		0x8 */
+#define		b5GPAPEPolarity		0x40000000
+#define		b2GPAPEPolarity		0x80000000
+#define		bRFSW_TxDefaultAnt		0x3
+#define		bRFSW_TxOptionAnt		0x30
+#define		bRFSW_RxDefaultAnt		0x300
+#define		bRFSW_RxOptionAnt		0x3000
+#define		bRFSI_3WireData		0x1
+#define		bRFSI_3WireClock		0x2
+#define		bRFSI_3WireLoad		0x4
+#define		bRFSI_3WireRW		0x8
+#define		bRFSI_3Wire			0xf
+
+#define		bRFSI_RFENV               		0x10	/* Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+
+#define		bRFSI_TRSW                		0x20	/* Useless now */
+#define		bRFSI_TRSWB		0x40
+#define		bRFSI_ANTSW		0x100
+#define		bRFSI_ANTSWB		0x200
+#define		bRFSI_PAPE			0x400
+#define		bRFSI_PAPE5G		0x800
+#define		bBandSelect			0x1
+#define		bHTSIG2_GI			0x80
+#define		bHTSIG2_Smoothing		0x01
+#define		bHTSIG2_Sounding		0x02
+#define		bHTSIG2_Aggreaton		0x08
+#define		bHTSIG2_STBC		0x30
+#define		bHTSIG2_AdvCoding		0x40
+#define		bHTSIG2_NumOfHTLTF	0x300
+#define		bHTSIG2_CRC8		0x3fc
+#define		bHTSIG1_MCS		0x7f
+#define		bHTSIG1_BandWidth		0x80
+#define		bHTSIG1_HTLength		0xffff
+#define		bLSIG_Rate			0xf
+#define		bLSIG_Reserved		0x10
+#define		bLSIG_Length		0x1fffe
+#define		bLSIG_Parity			0x20
+#define		bCCKRxPhase		0x4
+#if (RTL92SE_FPGA_VERIFY == 1)
+	#define		bLSSIReadAddress          		0x3f000000   /* LSSI "Read" Address	 */ /* Reg 0x824 rFPGA0_XA_HSSIParameter2 */
+#else
+	#define		bLSSIReadAddress          		0x7f800000   /* T65 RF */
+#endif
+#define		bLSSIReadEdge             		0x80000000   /* LSSI "Read" edge signal */
+#if (RTL92SE_FPGA_VERIFY == 1)
+	#define		bLSSIReadBackData         		0xfff		/* Reg 0x8a0 rFPGA0_XA_LSSIReadBack */
+#else
+	#define		bLSSIReadBackData         		0xfffff		/* T65 RF */
+#endif
+#define		bLSSIReadOKFlag           		0x1000	/* Useless now */
+#define		bCCKSampleRate            		0x8       /* 0: 44MHz, 1:88MHz      		 */
+#define		bRegulator0Standby		0x1
+#define		bRegulatorPLLStandby		0x2
+#define		bRegulator1Standby		0x4
+#define		bPLLPowerUp		0x8
+#define		bDPLLPowerUp		0x10
+#define		bDA10PowerUp		0x20
+#define		bAD7PowerUp		0x200
+#define		bDA6PowerUp		0x2000
+#define		bXtalPowerUp		0x4000
+#define		b40MDClkPowerUP		0x8000
+#define		bDA6DebugMode		0x20000
+#define		bDA6Swing			0x380000
+
+#define		bADClkPhase               		0x4000000	/* Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+
+#define		b80MClkDelay              		0x18000000	/* Useless */
+#define		bAFEWatchDogEnable		0x20000000
+
+#define		bXtalCap01                			0xc0000000	/* Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define		bXtalCap23			0x3
+#define		bXtalCap92x					0x0f000000
+#define		bXtalCap			0x0f000000
+
+#define		bIntDifClkEnable          		0x400	/* Useless */
+#define		bExtSigClkEnable		0x800
+#define		bBandgapMbiasPowerUp	0x10000
+#define		bAD11SHGain		0xc0000
+#define		bAD11InputRange		0x700000
+#define		bAD11OPCurrent		0x3800000
+#define		bIPathLoopback		0x4000000
+#define		bQPathLoopback		0x8000000
+#define		bAFELoopback		0x10000000
+#define		bDA10Swing		0x7e0
+#define		bDA10Reverse		0x800
+#define		bDAClkSource		0x1000
+#define		bAD7InputRange		0x6000
+#define		bAD7Gain			0x38000
+#define		bAD7OutputCMMode		0x40000
+#define		bAD7InputCMMode		0x380000
+#define		bAD7Current			0xc00000
+#define		bRegulatorAdjust		0x7000000
+#define		bAD11PowerUpAtTx		0x1
+#define		bDA10PSAtTx		0x10
+#define		bAD11PowerUpAtRx		0x100
+#define		bDA10PSAtRx		0x1000
+#define		bCCKRxAGCFormat		0x200
+#define		bPSDFFTSamplepPoint		0xc000
+#define		bPSDAverageNum		0x3000
+#define		bIQPathControl		0xc00
+#define		bPSDFreq			0x3ff
+#define		bPSDAntennaPath		0x30
+#define		bPSDIQSwitch		0x40
+#define		bPSDRxTrigger		0x400000
+#define		bPSDTxTrigger		0x80000000
+#define		bPSDSineToneScale		0x7f000000
+#define		bPSDReport			0xffff
+
+/* 3. Page9(0x900) */
+#define		bOFDMTxSC                 		0x30000000	/* Useless */
+#define		bCCKTxOn			0x1
+#define		bOFDMTxOn		0x2
+#define		bDebugPage                		0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem                		0xff   /* reset debug page and LWord */
+#define		bAntL			0x10
+#define		bAntNonHT				0x100
+#define		bAntHT1			0x1000
+#define		bAntHT2			0x10000
+#define		bAntHT1S1			0x100000
+#define		bAntNonHTS1		0x1000000
+
+/* 4. PageA(0xA00) */
+#define		bCCKBBMode                		0x3	/* Useless */
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand              		0x10	/* Reg 0xa00 rCCK0_System 20/40 switch */
+
+#define		bCCKScramble              		0x8	/* Useless */
+#define		bCCKAntDiversity			0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate			0x3000
+#define		bCCKDCCancel		0x0800
+#define		bCCKISICancel		0x0400
+#define		bCCKMatchFilter		0x0200
+#define		bCCKEqualizer		0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart		0x300000
+#define		bCCKCCACount		0x080000
+#define		bCCKcs_lim			0x070000
+#define		bCCKBistMode		0x80000000
+#define		bCCKCCAMask		0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase         	   	0x20000000   /* r_rx_clk */
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset		0xf0
+#define		bCCKRxDCOffset		0xf
+#define		bCCKCCAMode		0xc000
+#define		bCCKFalseCS_lim		0x3f00
+#define		bCCKCS_ratio		0xc00000
+#define		bCCKCorgBit_sel		0x300000
+#define		bCCKPD_lim			0x0f0000
+#define		bCCKNewCCA		0x80000000
+#define		bCCKRxHPofIG		0x8000
+#define		bCCKRxIG			0x7f00
+#define		bCCKLNAPolarity		0x800000
+#define		bCCKRx1stGain		0x7f0000
+#define		bCCKRFExtend              		0x20000000 /* CCK Rx Iinital gain polarity */
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle            		0x1f       /* AGCsamp_dly */
+#define		bCCKFixedRxAGC		0x8000
+/* #define bCCKRxAGCFormat		0x4000 */   /* remove to HSSI register 0x824 */
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType		0x0300
+#define		bCCKRxDAGCEn		0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0			0x3f0000
+#define		bCCKTxC1			0x3f000000
+#define		bCCKTxC2			0x3f
+#define		bCCKTxC3			0x3f00
+#define		bCCKTxC4			0x3f0000
+#define		bCCKTxC5			0x3f000000
+#define		bCCKTxC6			0x3f
+#define		bCCKTxC7			0x3f00
+#define		bCCKDebugPort		0xff0000
+#define		bCCKDACDebug		0x0f000000
+#define		bCCKFalseAlarmEnable		0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI			0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel		0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss		0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate		0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze		0x4000
+#define		bCCKTxPathSel		0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+/* 5. PageC(0xC00) */
+#define		bNumOfSTF                			0x3	/* Useless */
+#define		bShift_L			0xc0
+#define		bGI_TH			0xc
+#define		bRxPathA			0x1
+#define		bRxPathB			0x2
+#define		bRxPathC			0x4
+#define		bRxPathD			0x8
+#define		bTxPathA			0x1
+#define		bTxPathB			0x2
+#define		bTxPathC			0x4
+#define		bTxPathD			0x8
+#define		bTRSSIFreq			0x200
+#define		bADCBackoff			0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode		0x1800000
+#define		bRxDCNFType		0xe000000
+#define		bRXIQImb_A			0x3ff
+#define		bRXIQImb_B			0xfc00
+#define		bRXIQImb_C			0x3f0000
+#define		bRXIQImb_D			0xffc00000
+#define		bDC_dc_Notch		0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH			0xf
+#define		bPD_TH_Opt2		0xc000
+#define		bPWED_TH			0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option			0x1000
+#define		bMF_Win_L			0xe000
+#define		bBW_Search_L		0x30000
+#define		bwin_enh_L			0xc0000
+#define		bBW_TH			0x700000
+#define		bED_TH2			0x3800000
+#define		bBW_option			0x4000000
+#define		bRatio_TH			0x18000000
+#define		bWindow_L			0xe0000000
+#define		bSBD_Option			0x1
+#define		bFrame_TH			0x1c
+#define		bFS_Option			0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L		0xe00
+#define		bFrame_Weight_Short		0x7000
+#define		bSub_Tune			0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2		0x7
+#define		bFrame_GI2_TH		0x38
+#define		bGI2_Sync_en		0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum		0x1
+#define		bCFOAcc			0x2
+#define		bCFOStartOffset		0xc
+#define		bCFOLookBack		0x70
+#define		bCFOSumWeight		0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A			0x3ff
+#define		bTXIQImb_B			0xfc00
+#define		bTXIQImb_C			0x3f0000
+#define		bTXIQImb_D			0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode		0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption		0x20000
+#define		bCCADropThres		0xfff00000
+#define		bEDCCA_H			0xf
+#define		bEDCCA_L			0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen                0x7f000000   /* the threshold for ant diversity */
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+/* #define bRxMF_Hold               0x3800 */
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000
+#define		bDAFormat                0x40000
+#define		bTxChEmuEnable           0x01000000
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000
+#define		bExtLNAGain              0x7c00
+
+/* 6. PageE(0xE00) */
+#define		bSTBCEn                  0x4	/* Useless */
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+/* #define bRxPath1                 0x01 */
+/* #define bRxPath2                 0x02 */
+/* #define bRxPath3                 0x04 */
+/* #define bRxPath4                 0x08 */
+/* #define bTxPath1                 0x10 */
+/* #define bTxPath2                 0x20 */
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   /* total */
+#define		bShortCFOFLength         11   /* fraction */
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+
+#define		bSFactorQAM1             0xf	/* Useless */
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+
+#define		bNoiseLvlTopSet          0x3	/* Useless */
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+
+#define		bLoopFitType             0x1	/* Useless */
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	/* Useless */
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK			0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn         0x20000000	/* Useless */
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+/* 7. RF Register
+ * Zebra1 */
+#define		bZebra1_HSSIEnable        0x8		/* Useless */
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1      0x100	/* Useless */
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW          0xc	/* Useless */
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+/*
+ * Other Definition
+ *   */
+
+/* byte endable for sb_write */
+#define		bByte0                    0x1	/* Useless */
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0		0xff	/* Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define		bMaskByte1		0xff00
+#define		bMaskByte2		0xff0000
+#define		bMaskByte3		0xff000000
+#define		bMaskHWord	0xffff0000
+#define		bMaskLWord		0x0000ffff
+#define		bMaskDWord	0xffffffff
+#define		bMaskH4Bits		0xf0000000
+#define		bMaskH3Bytes	0xffffff00
+#define		bMaskOFDM_D	0xffc00000
+#define		bMaskCCK		0x3f3f3f3f
+#define		bMask12Bits		0xfff
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
+#if (RTL92SE_FPGA_VERIFY == 1)
+/* #define		bMask12Bits               0xfff */	/* RF Reg mask bits */
+/* #define		bMask20Bits               0xfff */	/* RF Reg mask bits T65 RF */
+#define		bRFRegOffsetMask	0xfff
+#else
+/* #define		bMask12Bits               0xfffff */	/* RF Reg mask bits */
+/* #define		bMask20Bits               0xfffff */	/* RF Reg mask bits T65 RF */
+#define		bRFRegOffsetMask	0xfffff
+#endif
+#define		bEnable                   0x1	/* Useless */
+#define		bDisable                  0x0
+
+#define		LeftAntenna               0x0	/* Useless */
+#define		RightAntenna              0x1
+
+#define		tCheckTxStatus            500   /* 500ms */ /* Useless */
+#define		tUpdateRxCounter          100   /* 100ms */
+
+#define		rateCCK     0	/* Useless */
+#define		rateOFDM    1
+#define		rateHT      2
+
+/* define Register-End */
+#define		bPMAC_End                 0x1ff	/* Useless */
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+/* define max debug item in each debug page
+ * #define bMaxItem_FPGA_PHY0        0x9
+ * #define bMaxItem_FPGA_PHY1        0x3
+ * #define bMaxItem_PHY_11B          0x16
+ * #define bMaxItem_OFDM_PHY0        0x29
+ * #define bMaxItem_OFDM_PHY1        0x0 */
+
+#define		bPMACControl	0x0		/* Useless */
+#define		bWMACControl	0x1
+#define		bWNICControl	0x2
+
+#define RCR_AAP			BIT(0)				/* accept all physical address */
+#define RCR_APM			BIT(1)				/* accept physical match */
+#define RCR_AM			BIT(2)				/* accept multicast */
+#define RCR_AB			BIT(3)				/* accept broadcast */
+#define RCR_ACRC32		BIT(5)				/* accept error packet */
+#define RCR_9356SEL		BIT(6)
+#define RCR_AICV		BIT(9)				/* Accept ICV error packet */
+#define RCR_RXFTH0		(BIT(13) | BIT(14) | BIT(15))	/* Rx FIFO threshold */
+#define RCR_ADF			BIT(18)				/* Accept Data(frame type) frame */
+#define RCR_ACF			BIT(19)				/* Accept control frame */
+#define RCR_AMF			BIT(20)				/* Accept management frame */
+#define RCR_ADD3		BIT(21)
+#define RCR_APWRMGT		BIT(22)				/* Accept power management packet */
+#define RCR_CBSSID		BIT(23)				/* Accept BSSID match packet */
+#define RCR_ENMARP		BIT(28)				/* enable mac auto reset phy */
+#define RCR_EnCS1		BIT(29)				/* enable carrier sense method 1 */
+#define RCR_EnCS2		BIT(30)				/* enable carrier sense method 2 */
+#define RCR_OnlyErlPkt		BIT(31)				/* Rx Early mode is performed for packet size greater than 1536 */
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif /* __INC_HAL8192SPHYREG_H */
diff --git a/drivers/staging/rtl8188eu/include/rtw_odm.h b/drivers/staging/rtl8188eu/include/rtw_odm.h
new file mode 100644
index 000000000000..7af30f3b2489
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_odm.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_ODM_H__
+#define __RTW_ODM_H__
+
+#include <drv_types.h>
+#include "../hal/phydm_types.h"
+/*
+* This file provides utilities/wrappers for rtw driver to use ODM
+*/
+
+
+void rtw_odm_init_ic_type(_adapter *adapter);
+
+void rtw_odm_set_force_igi_lb(_adapter *adapter, u8 lb);
+u8 rtw_odm_get_force_igi_lb(_adapter *adapter);
+
+void rtw_odm_adaptivity_config_msg(void *sel, _adapter *adapter);
+
+bool rtw_odm_adaptivity_needed(_adapter *adapter);
+void rtw_odm_adaptivity_parm_msg(void *sel, _adapter *adapter);
+void rtw_odm_adaptivity_parm_set(_adapter *adapter, s8 th_l2h_ini, s8 th_edcca_hl_diff, s8 th_l2h_ini_mode2, s8 th_edcca_hl_diff_mode2, u8 edcca_enable);
+void rtw_odm_get_perpkt_rssi(void *sel, _adapter *adapter);
+void rtw_odm_acquirespinlock(_adapter *adapter,	enum rt_spinlock_type type);
+void rtw_odm_releasespinlock(_adapter *adapter,	enum rt_spinlock_type type);
+
+u8 rtw_odm_get_dfs_domain(_adapter *adapter);
+u8 rtw_odm_dfs_domain_unknown(_adapter *adapter);
+#ifdef CONFIG_DFS_MASTER
+void rtw_odm_radar_detect_reset(_adapter *adapter);
+void rtw_odm_radar_detect_disable(_adapter *adapter);
+void rtw_odm_radar_detect_enable(_adapter *adapter);
+bool rtw_odm_radar_detect(_adapter *adapter);
+#endif /* CONFIG_DFS_MASTER */
+
+void rtw_odm_parse_rx_phy_status_chinfo(union recv_frame *rframe, u8 *phys);
+
+#endif /* __RTW_ODM_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_p2p.h b/drivers/staging/rtl8188eu/include/rtw_p2p.h
new file mode 100644
index 000000000000..4b3c8d054eee
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_p2p.h
@@ -0,0 +1,152 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_P2P_H_
+#define __RTW_P2P_H_
+
+
+u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 *pssid, u8 ussidlen, u8 *pdev_raddr);
+u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
+u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+#ifdef CONFIG_WFD
+int rtw_init_wifi_display_info(_adapter *padapter);
+void rtw_wfd_enable(_adapter *adapter, bool on);
+void rtw_wfd_set_ctrl_port(_adapter *adapter, u16 port);
+void rtw_tdls_wfd_enable(_adapter *adapter, bool on);
+
+u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled);
+u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+
+u32 rtw_append_beacon_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_probe_req_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_probe_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_assoc_req_wfd_ie(_adapter *adapter, u8 *pbuf);
+u32 rtw_append_assoc_resp_wfd_ie(_adapter *adapter, u8 *pbuf);
+#endif /*CONFIG_WFD */
+
+void rtw_xframe_chk_wfd_ie(struct xmit_frame *xframe);
+
+u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
+u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
+u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe);
+u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+int process_p2p_cross_connect_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
+
+s32 p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType, u8 *buf);
+
+#ifdef CONFIG_P2P_PS
+void	process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
+void	p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state);
+u8	p2p_ps_wk_cmd(_adapter *padapter, u8 p2p_ps_state, u8 enqueue);
+#endif /* CONFIG_P2P_PS */
+
+#ifdef CONFIG_IOCTL_CFG80211
+void rtw_init_cfg80211_wifidirect_info(_adapter	*padapter);
+int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx);
+#endif /* CONFIG_IOCTL_CFG80211 */
+
+void reset_global_wifidirect_info(_adapter *padapter);
+void rtw_init_wifidirect_timers(_adapter *padapter);
+void rtw_init_wifidirect_addrs(_adapter *padapter, u8 *dev_addr, u8 *iface_addr);
+void init_wifidirect_info(_adapter *padapter, enum P2P_ROLE role);
+int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role);
+
+static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if (wdinfo->p2p_state != state) {
+		/* wdinfo->pre_p2p_state = wdinfo->p2p_state; */
+		wdinfo->p2p_state = state;
+	}
+}
+static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if (wdinfo->pre_p2p_state != state)
+		wdinfo->pre_p2p_state = state;
+}
+
+static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	if (wdinfo->role != role)
+		wdinfo->role = role;
+}
+static inline int _rtw_p2p_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->p2p_state;
+}
+static inline int _rtw_p2p_pre_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->pre_p2p_state;
+}
+static inline int _rtw_p2p_role(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->role;
+}
+static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	return wdinfo->p2p_state == state;
+}
+static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	return wdinfo->role == role;
+}
+
+#ifdef CONFIG_DBG_P2P
+void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+/* void dbg_rtw_p2p_restore_state(struct wifidirect_info *wdinfo, const char *caller, int line); */
+void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
+#define rtw_p2p_set_state(wdinfo, state) dbg_rtw_p2p_set_state(wdinfo, state, __func__, __LINE__)
+#define rtw_p2p_set_pre_state(wdinfo, state) dbg_rtw_p2p_set_pre_state(wdinfo, state, __func__, __LINE__)
+#define rtw_p2p_set_role(wdinfo, role) dbg_rtw_p2p_set_role(wdinfo, role, __func__, __LINE__)
+/* #define rtw_p2p_restore_state(wdinfo) dbg_rtw_p2p_restore_state(wdinfo, __func__, __LINE__) */
+#else /* CONFIG_DBG_P2P */
+#define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
+#define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
+#define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
+/* #define rtw_p2p_restore_state(wdinfo) _rtw_p2p_restore_state(wdinfo) */
+#endif /* CONFIG_DBG_P2P */
+
+#define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
+#define rtw_p2p_pre_state(wdinfo) _rtw_p2p_pre_state(wdinfo)
+#define rtw_p2p_role(wdinfo) _rtw_p2p_role(wdinfo)
+#define rtw_p2p_chk_state(wdinfo, state) _rtw_p2p_chk_state(wdinfo, state)
+#define rtw_p2p_chk_role(wdinfo, role) _rtw_p2p_chk_role(wdinfo, role)
+
+#define rtw_p2p_findphase_ex_set(wdinfo, value) \
+	(wdinfo)->find_phase_state_exchange_cnt = (value)
+
+#ifdef CONFIG_P2P
+/* is this find phase exchange for social channel scan? */
+#define rtw_p2p_findphase_ex_is_social(wdinfo)   \
+	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST
+
+/* should we need find phase exchange anymore? */
+#define rtw_p2p_findphase_ex_is_needed(wdinfo) \
+	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
+	 (wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE && \
+	 !(wdinfo)->rx_invitereq_info.scan_op_ch_only && \
+	 !(wdinfo)->p2p_info.scan_op_ch_only)
+#else
+#define rtw_p2p_findphase_ex_is_social(wdinfo) 0
+#define rtw_p2p_findphase_ex_is_needed(wdinfo) 0
+#endif /* CONFIG_P2P */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_pwrctrl.h b/drivers/staging/rtl8188eu/include/rtw_pwrctrl.h
new file mode 100644
index 000000000000..42300288715a
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_pwrctrl.h
@@ -0,0 +1,543 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_PWRCTRL_H_
+#define __RTW_PWRCTRL_H_
+
+
+#define FW_PWR0	0
+#define FW_PWR1	1
+#define FW_PWR2	2
+#define FW_PWR3	3
+
+
+#define HW_PWR0	7
+#define HW_PWR1	6
+#define HW_PWR2	2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+#ifdef CONFIG_BT_COEXIST
+#define BTCOEX_ALIVE	BIT(4)
+#endif /* CONFIG_BT_COEXIST */
+
+#ifdef CONFIG_WOWLAN
+#ifdef CONFIG_DEFAULT_PATTERNS_EN
+	#ifdef CONFIG_PLATFORM_ANDROID_INTEL_X86
+		/* TCP/ICMP/UDP multicast with specific IP addr */
+		#define DEFAULT_PATTERN_NUM 3
+	#else
+		/* TCP/ICMP */
+		#define DEFAULT_PATTERN_NUM 2
+	#endif
+#else
+	#define DEFAULT_PATTERN_NUM 0
+#endif /*CONFIG_DEFAULT_PATTERNS_EN*/
+
+#ifdef CONFIG_WOW_PATTERN_HW_CAM	/* Frame Mask Cam number for pattern match */
+#define MAX_WKFM_CAM_NUM	12
+#else
+#define MAX_WKFM_CAM_NUM	16
+#endif
+
+#define MAX_WKFM_SIZE	16 /* (16 bytes for WKFM bit mask, 16*8 = 128 bits) */
+#define MAX_WKFM_PATTERN_SIZE	128
+#define WKFMCAM_ADDR_NUM 6
+#define WKFMCAM_SIZE 24 /* each entry need 6*4 bytes */
+enum pattern_type {
+	PATTERN_BROADCAST = 0,
+	PATTERN_MULTICAST,
+	PATTERN_UNICAST,
+	PATTERN_VALID,
+	PATTERN_INVALID,
+};
+
+typedef struct rtl_priv_pattern {
+	int len;
+	char content[MAX_WKFM_PATTERN_SIZE];
+	char mask[MAX_WKFM_SIZE];
+} rtl_priv_pattern_t;
+
+#endif /* CONFIG_WOWLAN */
+
+enum Power_Mgnt {
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,	/* PS_MODE_SELF_DEFINED */
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM,
+};
+
+#ifdef CONFIG_PNO_SUPPORT
+#define MAX_PNO_LIST_COUNT 16
+#define MAX_SCAN_LIST_COUNT 14	/* 2.4G only */
+#define MAX_HIDDEN_AP 8		/* 8 hidden AP */
+#endif
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define PS_DPS				BIT(0)
+#define PS_LCLK				(PS_DPS)
+#define PS_RF_OFF			BIT(1)
+#define PS_ALL_ON			BIT(2)
+#define PS_ST_ACTIVE		BIT(3)
+
+#define PS_ISR_ENABLE		BIT(4)
+#define PS_IMR_ENABLE		BIT(5)
+#define PS_ACK				BIT(6)
+#define PS_TOGGLE			BIT(7)
+
+#define PS_STATE_MASK		(0x0F)
+#define PS_STATE_HW_MASK	(0x07)
+#define PS_SEQ_MASK			(0xc0)
+
+#define PS_STATE(x)		(PS_STATE_MASK & (x))
+#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define PS_SEQ(x)		(PS_SEQ_MASK & (x))
+
+#define PS_STATE_S0		(PS_DPS)
+#define PS_STATE_S1		(PS_LCLK)
+#define PS_STATE_S2		(PS_RF_OFF)
+#define PS_STATE_S3		(PS_ALL_ON)
+#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
+#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
+#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; /* the CPWM value */
+	unsigned short rsvd;
+};
+
+
+typedef _sema _pwrlock;
+
+
+__inline static void _init_pwrlock(_pwrlock *plock)
+{
+	sema_init(plock, 1);
+}
+
+__inline static void _free_pwrlock(_pwrlock *plock)
+{
+}
+
+
+__inline static void _enter_pwrlock(_pwrlock *plock)
+{
+	_rtw_down_sema(plock);
+}
+
+
+__inline static void _exit_pwrlock(_pwrlock *plock)
+{
+	up(plock);
+}
+
+#define LPS_DELAY_TIME	1*HZ /* 1 sec */
+
+#define EXE_PWR_NONE	0x01
+#define EXE_PWR_IPS		0x02
+#define EXE_PWR_LPS		0x04
+
+/* RF state. */
+typedef enum _rt_rf_power_state {
+	rf_on,		/* RF is on after RFSleep or RFOff */
+	rf_sleep,	/* 802.11 Power Save mode */
+	rf_off,		/* HW/SW Radio OFF or Inactive Power Save */
+	/* =====Add the new RF state above this line===== */
+	rf_max
+} rt_rf_power_state;
+
+/* RF Off Level for IPS or HW/SW radio off */
+#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	/* PCI ASPM */
+#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	/* PCI clock request */
+#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	/* PCI D3 mode */
+#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	/* NIC halt, re-initialize hw parameters */
+#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	/* FW free, re-download the FW */
+#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	/* FW in 32k */
+#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	/* Always enable ASPM and Clock Req in initialization. */
+#define	RT_RF_LPS_DISALBE_2R			BIT(30)	/* When LPS is on, disable 2R if no packet is received or transmittd. */
+#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	/* LPS with ASPM */
+
+#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? true : false)
+#define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
+#define	RT_SET_PS_LEVEL(ppsc, _PS_FLAG)		(ppsc->cur_ps_level |= _PS_FLAG)
+
+/* ASPM OSC Control bit, added by Roger, 2013.03.29. */
+#define	RT_PCI_ASPM_OSC_IGNORE		0	 /* PCI ASPM ignore OSC control in default */
+#define	RT_PCI_ASPM_OSC_ENABLE		BIT0 /* PCI ASPM controlled by OS according to ACPI Spec 5.0 */
+#define	RT_PCI_ASPM_OSC_DISABLE		BIT1 /* PCI ASPM controlled by driver or BIOS, i.e., force enable ASPM */
+
+
+enum _PS_BBRegBackup_ {
+	PSBBREG_RF0 = 0,
+	PSBBREG_RF1,
+	PSBBREG_RF2,
+	PSBBREG_AFE0,
+	PSBBREG_TOTALCNT
+};
+
+enum { /* for ips_mode */
+	IPS_NONE = 0,
+	IPS_NORMAL,
+	IPS_LEVEL_2,
+	IPS_NUM
+};
+
+/* Design for pwrctrl_priv.ips_deny, 32 bits for 32 reasons at most */
+typedef enum _PS_DENY_REASON {
+	PS_DENY_DRV_INITIAL = 0,
+	PS_DENY_SCAN,
+	PS_DENY_JOIN,
+	PS_DENY_DISCONNECT,
+	PS_DENY_SUSPEND,
+	PS_DENY_IOCTL,
+	PS_DENY_MGNT_TX,
+	PS_DENY_MONITOR_MODE,
+	PS_DENY_BEAMFORMING,		/* Beamforming */
+	PS_DENY_DRV_REMOVE = 30,
+	PS_DENY_OTHERS = 31
+} PS_DENY_REASON;
+
+#ifdef CONFIG_PNO_SUPPORT
+typedef struct pno_nlo_info {
+	u32 fast_scan_period;				/* Fast scan period */
+	u8	ssid_num;				/* number of entry */
+	u8	hidden_ssid_num;
+	u32	slow_scan_period;			/* slow scan period */
+	u32	fast_scan_iterations;			/* Fast scan iterations */
+	u8	ssid_length[MAX_PNO_LIST_COUNT];	/* SSID Length Array */
+	u8	ssid_cipher_info[MAX_PNO_LIST_COUNT];	/* Cipher information for security */
+	u8	ssid_channel_info[MAX_PNO_LIST_COUNT];	/* channel information */
+	u8	loc_probe_req[MAX_HIDDEN_AP];		/* loc_probeReq */
+} pno_nlo_info_t;
+
+typedef struct pno_ssid {
+	u32		SSID_len;
+	u8		SSID[32];
+} pno_ssid_t;
+
+typedef struct pno_ssid_list {
+	pno_ssid_t	node[MAX_PNO_LIST_COUNT];
+} pno_ssid_list_t;
+
+typedef struct pno_scan_channel_info {
+	u8	channel;
+	u8	tx_power;
+	u8	timeout;
+	u8	active;				/* set 1 means active scan, or pasivite scan. */
+} pno_scan_channel_info_t;
+
+typedef struct pno_scan_info {
+	u8	enableRFE;			/* Enable RFE */
+	u8	period_scan_time;		/* exclusive with fast_scan_period and slow_scan_period */
+	u8	periodScan;			/* exclusive with fast_scan_period and slow_scan_period */
+	u8	orig_80_offset;			/* original channel 80 offset */
+	u8	orig_40_offset;			/* original channel 40 offset */
+	u8	orig_bw;			/* original bandwidth */
+	u8	orig_ch;			/* original channel */
+	u8	channel_num;			/* number of channel */
+	u64	rfe_type;			/* rfe_type && 0x00000000000000ff */
+	pno_scan_channel_info_t ssid_channel_info[MAX_SCAN_LIST_COUNT];
+} pno_scan_info_t;
+#endif /* CONFIG_PNO_SUPPORT */
+
+#ifdef CONFIG_LPS_POFF
+/* Driver context for LPS 32K Close IO Power */
+typedef struct lps_poff_info {
+	bool	bEn;
+	u8	*pStaticFile;
+	u8	*pDynamicFile;
+	u32	ConfFileOffset;
+	u32	tx_bndy_static;
+	u32	tx_bndy_dynamic;
+	u16	ConfLenForPTK;
+	u16	ConfLenForGTK;
+	ATOMIC_T bEnterPOFF;
+	ATOMIC_T bTxBoundInProgress;
+	ATOMIC_T bSetPOFFParm;
+} lps_poff_info_t;
+#endif /*CONFIG_LPS_POFF*/
+
+struct aoac_report {
+	u8 iv[8];
+	u8 replay_counter_eapol_key[8];
+	u8 group_key[32];
+	u8 key_index;
+	u8 security_type;
+};
+
+struct pwrctrl_priv {
+	_adapter *padapter;
+	_pwrlock	lock;
+	_pwrlock	check_32k_lock;
+	volatile u8 rpwm; /* requested power state for fw */
+	volatile u8 cpwm; /* fw current power state. updated when 1. read from HCPWM 2. driver lowers power level */
+	volatile u8 tog; /* toggling */
+	volatile u8 cpwm_tog; /* toggling */
+
+	u8	pwr_mode;
+	u8	smart_ps;
+	u8	bcn_ant_mode;
+	u8	dtim;
+
+	u32	alives;
+	_workitem cpwm_event;
+	_workitem dma_event; /*for handle un-synchronized tx dma*/
+#ifdef CONFIG_LPS_RPWM_TIMER
+	u8 brpwmtimeout;
+	_workitem rpwmtimeoutwi;
+	struct timer_list pwr_rpwm_timer;
+#endif /* CONFIG_LPS_RPWM_TIMER */
+	u8	bpower_saving; /* for LPS/IPS */
+
+	u8	b_hw_radio_off;
+	u8	reg_rfoff;
+	u8	reg_pdnmode; /* powerdown mode */
+	u32	rfoff_reason;
+
+	/* RF OFF Level */
+	u32	cur_ps_level;
+	u32	reg_rfps_level;
+
+	uint	ips_enter_cnts;
+	uint	ips_leave_cnts;
+	uint	lps_enter_cnts;
+	uint	lps_leave_cnts;
+
+	u8	ips_mode;
+	u8	ips_org_mode;
+	u8	ips_mode_req; /* used to accept the mode setting request, will update to ipsmode later */
+	uint bips_processing;
+	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
+	u8 pre_ips_type;/* 0: default flow, 1: carddisbale flow */
+
+	/* ps_deny: if 0, power save is free to go; otherwise deny all kinds of power save. */
+	/* Use PS_DENY_REASON to decide reason. */
+	/* Don't access this variable directly without control function, */
+	/* and this variable should be protected by lock. */
+	u32 ps_deny;
+
+	u8 ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
+
+	u8 fw_psmode_iface_id;
+	u8	bLeisurePs;
+	u8	LpsIdleCount;
+	u8	power_mgnt;
+	u8	org_power_mgnt;
+	u8	bFwCurrentInPSMode;
+	u32	DelayLPSLastTimeStamp;
+	s32		pnp_current_pwr_state;
+	u8		pnp_bstop_trx;
+
+
+	u8		bInternalAutoSuspend;
+	u8		bInSuspend;
+#ifdef CONFIG_BT_COEXIST
+	u8		bAutoResume;
+	u8		autopm_cnt;
+#endif
+	u8		bSupportRemoteWakeup;
+	u8		wowlan_wake_reason;
+	u8		wowlan_last_wake_reason;
+	u8		wowlan_ap_mode;
+	u8		wowlan_mode;
+	u8		wowlan_p2p_mode;
+	u8		wowlan_pno_enable;
+#ifdef CONFIG_GPIO_WAKEUP
+	u8		is_high_active;
+#endif /* CONFIG_GPIO_WAKEUP */
+#ifdef CONFIG_WOWLAN
+	u8		wowlan_txpause_status;
+	u8		wowlan_pattern_idx;
+	u8		wowlan_in_resume;
+	u64		wowlan_fw_iv;
+	struct rtl_priv_pattern	patterns[MAX_WKFM_CAM_NUM];
+#ifdef CONFIG_PNO_SUPPORT
+	u8		pno_inited;
+	pno_nlo_info_t	*pnlo_info;
+	pno_scan_info_t	*pscan_info;
+	pno_ssid_list_t	*pno_ssid_list;
+#endif /* CONFIG_PNO_SUPPORT */
+#ifdef CONFIG_WOW_PATTERN_HW_CAM
+	_mutex	wowlan_pattern_cam_mutex;
+#endif
+	u8		wowlan_aoac_rpt_loc;
+	struct aoac_report wowlan_aoac_rpt;
+#endif /* CONFIG_WOWLAN */
+	struct timer_list pwr_state_check_timer;
+	int		pwr_state_check_interval;
+	u8		pwr_state_check_cnts;
+
+	int		ps_flag; /* used by autosuspend */
+
+	rt_rf_power_state	rf_pwrstate;/* cur power state, only for IPS */
+	/* rt_rf_power_state	current_rfpwrstate; */
+	rt_rf_power_state	change_rfpwrstate;
+
+	u8		bHWPowerdown; /* power down mode selection. 0:radio off, 1:power down */
+	u8		bHWPwrPindetect; /* come from registrypriv.hwpwrp_detect. enable power down function. 0:disable, 1:enable */
+	u8		bkeepfwalive;
+	u8		brfoffbyhw;
+	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	struct workqueue_struct *rtw_workqueue;
+	_workitem resume_work;
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+	u8 do_late_resume;
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+#ifdef CONFIG_ANDROID_POWER
+	android_early_suspend_t early_suspend;
+	u8 do_late_resume;
+#endif
+
+#ifdef CONFIG_INTEL_PROXIM
+	u8	stored_power_mgnt;
+#endif
+
+#ifdef CONFIG_LPS_POFF
+	lps_poff_info_t	*plps_poff_info;
+#endif
+
+#ifdef CONFIG_LPS_PG
+	u8 lpspg_rsvd_page_locate;
+	u8 blpspg_info_up;
+#endif
+	u8 current_lps_hw_port_id;
+};
+
+#define rtw_get_ips_mode_req(pwrctl) \
+	(pwrctl)->ips_mode_req
+
+#define rtw_ips_mode_req(pwrctl, ips_mode) \
+	(pwrctl)->ips_mode_req = (ips_mode)
+
+#define RTW_PWR_STATE_CHK_INTERVAL 2000
+
+#define _rtw_set_pwr_state_check_timer(pwrctl, ms) \
+	do { \
+		/*RTW_INFO("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __func__, (pwrctl), (ms));*/ \
+		_set_timer(&(pwrctl)->pwr_state_check_timer, (ms)); \
+	} while (0)
+
+#define rtw_set_pwr_state_check_timer(pwrctl) \
+	_rtw_set_pwr_state_check_timer((pwrctl), (pwrctl)->pwr_state_check_interval)
+
+extern void rtw_init_pwrctrl_priv(_adapter *adapter);
+extern void rtw_free_pwrctrl_priv(_adapter *adapter);
+
+#ifdef CONFIG_LPS_LCLK
+s32 rtw_register_task_alive(PADAPTER, u32 task);
+void rtw_unregister_task_alive(PADAPTER, u32 task);
+extern s32 rtw_register_tx_alive(PADAPTER padapter);
+extern void rtw_unregister_tx_alive(PADAPTER padapter);
+extern s32 rtw_register_rx_alive(PADAPTER padapter);
+extern void rtw_unregister_rx_alive(PADAPTER padapter);
+extern s32 rtw_register_cmd_alive(PADAPTER padapter);
+extern void rtw_unregister_cmd_alive(PADAPTER padapter);
+extern s32 rtw_register_evt_alive(PADAPTER padapter);
+extern void rtw_unregister_evt_alive(PADAPTER padapter);
+extern void cpwm_int_hdl(PADAPTER padapter, struct reportpwrstate_parm *preportpwrstate);
+extern void LPS_Leave_check(PADAPTER padapter);
+#endif
+
+extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
+extern void LeaveAllPowerSaveModeDirect(PADAPTER Adapter);
+#ifdef CONFIG_IPS
+void _ips_enter(_adapter *padapter);
+void ips_enter(_adapter *padapter);
+int _ips_leave(_adapter *padapter);
+int ips_leave(_adapter *padapter);
+#endif
+
+void rtw_ps_processor(_adapter *padapter);
+
+#ifdef CONFIG_AUTOSUSPEND
+int autoresume_enter(_adapter *padapter);
+#endif
+#ifdef SUPPORT_HW_RFOFF_DETECTED
+rt_rf_power_state RfOnOffDetect(PADAPTER pAdapter);
+#endif
+
+
+int rtw_fw_ps_state(PADAPTER padapter);
+
+#ifdef CONFIG_LPS
+s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
+void LPS_Enter(PADAPTER padapter, const char *msg);
+void LPS_Leave(PADAPTER padapter, const char *msg);
+void traffic_check_for_leave_lps(PADAPTER padapter, u8 tx, u32 tx_packets);
+void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode, const char *msg);
+void rtw_set_fw_in_ips_mode(PADAPTER padapter, u8 enable);
+void rtw_set_rpwm(_adapter *padapter, u8 val8);
+#endif
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
+bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv);
+void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable);
+void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv);
+void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv);
+#else
+#define rtw_is_earlysuspend_registered(pwrpriv) false
+#define rtw_is_do_late_resume(pwrpriv) false
+#define rtw_set_do_late_resume(pwrpriv, enable) do {} while (0)
+#define rtw_register_early_suspend(pwrpriv) do {} while (0)
+#define rtw_unregister_early_suspend(pwrpriv) do {} while (0)
+#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
+
+u8 rtw_interface_ps_func(_adapter *padapter, HAL_INTF_PS_FUNC efunc_id, u8 *val);
+void rtw_set_ips_deny(_adapter *padapter, u32 ms);
+int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller);
+#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __func__)
+#define rtw_pwr_wakeup_ex(adapter, ips_deffer_ms) _rtw_pwr_wakeup(adapter, ips_deffer_ms, __func__)
+int rtw_pm_set_ips(_adapter *padapter, u8 mode);
+int rtw_pm_set_lps(_adapter *padapter, u8 mode);
+
+void rtw_ps_deny(PADAPTER padapter, PS_DENY_REASON reason);
+void rtw_ps_deny_cancel(PADAPTER padapter, PS_DENY_REASON reason);
+u32 rtw_ps_deny_get(PADAPTER padapter);
+
+#if defined(CONFIG_WOWLAN)
+void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
+void rtw_get_sec_iv(PADAPTER padapter, u8 *pcur_dot11txpn, u8 *StaAddr);
+bool rtw_check_pattern_valid(u8 *input, u8 len);
+bool rtw_wowlan_parser_pattern_cmd(u8 *input, char *pattern,
+				int *pattern_len, char *bit_mask);
+void rtw_wow_pattern_sw_reset(_adapter *adapter);
+u8 rtw_set_default_pattern(_adapter *adapter);
+void rtw_wow_pattern_sw_dump(_adapter *adapter);
+#endif /* CONFIG_WOWLAN */
+#endif /* __RTL871X_PWRCTRL_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_qos.h b/drivers/staging/rtl8188eu/include/rtw_qos.h
new file mode 100644
index 000000000000..b52d51545279
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_qos.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+
+
+#ifndef _RTW_QOS_H_
+#define _RTW_QOS_H_
+
+
+
+struct	qos_priv	{
+
+	unsigned int	  qos_option;	/* bit mask option: u-apsd, s-apsd, ts, block ack...		 */
+
+};
+
+
+#endif /* _RTL871X_QOS_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_recv.h b/drivers/staging/rtl8188eu/include/rtw_recv.h
new file mode 100644
index 000000000000..74f3df4e2c6d
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_recv.h
@@ -0,0 +1,690 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_RECV_H_
+#define _RTW_RECV_H_
+
+#ifdef CONFIG_SINGLE_RECV_BUF
+	#define NR_RECVBUFF (1)
+#else
+		#define NR_RECVBUFF (8)
+#endif /* CONFIG_SINGLE_RECV_BUF */
+#ifdef CONFIG_PREALLOC_RX_SKB_BUFFER
+	#define NR_PREALLOC_RECV_SKB (rtw_rtkm_get_nr_recv_skb()>>1)
+#else /*!CONFIG_PREALLOC_RX_SKB_BUFFER */
+	#define NR_PREALLOC_RECV_SKB 8
+#endif /* CONFIG_PREALLOC_RX_SKB_BUFFER */
+
+#ifdef CONFIG_RTW_NAPI
+	#define RTL_NAPI_WEIGHT (32)
+#endif
+
+#define NR_RECVFRAME 256
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define DRVINFO_SZ	4 /* unit is 8bytes */
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+#define MAX_CONTINUAL_NORXPACKET_COUNT 4    /*  In MAX_CONTINUAL_NORXPACKET_COUNT*2 sec  , no rx traffict would issue DELBA*/
+
+#define PHY_RSSI_SLID_WIN_MAX				100
+#define PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define RX_MPDU_QUEUE				0
+#define RX_CMD_QUEUE				1
+#define RX_MAX_QUEUE				2
+
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
+static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; /* Datagram Delivery Protocol */
+
+static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8 oui_rfc1042[] = {0x00, 0x00, 0x00};
+
+#define MAX_SUBFRAME_COUNT	64
+static u8 rtw_rfc1042_header[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 rtw_bridge_tunnel_header[] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+
+/* for Rx reordering buffer control */
+struct recv_reorder_ctrl {
+	_adapter	*padapter;
+	u8 enable;
+	u16 indicate_seq;/* =wstart_b, init_value=0xffff */
+	u16 wend_b;
+	u8 wsize_b;
+	u8 ampdu_size;
+	_queue pending_recvframe_queue;
+	struct timer_list reordering_ctrl_timer;
+	u8 bReorderWaiting;
+};
+
+struct	stainfo_rxcache	{
+	u16	tid_rxseq[16];
+	u8 iv[16][8];
+};
+
+struct smooth_rssi_data {
+	u32	elements[100];	/* array to store values */
+	u32	index;			/* index to current array to store */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements */
+};
+
+struct signal_stat {
+	u8	update_req;		/* used to indicate */
+	u8	avg_val;		/* avg of valid elements */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements	 */
+};
+
+struct phy_info {
+	u8			RxPWDBAll;
+	u8			SignalQuality;				/* in 0-100 index. */
+	s8			RxMIMOSignalQuality[4];		/* per-path's EVM */
+	u8			RxMIMOEVMdbm[4];			/* per-path's EVM dbm */
+	u8			RxMIMOSignalStrength[4];	/* in 0~100 index */
+	s16			Cfo_short[4];				/* per-path's Cfo_short */
+	s16			Cfo_tail[4];					/* per-path's Cfo_tail */
+	s8			RxPower;					/* in dBm Translate from PWdB */
+	s8			RecvSignalPower;			/* Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures. */
+	u8			BTRxRSSIPercentage;
+	u8			SignalStrength;				/* in 0-100 index. */
+	s8			RxPwr[4];					/* per-path's pwdb */
+	s8			RxSNR[4];
+	u8			BandWidth;
+	u8			btCoexPwrAdjust;
+};
+
+struct rx_raw_rssi {
+	u8 data_rate;
+	u8 pwdball;
+	s8 pwr_all;
+
+	u8 mimo_signal_strength[4];/* in 0~100 index */
+	u8 mimo_signal_quality[4];
+
+	s8 ofdm_pwr[4];
+	u8 ofdm_snr[4];
+};
+
+struct rx_pkt_attrib	{
+	__le16	pkt_len;
+	u8	physt;
+	u8	drvinfo_sz;
+	u8	shift_sz;
+	u8	hdrlen; /* the WLAN Header Len */
+	u8	to_fr_ds;
+	u8	amsdu;
+	u8	qos;
+	u8	priority;
+	u8	pw_save;
+	u8	mdata;
+	__le16	seq_num;
+	u8	frag_num;
+	u8	mfrag;
+	u8	order;
+	u8	privacy; /* in frame_ctrl field */
+	u8	bdecrypted;
+	u8	encrypt; /* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
+	u8	iv_len;
+	u8	icv_len;
+	u8	crc_err;
+	u8	icv_err;
+
+	__le16	eth_type;
+
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	bssid[ETH_ALEN];
+
+	u8	ack_policy;
+
+/* #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX */
+	u8	tcpchk_valid; /* 0: invalid, 1: valid */
+	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
+	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
+/* #endif */
+	u8	key_index;
+
+	u8	data_rate;
+	u8 ch; /* RX channel */
+	u8	bw;
+	u8	stbc;
+	u8	ldpc;
+	u8	sgi;
+	u8	pkt_rpt_type;
+	__le32 tsfl;
+	__le32	MacIDValidEntry[2];	/* 64 bits present 64 entry. */
+
+	struct phy_info phy_info;
+};
+
+
+/* These definition is used for Rx packet reordering. */
+#define SN_LESS(a, b)		(((a-b) & 0x800) != 0)
+#define SN_EQUAL(a, b)	(a == b)
+/* #define REORDER_WIN_SIZE	128 */
+/* #define REORDER_ENTRY_NUM	128 */
+#define REORDER_WAIT_TIME	(50) /* (ms) */
+
+#define RECVBUFF_ALIGN_SZ 8
+
+#ifdef CONFIG_TRX_BD_ARCH
+	#define RX_WIFI_INFO_SIZE	24
+#endif
+
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+
+#ifdef CONFIG_TRX_BD_ARCH
+struct rx_buf_desc {
+	/* RX has exactly one segment */
+#ifdef CONFIG_64BIT_DMA
+	unsigned int dword[4];
+#else
+	unsigned int dword[2];
+#endif
+};
+
+struct recv_stat {
+	unsigned int rxdw[8];
+};
+#else
+struct recv_stat {
+	__le32 rxdw0;
+	__le32 rxdw1;
+	__le32 rxdw2;
+	__le32 rxdw3;
+
+#ifndef BUF_DESC_ARCH
+	__le32 rxdw4;
+
+	__le32 rxdw5;
+
+#endif /* if BUF_DESC_ARCH is defined, rx_buf_desc occupy 4 double words */
+};
+#endif
+
+#define EOR BIT(30)
+
+/*
+accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv {
+	_lock	lock;
+
+#ifdef CONFIG_RECV_THREAD_MODE
+	_sema	recv_sema;
+	_sema	terminate_recvthread_sema;
+#endif
+
+	/* _queue	blk_strms[MAX_RX_NUMBLKS];    */ /* keeping the block ack frame until return ack */
+	_queue	free_recv_queue;
+	_queue	recv_pending_queue;
+	_queue	uc_swdec_pending_queue;
+
+
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf;
+
+	uint free_recvframe_cnt;
+
+	_adapter	*adapter;
+
+	u32 is_any_non_be_pkts;
+
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+	/* u8 *pallocated_urb_buf; */
+	_sema allrxreturnevt;
+	uint	ff_hwaddr;
+	ATOMIC_T	rx_pending_cnt;
+
+#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
+	PURB	int_in_urb;
+
+	u8	*int_in_buf;
+#endif /* CONFIG_USB_INTERRUPT_IN_PIPE */
+
+	struct tasklet_struct irq_prepare_beacon_tasklet;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+#ifdef CONFIG_RTW_NAPI
+		struct sk_buff_head rx_napi_skb_queue;
+#endif 
+#ifdef CONFIG_RX_INDICATE_QUEUE
+	struct task rx_indicate_tasklet;
+	struct ifqueue rx_indicate_queue;
+#endif /* CONFIG_RX_INDICATE_QUEUE */
+
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    /* 4 alignment */
+	_queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+
+	_queue	recv_buf_pending_queue;
+
+	/* For display the phy informatiom */
+	u8 is_signal_dbg;	/* for debug */
+	u8 signal_strength_dbg;	/* for debug */
+
+	u8 signal_strength;
+	u8 signal_qual;
+	s8 rssi;	/* translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength); */
+	struct rx_raw_rssi raw_rssi_info;
+	/* s8 rxpwdb;	 */
+	s16 noise;
+	/* int RxSNRdB[2]; */
+	/* s8 RxRssi[2]; */
+	/* int FalseAlmCnt_all; */
+
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct timer_list signal_stat_timer;
+	u32 signal_stat_sampling_interval;
+	/* u32 signal_stat_converging_constant; */
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+	u16 sink_udpport, pre_rtp_rxseq, cur_rtp_rxseq;
+
+	bool store_law_data_flag;
+};
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+
+struct sta_recv_priv {
+
+	_lock	lock;
+	sint	option;
+
+	/* _queue	blk_strms[MAX_RX_NUMBLKS]; */
+	_queue defrag_q;	 /* keeping the fragment frame until defrag */
+
+	struct	stainfo_rxcache rxcache;
+
+	/* uint	sta_rx_bytes; */
+	/* uint	sta_rx_pkts; */
+	/* uint	sta_rx_fail; */
+
+};
+
+
+struct recv_buf {
+	_list list;
+
+	_lock recvbuf_lock;
+
+	u32	ref_cnt;
+
+	PADAPTER adapter;
+
+	u8	*pbuf;
+	u8	*pallocated_buf;
+
+	u32	len;
+	u8	*phead;
+	u8	*pdata;
+	u8	*ptail;
+	u8	*pend;
+
+	PURB	purb;
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+	u32 alloc_sz;
+
+	u8  irp_pending;
+	int  transfer_len;
+
+	_pkt	*pskb;
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+
+			payload
+
+		tail  ----->
+
+
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame_hdr {
+	_list	list;
+#ifndef CONFIG_BSD_RX_USE_MBUF
+	struct sk_buff	*pkt;
+	struct sk_buff	*pkt_newalloc;
+#else /* CONFIG_BSD_RX_USE_MBUF */
+	_pkt	*pkt;
+	_pkt *pkt_newalloc;
+#endif /* CONFIG_BSD_RX_USE_MBUF */
+
+	_adapter  *adapter;
+
+	u8 fragcnt;
+
+	int frame_tag;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+
+	void *precvbuf;
+
+
+	/*  */
+	struct sta_info *psta;
+
+	/* for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl *preorder_ctrl;
+
+#ifdef CONFIG_WAPI_SUPPORT
+	u8 UserPriority;
+	u8 WapiTempPN[16];
+	u8 WapiSrcAddr[6];
+	u8 bWapiCheckPNInDecrypt;
+	u8 bIsWaiPacket;
+#endif
+
+};
+
+
+union recv_frame {
+
+	union {
+		_list list;
+		struct recv_frame_hdr hdr;
+		uint mem[RECVFRAME_HDR_ALIGN >> 2];
+	} u;
+
+	/* uint mem[MAX_RXSZ>>2]; */
+
+};
+
+bool rtw_rframe_del_wfd_ie(union recv_frame *rframe, u8 ies_offset);
+
+typedef enum _RX_PACKET_TYPE {
+	NORMAL_RX,/* Normal rx packet */
+	TX_REPORT1,/* CCX */
+	TX_REPORT2,/* TX RPT */
+	HIS_REPORT,/* USB HISR RPT */
+	C2H_PACKET
+} RX_PACKET_TYPE, *PRX_PACKET_TYPE;
+
+extern union recv_frame *_rtw_alloc_recvframe(_queue *pfree_recv_queue);   /* get a free recv_frame from pfree_recv_queue */
+extern union recv_frame *rtw_alloc_recvframe(_queue *pfree_recv_queue);   /* get a free recv_frame from pfree_recv_queue */
+extern void rtw_init_recvframe(union recv_frame *precvframe , struct recv_priv *precvpriv);
+extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);
+
+#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
+extern int _rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+extern int rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue);
+
+extern void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);
+u32 rtw_free_uc_swdec_pending_queue(_adapter *adapter);
+
+sint rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, _queue *queue);
+sint rtw_enqueue_recvbuf(struct recv_buf *precvbuf, _queue *queue);
+struct recv_buf *rtw_dequeue_recvbuf(_queue *queue);
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext);
+
+void rx_query_phy_status(union recv_frame *rframe, u8 *phy_stat);
+int rtw_inc_and_chk_continual_no_rx_packet(struct sta_info *sta, int tid_index);
+void rtw_reset_continual_no_rx_packet(struct sta_info *sta, int tid_index);
+
+#ifdef CONFIG_RECV_THREAD_MODE
+thread_return rtw_recv_thread(thread_context context);
+#endif
+
+__inline static u8 *get_rxmem(union recv_frame *precvframe)
+{
+	/* always return rx_head... */
+	if (precvframe == NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_head;
+}
+
+__inline static u8 *get_rx_status(union recv_frame *precvframe)
+{
+
+	return get_rxmem(precvframe);
+
+}
+
+__inline static u8 *get_recvframe_data(union recv_frame *precvframe)
+{
+
+	/* alwasy return rx_data */
+	if (precvframe == NULL)
+		return NULL;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+__inline static u8 *recvframe_push(union recv_frame *precvframe, sint sz)
+{
+	/* append data before rx_data */
+
+	/* add data to the start of recv_frame
+	*
+	*      This function extends the used data area of the recv_frame at the buffer
+	*      start. rx_data must be still larger than rx_head, after pushing.
+	*/
+
+	if (precvframe == NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data -= sz ;
+	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head) {
+		precvframe->u.hdr.rx_data += sz ;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len += sz;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+
+__inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
+{
+	/* rx_data += sz; move rx_data sz bytes  hereafter */
+
+	/* used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller */
+
+
+	if (precvframe == NULL)
+		return NULL;
+
+
+	precvframe->u.hdr.rx_data += sz;
+
+	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
+		precvframe->u.hdr.rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -= sz;
+
+	return precvframe->u.hdr.rx_data;
+
+}
+
+__inline static u8 *recvframe_put(union recv_frame *precvframe, __le16 le_sz)
+{
+	s16 sz = le16_to_cpu(le_sz);
+	/* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
+	/* after putting, rx_tail must be still larger than rx_end. */
+	unsigned char *prev_rx_tail;
+
+	if (!precvframe)
+		return NULL;
+
+	prev_rx_tail = precvframe->u.hdr.rx_tail;
+
+	precvframe->u.hdr.rx_tail += sz;
+
+	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
+		precvframe->u.hdr.rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len += sz;
+
+	return precvframe->u.hdr.rx_tail;
+}
+
+
+
+__inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
+{
+	/* rmv data from rx_tail (by yitsen) */
+
+	/* used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller */
+	/* after pulling, rx_end must be still larger than rx_data. */
+
+	if (precvframe == NULL)
+		return NULL;
+
+	precvframe->u.hdr.rx_tail -= sz;
+
+	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {
+		precvframe->u.hdr.rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->u.hdr.len -= sz;
+
+	return precvframe->u.hdr.rx_tail;
+
+}
+
+
+
+__inline static _buffer *get_rxbuf_desc(union recv_frame *precvframe)
+{
+	_buffer *buf_desc;
+
+	if (precvframe == NULL)
+		return NULL;
+
+	return buf_desc;
+}
+
+
+__inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
+{
+	/* due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame */
+	/* from any given member of recv_frame. */
+	/* rxmem indicates the any member/address in recv_frame */
+
+	return (union recv_frame *)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
+
+}
+
+__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
+{
+
+	u8 *buf_star;
+	union recv_frame *precv_frame;
+	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);
+
+	return precv_frame;
+}
+
+__inline static u8 *pkt_to_recvmem(_pkt *pkt)
+{
+	/* return the rx_head */
+
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_head;
+
+}
+
+__inline static u8 *pkt_to_recvdata(_pkt *pkt)
+{
+	/* return the rx_data */
+
+	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
+
+	return	precv_frame->u.hdr.rx_data;
+
+}
+
+
+__inline static sint get_recvframe_len(union recv_frame *precvframe)
+{
+	return precvframe->u.hdr.len;
+}
+
+
+__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
+{
+	s32	SignalPower; /* in dBm. */
+
+#ifdef CONFIG_SIGNAL_SCALE_MAPPING
+	/* Translate to dBm (x=0.5y-95). */
+	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1);
+	SignalPower -= 95;
+#else
+	/* Translate to dBm (x=y-100) */
+	SignalPower = SignalStrengthIndex - 100;
+#endif
+
+	return SignalPower;
+}
+
+
+struct sta_info;
+
+extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+
+extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
+
+s32 pre_recv_entry(union recv_frame *precvframe, u8 *pphy_status);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_rf.h b/drivers/staging/rtl8188eu/include/rtw_rf.h
new file mode 100644
index 000000000000..8e7ad35466c9
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_rf.h
@@ -0,0 +1,270 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef	__RTW_RF_H_
+#define __RTW_RF_H_
+
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#define NumRates	(13)
+
+/* slot time for 11g */
+#define SHORT_SLOT_TIME					9
+#define NON_SHORT_SLOT_TIME				20
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+/*
+ * We now define the following channels as the max channels in each channel plan.
+ * 2G, total 14 chnls
+ * {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
+ * 5G, total 25 chnls
+ * {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165}
+ */
+#define	MAX_CHANNEL_NUM_2G	14
+#define	MAX_CHANNEL_NUM_5G	25
+#define	MAX_CHANNEL_NUM		(MAX_CHANNEL_NUM_2G + MAX_CHANNEL_NUM_5G)
+
+#define CENTER_CH_2G_40M_NUM	9
+#define CENTER_CH_2G_NUM		14
+#define CENTER_CH_5G_20M_NUM	28	/* 20M center channels */
+#define CENTER_CH_5G_40M_NUM	14	/* 40M center channels */
+#define CENTER_CH_5G_80M_NUM	7	/* 80M center channels */
+#define CENTER_CH_5G_160M_NUM	3	/* 160M center channels */
+#define CENTER_CH_5G_ALL_NUM	(CENTER_CH_5G_20M_NUM + CENTER_CH_5G_40M_NUM + CENTER_CH_5G_80M_NUM)
+
+extern u8 center_ch_2g[CENTER_CH_2G_NUM];
+extern u8 center_ch_2g_40m[CENTER_CH_2G_40M_NUM];
+
+u8 center_chs_2g_num(u8 bw);
+u8 center_chs_2g(u8 bw, u8 id);
+
+extern u8 center_ch_5g_20m[CENTER_CH_5G_20M_NUM];
+extern u8 center_ch_5g_40m[CENTER_CH_5G_40M_NUM];
+extern u8 center_ch_5g_20m_40m[CENTER_CH_5G_20M_NUM + CENTER_CH_5G_40M_NUM];
+extern u8 center_ch_5g_80m[CENTER_CH_5G_80M_NUM];
+extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];
+
+u8 center_chs_5g_num(u8 bw);
+u8 center_chs_5g(u8 bw, u8 id);
+
+u8 rtw_get_scch_by_cch_offset(u8 cch, u8 bw, u8 offset);
+
+u8 rtw_get_op_chs_by_cch_bw(u8 cch, u8 bw, u8 **op_chs, u8 *op_ch_num);
+
+u8 rtw_get_ch_group(u8 ch, u8 *group, u8 *cck_group);
+
+/* #define NUM_REGULATORYS	21 */
+#define NUM_REGULATORYS	1
+
+/* Country codes */
+#define USA							0x555320
+#define EUROPE						0x1 /* temp, should be provided later	 */
+#define JAPAN						0x2 /* temp, should be provided later	 */
+
+struct	regulatory_class {
+	u32	starting_freq;					/* MHz, */
+	u8	channel_set[MAX_CHANNEL_NUM];
+	u8	channel_cck_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	channel_ofdm_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	txpower_limit;  				/* dbm */
+	u8	channel_spacing;				/* MHz */
+	u8	modem;
+};
+
+typedef enum _CAPABILITY {
+	cESS			= 0x0001,
+	cIBSS			= 0x0002,
+	cPollable		= 0x0004,
+	cPollReq			= 0x0008,
+	cPrivacy		= 0x0010,
+	cShortPreamble	= 0x0020,
+	cPBCC			= 0x0040,
+	cChannelAgility	= 0x0080,
+	cSpectrumMgnt	= 0x0100,
+	cQos			= 0x0200,	/* For HCCA, use with CF-Pollable and CF-PollReq */
+	cShortSlotTime	= 0x0400,
+	cAPSD			= 0x0800,
+	cRM				= 0x1000,	/* RRM (Radio Request Measurement) */
+	cDSSS_OFDM	= 0x2000,
+	cDelayedBA		= 0x4000,
+	cImmediateBA	= 0x8000,
+} CAPABILITY, *PCAPABILITY;
+
+enum	_REG_PREAMBLE_MODE {
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_ {
+	RTL8712_RFCONFIG_1T = 0x10,
+	RTL8712_RFCONFIG_2T = 0x20,
+	RTL8712_RFCONFIG_1R = 0x01,
+	RTL8712_RFCONFIG_2R = 0x02,
+	RTL8712_RFCONFIG_1T1R = 0x11,
+	RTL8712_RFCONFIG_1T2R = 0x12,
+	RTL8712_RFCONFIG_TURBO = 0x92,
+	RTL8712_RFCONFIG_2T2R = 0x22
+};
+
+typedef enum _RF_PATH {
+	RF_PATH_A = 0,
+	RF_PATH_B = 1,
+	RF_PATH_C = 2,
+	RF_PATH_D = 3,
+} RF_PATH, *PRF_PATH;
+
+#define rf_path_char(path) (((path) >= RF_PATH_MAX) ? 'X' : 'A' + (path))
+
+/* Bandwidth Offset */
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+
+typedef enum _BAND_TYPE {
+	BAND_ON_2_4G = 0,
+	BAND_ON_5G = 1,
+	BAND_ON_BOTH = 2,
+	BAND_MAX = 3,
+} BAND_TYPE, *PBAND_TYPE;
+
+extern const char *const _band_str[];
+#define band_str(band) (((band) >= BAND_MAX) ? _band_str[BAND_MAX] : _band_str[(band)])
+
+extern const u8 _band_to_band_cap[];
+#define band_to_band_cap(band) (((band) >= BAND_MAX) ? _band_to_band_cap[BAND_MAX] : _band_to_band_cap[(band)])
+
+/* Represent Channel Width in HT Capabilities
+ *   */
+typedef enum _CHANNEL_WIDTH {
+	CHANNEL_WIDTH_20 = 0,
+	CHANNEL_WIDTH_40 = 1,
+	CHANNEL_WIDTH_80 = 2,
+	CHANNEL_WIDTH_160 = 3,
+	CHANNEL_WIDTH_80_80 = 4,
+	CHANNEL_WIDTH_MAX = 5,
+} CHANNEL_WIDTH, *PCHANNEL_WIDTH;
+
+extern const char *const _ch_width_str[];
+#define ch_width_str(bw) (((bw) >= CHANNEL_WIDTH_MAX) ? _ch_width_str[CHANNEL_WIDTH_MAX] : _ch_width_str[(bw)])
+
+extern const u8 _ch_width_to_bw_cap[];
+#define ch_width_to_bw_cap(bw) (((bw) >= CHANNEL_WIDTH_MAX) ? _ch_width_to_bw_cap[CHANNEL_WIDTH_MAX] : _ch_width_to_bw_cap[(bw)])
+
+/*
+ * Represent Extention Channel Offset in HT Capabilities
+ * This is available only in 40Mhz mode.
+ *   */
+typedef enum _EXTCHNL_OFFSET {
+	EXTCHNL_OFFSET_NO_EXT = 0,
+	EXTCHNL_OFFSET_UPPER = 1,
+	EXTCHNL_OFFSET_NO_DEF = 2,
+	EXTCHNL_OFFSET_LOWER = 3,
+} EXTCHNL_OFFSET, *PEXTCHNL_OFFSET;
+
+typedef enum _VHT_DATA_SC {
+	VHT_DATA_SC_DONOT_CARE = 0,
+	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
+	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
+	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
+	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
+	VHT_DATA_SC_20_RECV1 = 5,
+	VHT_DATA_SC_20_RECV2 = 6,
+	VHT_DATA_SC_20_RECV3 = 7,
+	VHT_DATA_SC_20_RECV4 = 8,
+	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
+	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
+} VHT_DATA_SC, *PVHT_DATA_SC_E;
+
+typedef enum _PROTECTION_MODE {
+	PROTECTION_MODE_AUTO = 0,
+	PROTECTION_MODE_FORCE_ENABLE = 1,
+	PROTECTION_MODE_FORCE_DISABLE = 2,
+} PROTECTION_MODE, *PPROTECTION_MODE;
+
+typedef	enum _RT_RF_TYPE_DEFINITION {
+	RF_1T2R = 0,
+	RF_2T4R = 1,
+	RF_2T2R = 2,
+	RF_1T1R = 3,
+	RF_2T2R_GREEN = 4,
+	RF_2T3R = 5,
+	RF_3T3R = 6,
+	RF_3T4R	= 7,
+	RF_4T4R	= 8,
+
+	RF_TYPE_AUTO,
+} RT_RF_TYPE_DEF_E;
+
+#define RF_TYPE_VALID(rf_type) (rf_type < RF_TYPE_AUTO)
+
+extern const u8 _rf_type_to_rf_tx_cnt[];
+#define rf_type_to_rf_tx_cnt(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rf_tx_cnt[rf_type] : 0)
+
+extern const u8 _rf_type_to_rf_rx_cnt[];
+#define rf_type_to_rf_rx_cnt(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rf_rx_cnt[rf_type] : 0)
+
+int rtw_ch2freq(int chan);
+int rtw_freq2ch(int freq);
+bool rtw_chbw_to_freq_range(u8 ch, u8 bw, u8 offset, u32 *hi, u32 *lo);
+
+#define RTW_MODULE_RTL8821AE_HMC_M2		BIT0 /* RTL8821AE(HMC + M.2) */
+#define RTW_MODULE_RTL8821AU			BIT1 /* RTL8821AU */
+#define RTW_MODULE_RTL8812AENF_NGFF		BIT2 /* RTL8812AENF(8812AE+8761)_NGFF */
+#define RTW_MODULE_RTL8812AEBT_HMC		BIT3 /* RTL8812AEBT(8812AE+8761)_HMC */
+#define RTW_MODULE_RTL8188EE_HMC_M2		BIT4 /* RTL8188EE(HMC + M.2) */
+#define RTW_MODULE_RTL8723BE_HMC_M2		BIT5 /* RTL8723BE(HMC + M.2) */
+#define RTW_MODULE_RTL8723BS_NGFF1216	BIT6 /* RTL8723BS(NGFF1216) */
+#define RTW_MODULE_RTL8192EEBT_HMC_M2	BIT7 /* RTL8192EEBT(8192EE+8761AU)_(HMC + M.2) */
+
+#define IS_ALPHA2_NO_SPECIFIED(_alpha2) ((*((u16 *)(_alpha2))) == 0xFFFF)
+
+struct country_chplan {
+	char alpha2[2];
+	u8 chplan;
+#if RTW_DEF_MODULE_REGULATORY_CERT
+	u8 def_module_flags; /* RTW_MODULE_RTLXXX */
+#endif
+};
+
+#define COUNTRY_CHPLAN_EN_11AC(_ent) 0
+
+#if RTW_DEF_MODULE_REGULATORY_CERT
+#define COUNTRY_CHPLAN_DEF_MODULE_FALGS(_ent) ((_ent)->def_module_flags)
+#else
+#define COUNTRY_CHPLAN_DEF_MODULE_FALGS(_ent) 0
+#endif
+
+const struct country_chplan *rtw_get_chplan_from_country(const char *country_code);
+
+#define BB_GAIN_2G 0
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+#define BB_GAIN_5GLB1 1
+#define BB_GAIN_5GLB2 2
+#define BB_GAIN_5GMB1 3
+#define BB_GAIN_5GMB2 4
+#define BB_GAIN_5GHB 5
+#endif
+
+#ifdef CONFIG_IEEE80211_BAND_5GHZ
+#define BB_GAIN_NUM 6
+#else
+#define BB_GAIN_NUM 1
+#endif
+
+int rtw_ch_to_bb_gain_sel(int ch);
+void rtw_rf_set_tx_gain_offset(_adapter *adapter, u8 path, s8 offset);
+void rtw_rf_apply_tx_gain_offset(_adapter *adapter, u8 ch);
+
+bool rtw_is_dfs_range(u32 hi, u32 lo);
+bool rtw_is_dfs_ch(u8 ch, u8 bw, u8 offset);
+bool rtw_is_long_cac_range(u32 hi, u32 lo, u8 dfs_region);
+bool rtw_is_long_cac_ch(u8 ch, u8 bw, u8 offset, u8 dfs_region);
+
+#endif /* _RTL8711_RF_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_sdio.h b/drivers/staging/rtl8188eu/include/rtw_sdio.h
new file mode 100644
index 000000000000..c915d0804f9f
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_sdio.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_SDIO_H_
+#define _RTW_SDIO_H_
+
+#include <drv_types.h>		/* struct dvobj_priv and etc. */
+
+u8 rtw_sdio_read_cmd52(struct dvobj_priv *, u32 addr, void *buf, size_t len);
+u8 rtw_sdio_read_cmd53(struct dvobj_priv *, u32 addr, void *buf, size_t len);
+u8 rtw_sdio_write_cmd52(struct dvobj_priv *, u32 addr, void *buf, size_t len);
+u8 rtw_sdio_write_cmd53(struct dvobj_priv *, u32 addr, void *buf, size_t len);
+u8 rtw_sdio_f0_read(struct dvobj_priv *, u32 addr, void *buf, size_t len);
+
+#endif /* _RTW_SDIO_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_security.h b/drivers/staging/rtl8188eu/include/rtw_security.h
new file mode 100644
index 000000000000..2c2d6fe34d56
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_security.h
@@ -0,0 +1,475 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_SECURITY_H_
+#define __RTW_SECURITY_H_
+
+
+#define _NO_PRIVACY_		0x0
+#define _WEP40_				0x1
+#define _TKIP_				0x2
+#define _TKIP_WTMIC_		0x3
+#define _AES_				0x4
+#define _WEP104_			0x5
+#define _WEP_WPA_MIXED_	0x07  /* WEP + WPA */
+#define _SMS4_				0x06
+#ifdef CONFIG_IEEE80211W
+#define _BIP_				0x8
+#endif /* CONFIG_IEEE80211W */
+/* 802.11W use wrong key */
+#define IEEE80211W_RIGHT_KEY	0x0
+#define IEEE80211W_WRONG_KEY	0x1
+#define IEEE80211W_NO_KEY		0x2
+
+#define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
+
+const char *security_type_str(u8 value);
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#define SHA256_MAC_LEN 32
+#define AES_BLOCK_SIZE 16
+#define AES_PRIV_SIZE (4 * 44)
+
+#define RTW_KEK_LEN 16
+#define RTW_KCK_LEN 16
+#define RTW_TKIP_MIC_LEN 8
+#define RTW_REPLAY_CTR_LEN 8
+
+#define INVALID_SEC_MAC_CAM_ID	0xFF
+
+typedef enum {
+	ENCRYP_PROTOCOL_OPENSYS,   /* open system */
+	ENCRYP_PROTOCOL_WEP,       /* WEP */
+	ENCRYP_PROTOCOL_WPA,       /* WPA */
+	ENCRYP_PROTOCOL_WPA2,      /* WPA2 */
+	ENCRYP_PROTOCOL_WAPI,      /* WAPI: Not support in this version */
+	ENCRYP_PROTOCOL_MAX
+} ENCRYP_PROTOCOL_E;
+
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48	{
+
+	u64	val;
+
+#ifdef __LITTLE_ENDIAN
+
+struct {
+	u8 TSC0;
+	u8 TSC1;
+	u8 TSC2;
+	u8 TSC3;
+	u8 TSC4;
+	u8 TSC5;
+	u8 TSC6;
+	u8 TSC7;
+} _byte_;
+
+#else
+
+struct {
+	u8 TSC7;
+	u8 TSC6;
+	u8 TSC5;
+	u8 TSC4;
+	u8 TSC3;
+	u8 TSC2;
+	u8 TSC1;
+	u8 TSC0;
+} _byte_;
+
+#endif
+
+};
+
+union Keytype {
+	u8   skey[16];
+	u32    lkey[4];
+};
+
+
+typedef struct _RT_PMKID_LIST {
+	u8						bUsed;
+	u8						Bssid[6];
+	u8						PMKID[16];
+	u8						SsidBuf[33];
+	u8						*ssid_octet;
+	u16						ssid_length;
+} RT_PMKID_LIST, *PRT_PMKID_LIST;
+
+
+struct security_priv {
+	u32	  dot11AuthAlgrthm;		/* 802.11 auth, could be open, shared, 8021x and authswitch */
+	u32	  dot11PrivacyAlgrthm;	/* This specify the privacy for shared auth. algorithm. */
+
+	/* WEP */
+	u32	  dot11PrivacyKeyIndex;	/* this is only valid for legendary wep, 0~3 for key id. (tx key index) */
+	union Keytype dot11DefKey[4];			/* this is only valid for def. key	 */
+	u32	dot11DefKeylen[4];
+	u8	dot11Def_camid[4];
+	u8 	key_mask; /* use to restore wep key after hal_init */
+
+	u32 dot118021XGrpPrivacy;	/* This specify the privacy algthm. used for Grp key */
+	u32	dot118021XGrpKeyid;		/* key id used for Grp Key ( tx key index) */
+	union Keytype	dot118021XGrpKey[4];	/* 802.1x Group Key, for inx0 and inx1	 */
+	union Keytype	dot118021XGrptxmickey[4];
+	union Keytype	dot118021XGrprxmickey[4];
+	union pn48		dot11Grptxpn;			/* PN48 used for Grp Key xmit. */
+	union pn48		dot11Grprxpn;			/* PN48 used for Grp Key recv. */
+	u8				iv_seq[4][8];
+#ifdef CONFIG_IEEE80211W
+	u32	dot11wBIPKeyid;						/* key id used for BIP Key ( tx key index) */
+	union Keytype	dot11wBIPKey[6];		/* BIP Key, for index4 and index5 */
+	union pn48		dot11wBIPtxpn;			/* PN48 used for Grp Key xmit. */
+	union pn48		dot11wBIPrxpn;			/* PN48 used for Grp Key recv. */
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_AP_MODE
+	/* extend security capabilities for AP_MODE */
+	unsigned int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	unsigned int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;
+#endif
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	dot118021x_bmc_cam_id;
+#endif
+	/*IEEE802.11-2012 Std. Table 8-101 AKM Suite Selectors*/
+	u32	rsn_akm_suite_type;
+
+	u8 wps_ie[MAX_WPS_IE_LEN];/* added in assoc req */
+	int wps_ie_len;
+
+
+	u8	binstallGrpkey;
+#ifdef CONFIG_GTK_OL
+	u8	binstallKCK_KEK;
+#endif /* CONFIG_GTK_OL */
+#ifdef CONFIG_IEEE80211W
+	u8	binstallBIPkey;
+#endif /* CONFIG_IEEE80211W */
+	u8	busetkipkey;
+	/* struct timer_list tkip_timer; */
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+
+	/* u8	packet_cnt; */ /* unused, removed */
+
+	s32	sw_encrypt;/* from registry_priv */
+	s32	sw_decrypt;/* from registry_priv */
+
+	s32 	hw_decrypted;/* if the rx packets is hw_decrypted==false, it means the hw has not been ready. */
+
+
+	/* keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc) */
+	u32 ndisauthtype;	/* NDIS_802_11_AUTHENTICATION_MODE */
+	u32 ndisencryptstatus;	/* NDIS_802_11_ENCRYPTION_STATUS */
+
+	NDIS_802_11_WEP ndiswep;
+
+	u8 assoc_info[600];
+	u8 szofcapability[256]; /* for wpa2 usage */
+	u8 oidassociation[512]; /* for wpa/wpa2 usage */
+	u8 authenticator_ie[256];  /* store ap security information element */
+	u8 supplicant_ie[256];  /* store sta security information element */
+
+
+	/* for tkip countermeasure */
+	u32 last_mic_err_time;
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	/* --------------------------------------------------------------------------- */
+	/* For WPA2 Pre-Authentication. */
+	/* --------------------------------------------------------------------------- */
+	/* u8				RegEnablePreAuth;				 */ /* Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01. */
+	/* u8				EnablePreAuthentication;			 */ /* Current Value: Pre-Authentication enabled or not. */
+	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	/* Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13. */
+	u8				PMKIDIndex;
+	/* u32				PMKIDCount;						 */ /* Added by Annie, 2006-10-13. */
+	/* u8				szCapability[256];				 */ /* For WPA2-PSK using zero-config, by Annie, 2005-09-20. */
+
+	u8 bWepDefaultKeyIdxSet;
+
+#define DBG_SW_SEC_CNT
+#ifdef DBG_SW_SEC_CNT
+	u64 wep_sw_enc_cnt_bc;
+	u64 wep_sw_enc_cnt_mc;
+	u64 wep_sw_enc_cnt_uc;
+	u64 wep_sw_dec_cnt_bc;
+	u64 wep_sw_dec_cnt_mc;
+	u64 wep_sw_dec_cnt_uc;
+
+	u64 tkip_sw_enc_cnt_bc;
+	u64 tkip_sw_enc_cnt_mc;
+	u64 tkip_sw_enc_cnt_uc;
+	u64 tkip_sw_dec_cnt_bc;
+	u64 tkip_sw_dec_cnt_mc;
+	u64 tkip_sw_dec_cnt_uc;
+
+	u64 aes_sw_enc_cnt_bc;
+	u64 aes_sw_enc_cnt_mc;
+	u64 aes_sw_enc_cnt_uc;
+	u64 aes_sw_dec_cnt_bc;
+	u64 aes_sw_dec_cnt_mc;
+	u64 aes_sw_dec_cnt_uc;
+#endif /* DBG_SW_SEC_CNT */
+};
+
+struct sha256_state_rtk {
+	u64 length;
+	u32 state[8], curlen;
+	u8 buf[64];
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+	do {\
+		switch (psecuritypriv->dot11AuthAlgrthm) {\
+		case dot11AuthAlgrthm_Open:\
+		case dot11AuthAlgrthm_Shared:\
+		case dot11AuthAlgrthm_Auto:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case dot11AuthAlgrthm_8021X:\
+			if (bmcst)\
+				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo = (u8) psta->dot118021XPrivacy;\
+			break;\
+		case dot11AuthAlgrthm_WAPI:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		} \
+	} while (0)
+
+#define _AES_IV_LEN_ 8
+
+#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
+	do {\
+		switch (encrypt) {\
+		case _WEP40_:\
+		case _WEP104_:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case _TKIP_:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case _AES_:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		case _SMS4_:\
+			iv_len = 18;\
+			icv_len = 16;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+		} \
+	} while (0)
+
+
+#define GET_TKIP_PN(iv, dot11txpn)\
+	do {\
+		dot11txpn._byte_.TSC0 = iv[2];\
+		dot11txpn._byte_.TSC1 = iv[0];\
+		dot11txpn._byte_.TSC2 = iv[4];\
+		dot11txpn._byte_.TSC3 = iv[5];\
+		dot11txpn._byte_.TSC4 = iv[6];\
+		dot11txpn._byte_.TSC5 = iv[7];\
+	} while (0)
+
+
+#define ROL32(A, n)	(((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
+#define ROR32(A, n)	ROL32((A), 32-(n))
+
+struct mic_data {
+	u32  K0, K1;         /* Key */
+	u32  L, R;           /* Current state */
+	u32  M;              /* Message accumulator (single word) */
+	u32     nBytesInM;      /*  # bytes in M */
+};
+
+extern const u32 Te0[256];
+extern const u32 Te1[256];
+extern const u32 Te2[256];
+extern const u32 Te3[256];
+extern const u32 Te4[256];
+extern const u32 Td0[256];
+extern const u32 Td1[256];
+extern const u32 Td2[256];
+extern const u32 Td3[256];
+extern const u32 Td4[256];
+extern const u32 rcon[10];
+extern const u8 Td4s[256];
+extern const u8 rcons[10];
+
+#define RCON(i) (rcons[(i)] << 24)
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+#define TE0(i) Te0[((i) >> 24) & 0xff]
+#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
+#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
+#define TE3(i) rotr(Te0[(i) & 0xff], 24)
+#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
+#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
+#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
+#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
+#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
+#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
+#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
+#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
+#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)
+
+#define TD0(i) Td0[((i) >> 24) & 0xff]
+#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
+#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
+#define TD3(i) rotr(Td0[(i) & 0xff], 24)
+#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
+#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
+#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
+#define TD44(i) (Td4s[(i) & 0xff])
+#define TD0_(i) Td0[(i) & 0xff]
+#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
+#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
+#define TD3_(i) rotr(Td0[(i) & 0xff], 24)
+
+#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
+			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+
+#define PUTU32(ct, st) { \
+		(ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); \
+		(ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
+
+#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+/* ===== start - public domain SHA256 implementation ===== */
+
+/* This is based on SHA256 implementation in LibTomCrypt that was released into
+ * public domain by Tom St Denis. */
+
+/* the K array */
+static const unsigned long K[64] = {
+	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
+	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
+	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
+	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
+	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
+	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
+	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
+	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
+	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
+	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
+	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
+	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
+	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
+};
+
+
+/* Various logical functions */
+#define RORc(x, y) \
+	(((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
+	  ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
+#define Ch(x, y, z)       (z ^ (x & (y ^ z)))
+#define Maj(x, y, z)      (((x | y) & z) | (x & y))
+#define S(x, n)         RORc((x), (n))
+#define R(x, n)         (((x) & 0xFFFFFFFFUL)>>(n))
+#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
+#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
+#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
+#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+#ifdef CONFIG_IEEE80211W
+int omac1_aes_128(u8 *key, u8 *data, size_t data_len, u8 *mac);
+#endif /* CONFIG_IEEE80211W */
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key);
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b);
+void rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nBytes);
+void rtw_secgetmic(struct mic_data *pmicdata, u8 *dst);
+
+void rtw_seccalctkipmic(
+	u8 *key,
+	u8 *header,
+	u8 *data,
+	u32 data_len,
+	u8 *Miccode,
+	u8   priority);
+
+u32 rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe);
+u32 rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe);
+void rtw_wep_encrypt(_adapter *padapter, u8  *pxmitframe);
+
+u32 rtw_aes_decrypt(_adapter *padapter, u8  *precvframe);
+u32 rtw_tkip_decrypt(_adapter *padapter, u8  *precvframe);
+void rtw_wep_decrypt(_adapter *padapter, u8  *precvframe);
+#ifdef CONFIG_IEEE80211W
+u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe);
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_TDLS
+void wpa_tdls_generate_tpk(_adapter *padapter, void * sta);
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
+			u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
+			u8 *mic);
+int wpa_tdls_teardown_ftie_mic(u8 *kck, u8 *lnkid, u16 reason,
+			u8 dialog_token, u8 trans_seq, u8 *ftie, u8 *mic);
+int tdls_verify_mic(u8 *kck, u8 trans_seq,
+			u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
+#endif /* CONFIG_TDLS */
+
+void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS);
+
+void rtw_sec_restore_wep_key(_adapter *adapter);
+u8 rtw_handle_tkip_countermeasure(_adapter *adapter, const char *caller);
+
+#ifdef CONFIG_WOWLAN
+u16 rtw_calc_crc(u8  *pdata, int length);
+#endif /*CONFIG_WOWLAN*/
+
+#endif /* __RTL871X_SECURITY_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_sreset.h b/drivers/staging/rtl8188eu/include/rtw_sreset.h
new file mode 100644
index 000000000000..5a4ddd37e24b
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_sreset.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_SRESET_H_
+#define _RTW_SRESET_H_
+
+/* #include <drv_types.h> */
+
+enum {
+	SRESET_TGP_NULL = 0,
+	SRESET_TGP_XMIT_STATUS = 1,
+	SRESET_TGP_LINK_STATUS = 2,
+};
+
+struct sreset_priv {
+	_mutex	silentreset_mutex;
+	u8	silent_reset_inprogress;
+	u8	Wifi_Error_Status;
+	unsigned long last_tx_time;
+	unsigned long last_tx_complete_time;
+
+	s32 dbg_trigger_point;
+};
+
+
+
+#define	WIFI_STATUS_SUCCESS		0
+#define	USB_VEN_REQ_CMD_FAIL	BIT0
+#define	USB_READ_PORT_FAIL		BIT1
+#define	USB_WRITE_PORT_FAIL		BIT2
+#define	WIFI_MAC_TXDMA_ERROR	BIT3
+#define   WIFI_TX_HANG				BIT4
+#define	WIFI_RX_HANG				BIT5
+#define	WIFI_IF_NOT_EXIST			BIT6
+
+void sreset_init_value(_adapter *padapter);
+void sreset_reset_value(_adapter *padapter);
+u8 sreset_get_wifi_status(_adapter *padapter);
+void sreset_set_wifi_error_status(_adapter *padapter, u32 status);
+void sreset_set_trigger_point(_adapter *padapter, s32 tgp);
+bool sreset_inprogress(_adapter *padapter);
+void sreset_reset(_adapter *padapter);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_tdls.h b/drivers/staging/rtl8188eu/include/rtw_tdls.h
new file mode 100644
index 000000000000..5dbb478dfd1e
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_tdls.h
@@ -0,0 +1,157 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __RTW_TDLS_H_
+#define __RTW_TDLS_H_
+
+
+#ifdef CONFIG_TDLS
+/* TDLS STA state */
+
+
+/* TDLS Diect Link Establishment */
+#define	TDLS_STATE_NONE				0x00000000		/* Default state */
+#define	TDLS_INITIATOR_STATE		BIT(28)			/* 0x10000000 */
+#define	TDLS_RESPONDER_STATE		BIT(29)			/* 0x20000000 */
+#define	TDLS_LINKED_STATE			BIT(30)			/* 0x40000000 */
+/* TDLS PU Buffer STA */
+#define	TDLS_WAIT_PTR_STATE			BIT(24)			/* 0x01000000 */	/* Waiting peer's TDLS_PEER_TRAFFIC_RESPONSE frame */
+/* TDLS Check ALive */
+#define	TDLS_ALIVE_STATE			BIT(20)			/* 0x00100000 */	/* Check if peer sta is alived. */
+/* TDLS Channel Switch */
+#define	TDLS_CH_SWITCH_PREPARE_STATE	BIT(15)			/* 0x00008000 */
+#define	TDLS_CH_SWITCH_ON_STATE			BIT(16)			/* 0x00010000 */
+#define	TDLS_PEER_AT_OFF_STATE			BIT(17)			/* 0x00020000 */	/* Could send pkt on target ch */
+#define	TDLS_CH_SW_INITIATOR_STATE		BIT(18)			/* 0x00040000 */	/* Avoid duplicated or unconditional ch. switch rsp. */
+#define	TDLS_WAIT_CH_RSP_STATE			BIT(19)			/* 0x00080000 */	/* Wait Ch. response as we are TDLS channel switch initiator */
+
+
+#define	TDLS_TPK_RESEND_COUNT			86400	/*Unit: seconds */
+#define	TDLS_CH_SWITCH_TIME				15
+#define	TDLS_CH_SWITCH_TIMEOUT			30
+#define	TDLS_CH_SWITCH_OPER_OFFLOAD_TIMEOUT	10
+#define	TDLS_SIGNAL_THRESH			0x20
+#define	TDLS_WATCHDOG_PERIOD		10	/* Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec */
+#define	TDLS_HANDSHAKE_TIME			3000
+#define	TDLS_PTI_TIME				7000
+
+#define TDLS_CH_SW_STAY_ON_BASE_CHNL_TIMEOUT	20		/* ms */
+#define TDLS_CH_SW_MONITOR_TIMEOUT				2000	/*ms */
+
+#define TDLS_MIC_LEN 16
+#define WPA_NONCE_LEN 32
+#define TDLS_TIMEOUT_LEN 4
+
+enum TDLS_CH_SW_CHNL {
+	TDLS_CH_SW_BASE_CHNL = 0,
+	TDLS_CH_SW_OFF_CHNL
+};
+
+struct wpa_tdls_ftie {
+	u8 ie_type; /* FTIE */
+	u8 ie_len;
+	u8 mic_ctrl[2];
+	u8 mic[TDLS_MIC_LEN];
+	u8 Anonce[WPA_NONCE_LEN]; /* Responder Nonce in TDLS */
+	u8 Snonce[WPA_NONCE_LEN]; /* Initiator Nonce in TDLS */
+	/* followed by optional elements */
+} ;
+
+struct wpa_tdls_lnkid {
+	u8 ie_type; /* Link Identifier IE */
+	u8 ie_len;
+	u8 bssid[ETH_ALEN];
+	u8 init_sta[ETH_ALEN];
+	u8 resp_sta[ETH_ALEN];
+} ;
+
+static u8 TDLS_RSNIE[20] = {	0x01, 0x00,	/* Version shall be set to 1 */
+				0x00, 0x0f, 0xac, 0x07,	/* Group sipher suite */
+				0x01, 0x00,	/* Pairwise cipher suite count */
+	0x00, 0x0f, 0xac, 0x04,	/* Pairwise cipher suite list; CCMP only */
+				0x01, 0x00,	/* AKM suite count */
+				0x00, 0x0f, 0xac, 0x07,	/* TPK Handshake */
+				0x0c, 0x02,
+				/* PMKID shall not be present */
+			   };
+
+static u8 TDLS_WMMIE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	/* Qos info all set zero */
+
+static u8 TDLS_WMM_PARAM_IE[] = {0x00, 0x00, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00};
+
+static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x00};	/* bit(28), bit(30), bit(37) */
+
+/* SRC: Supported Regulatory Classes */
+static u8 TDLS_SRC[] = { 0x01, 0x01, 0x02, 0x03, 0x04, 0x0c, 0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x20, 0x21 };
+
+int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len);
+int check_ap_tdls_ch_switching_prohibited(u8 *pframe, u8 pkt_len);
+
+u8 rtw_tdls_is_setup_allowed(_adapter *padapter);
+#ifdef CONFIG_TDLS_CH_SW
+u8 rtw_tdls_is_chsw_allowed(_adapter *padapter);
+#endif
+
+void rtw_reset_tdls_info(_adapter *padapter);
+int rtw_init_tdls_info(_adapter *padapter);
+void rtw_free_tdls_info(struct tdls_info *ptdlsinfo);
+int issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+void rtw_init_tdls_timer(_adapter *padapter, struct sta_info *psta);
+void	rtw_free_tdls_timer(struct sta_info *psta);
+void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta);
+
+#ifdef CONFIG_TDLS_CH_SW
+void rtw_tdls_set_ch_sw_oper_control(_adapter *padapter, u8 enable);
+void rtw_tdls_ch_sw_back_to_base_chnl(_adapter *padapter);
+s32 rtw_tdls_do_ch_sw(_adapter *padapter, struct sta_info *ptdls_sta, u8 chnl_type, u8 channel, u8 channel_offset, u16 bwmode, u16 ch_switch_time);
+void rtw_tdls_chsw_oper_done(_adapter *padapter);
+#endif
+
+#ifdef CONFIG_WFD
+int issue_tunneled_probe_req(_adapter *padapter);
+int issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame);
+#endif /* CONFIG_WFD */
+int issue_tdls_dis_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_setup_req(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
+int issue_tdls_setup_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_setup_cfm(_adapter *padapter, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_dis_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, u8 privacy);
+int issue_tdls_teardown(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, u8 wait_ack);
+int issue_tdls_peer_traffic_rsp(_adapter *padapter, struct sta_info *psta, struct tdls_txmgmt *ptxmgmt);
+int issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *psta);
+#ifdef CONFIG_TDLS_CH_SW
+int issue_tdls_ch_switch_req(_adapter *padapter, struct sta_info *ptdls_sta);
+int issue_tdls_ch_switch_rsp(_adapter *padapter, struct tdls_txmgmt *ptxmgmt, int wait_ack);
+#endif
+sint On_TDLS_Dis_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Peer_Traffic_Indication(_adapter *adapter, union recv_frame *precv_frame);
+int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+#ifdef CONFIG_TDLS_CH_SW
+sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame);
+sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame);
+void rtw_build_tdls_ch_switch_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_ch_switch_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+#endif
+void rtw_build_tdls_setup_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_setup_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_setup_cfm_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_teardown_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_dis_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_dis_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt, u8 privacy);
+void rtw_build_tdls_peer_traffic_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tdls_peer_traffic_indication_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, struct tdls_txmgmt *ptxmgmt);
+void rtw_build_tunneled_probe_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe);
+void rtw_build_tunneled_probe_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe);
+
+u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta);
+int rtw_tdls_is_driver_setup(_adapter *padapter);
+void rtw_tdls_set_key(_adapter *padapter, struct sta_info *ptdls_sta);
+const char *rtw_tdls_action_txt(enum TDLS_ACTION_FIELD action);
+#endif /* CONFIG_TDLS */
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_version.h b/drivers/staging/rtl8188eu/include/rtw_version.h
new file mode 100644
index 000000000000..b252febe9d39
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_version.h
@@ -0,0 +1 @@
+#define DRIVERVERSION	"v5.2.2.4_25483.20171222"
diff --git a/drivers/staging/rtl8188eu/include/rtw_vht.h b/drivers/staging/rtl8188eu/include/rtw_vht.h
new file mode 100644
index 000000000000..02b08f702574
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_vht.h
@@ -0,0 +1,128 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_VHT_H_
+#define _RTW_VHT_H_
+
+#define	LDPC_VHT_ENABLE_RX			BIT0
+#define	LDPC_VHT_ENABLE_TX			BIT1
+#define	LDPC_VHT_TEST_TX_ENABLE		BIT2
+#define	LDPC_VHT_CAP_TX				BIT3
+
+#define	STBC_VHT_ENABLE_RX			BIT0
+#define	STBC_VHT_ENABLE_TX			BIT1
+#define	STBC_VHT_TEST_TX_ENABLE		BIT2
+#define	STBC_VHT_CAP_TX				BIT3
+
+#define	BEAMFORMING_VHT_BEAMFORMER_ENABLE	BIT0	/* Declare our NIC supports beamformer */
+#define	BEAMFORMING_VHT_BEAMFORMEE_ENABLE	BIT1	/* Declare our NIC supports beamformee */
+#define	BEAMFORMING_VHT_MU_MIMO_AP_ENABLE		BIT2			/*Declare our NIC support MU-MIMO AP mode*/
+#define	BEAMFORMING_VHT_MU_MIMO_STA_ENABLE	BIT3			/*Declare our NIC support MU-MIMO STA mode*/
+#define	BEAMFORMING_VHT_BEAMFORMER_TEST		BIT4			/*Transmiting Beamforming no matter the target supports it or not*/
+#define	BEAMFORMING_VHT_BEAMFORMER_STS_CAP		(BIT8 | BIT9 | BIT10)		/*Asoc rsp cap*/
+#define	BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM		(BIT12 | BIT13 | BIT14)		/*Asoc rsp cap*/
+
+
+/* VHT capability info */
+#define SET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 0, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 5, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 0, 3, _val)
+
+#define SET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_HTC_VHT(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart, _val)		SET_BITS_TO_LE_2BYTE((_pEleStart)+2, 7, 3, _val) /* B23~B25 */
+#define SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+4, 0, 16, _val)   /* B0~B15 indicate Rx MCS MAP, we write 0 to indicate MCS0~7. by page */
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+6, 0, 13, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+8, 0, 16, _val)   /* B0~B15 indicate Tx MCS MAP, we write 0 to indicate MCS0~7. by page */
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+10, 0, 13, _val)
+
+
+#define GET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 2, 2)
+#define GET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 4, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 6, 1)
+#define GET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+#define GET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 3)
+#define GET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 3, 1)
+#define GET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 4, 1)
+/*phydm-beamforming*/
+#define GET_VHT_CAPABILITY_ELE_SU_BFEE_STS_CAP(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+1, 5, 3)
+#define GET_VHT_CAPABILITY_ELE_SU_BFER_SOUND_DIM_NUM(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 0, 3)
+#define GET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 3, 1)
+#define GET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 4, 1)
+#define GET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 7, 3)
+#define GET_VHT_CAPABILITY_ELE_RX_MCS(_pEleStart)					       ((_pEleStart)+4)
+#define GET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+6, 0, 13)
+#define GET_VHT_CAPABILITY_ELE_TX_MCS(_pEleStart)					       ((_pEleStart)+8)
+#define GET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+10, 0, 13)
+
+
+/* VHT Operation Information Element */
+#define SET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ1(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+1, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ2(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart+2, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_BASIC_MCS_SET(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE((_pEleStart)+3, 0, 16, _val)
+
+#define GET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 0, 8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ1(_pEleStart)	LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ2(_pEleStart)     LE_BITS_TO_1BYTE((_pEleStart)+2, 0, 8)
+
+/* VHT Operating Mode */
+#define SET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 3, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 4, 3)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+
+#define SET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+7, 6, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+7, 6, 1)
+
+struct vht_priv {
+	u8	vht_option;
+
+	u8	ldpc_cap;
+	u8	stbc_cap;
+	u16	beamform_cap;
+
+	u8	sgi_80m;/* short GI */
+	u8	ampdu_len;
+
+	u8	vht_op_mode_notify;
+	u8	vht_highest_rate;
+	u8	vht_mcs_map[2];
+
+	u8	vht_cap[32];
+};
+
+u8	rtw_get_vht_highest_rate(u8 *pvht_mcs_map);
+u16	rtw_vht_mcs_to_data_rate(u8 bw, u8 short_GI, u8 vht_mcs_rate);
+u64	rtw_vht_mcs_map_to_bitmap(u8 *mcs_map, u8 nss);
+void	rtw_vht_use_default_setting(_adapter *padapter);
+u32	rtw_build_vht_operation_ie(_adapter *padapter, u8 *pbuf, u8 channel);
+u32	rtw_build_vht_op_mode_notify_ie(_adapter *padapter, u8 *pbuf, u8 bw);
+u32	rtw_build_vht_cap_ie(_adapter *padapter, u8 *pbuf);
+void	update_sta_vht_info_apmode(_adapter *padapter, void * psta);
+void	update_hw_vht_param(_adapter *padapter);
+void	VHT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void	VHT_operation_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void	rtw_process_vht_op_mode_notify(_adapter *padapter, u8 *pframe, void * sta);
+u32	rtw_restructure_vht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void	VHTOnAssocRsp(_adapter *padapter);
+u8	rtw_vht_mcsmap_to_nss(u8 *pvht_mcs_map);
+void rtw_vht_nss_to_mcsmap(u8 nss, u8 *target_mcs_map, u8 *cur_mcs_map);
+
+#endif /* _RTW_VHT_H_ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_wapi.h b/drivers/staging/rtl8188eu/include/rtw_wapi.h
new file mode 100644
index 000000000000..e53b6a0c6980
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_wapi.h
@@ -0,0 +1,214 @@
+#ifndef __INC_WAPI_H
+#define __INC_WAPI_H
+
+
+#define CONFIG_WAPI_SW_SMS4
+#define WAPI_DEBUG
+
+#define SMS4_MIC_LEN                16
+#define WAPI_EXT_LEN                18
+#define MAX_WAPI_IE_LEN		    256
+#define sMacHdrLng				24		/* octets in data header, no WEP */
+
+#ifdef WAPI_DEBUG
+
+/* WAPI trace debug */
+extern u32 wapi_debug_component;
+
+static inline void dump_buf(u8 *buf, u32 len)
+{
+	u32 i;
+	printk("-----------------Len %d----------------\n", len);
+	for (i = 0; i < len; i++)
+		printk("%2.2x-", *(buf + i));
+	printk("\n");
+}
+
+#define WAPI_TRACE(component, x, args...) \
+	do { if (wapi_debug_component & (component)) \
+			printk(KERN_DEBUG "WAPI" ":" x "" , \
+			       ##args);\
+	} while (0);
+
+#define WAPI_DATA(component, x, buf, len) \
+	do { if (wapi_debug_component & (component)) { \
+			printk("%s:\n", x);\
+			dump_buf((buf), (len)); } \
+	} while (0);
+
+#define RT_ASSERT_RET(_Exp)								\
+	if (!(_Exp)) {									\
+		printk("RTWLAN: ");					\
+		printk("Assertion failed! %s,%s, line=%d\n", \
+		       #_Exp, __func__, __LINE__);          \
+		return;						\
+	}
+#define RT_ASSERT_RET_VALUE(_Exp, Ret)								\
+	if (!(_Exp)) {									\
+		printk("RTWLAN: ");					\
+		printk("Assertion failed! %s,%s, line=%d\n", \
+		       #_Exp, __func__, __LINE__);          \
+		return Ret;						\
+	}
+
+#else
+#define RT_ASSERT_RET(_Exp) do {} while (0)
+#define RT_ASSERT_RET_VALUE(_Exp, Ret) do {} while (0)
+#define WAPI_TRACE(component, x, args...) do {} while (0)
+#define WAPI_DATA(component, x, buf, len) do {} while (0)
+#endif
+
+
+enum WAPI_DEBUG {
+	WAPI_INIT				= 1,
+	WAPI_API				= 1 << 1,
+	WAPI_TX				= 1 << 2,
+	WAPI_RX				= 1 << 3,
+	WAPI_MLME				= 1 << 4,
+	WAPI_IOCTL				= 1 << 5,
+	WAPI_ERR			= 1 << 31
+};
+
+#define			WAPI_MAX_BKID_NUM				4
+#define			WAPI_MAX_STAINFO_NUM			4
+#define			WAPI_CAM_ENTRY_NUM			14	/* 28/2 = 14 */
+
+typedef struct  _RT_WAPI_BKID {
+	struct list_head	list;
+	u8				bkid[16];
+} RT_WAPI_BKID, *PRT_WAPI_BKID;
+
+typedef struct  _RT_WAPI_KEY {
+	u8			dataKey[16];
+	u8			micKey[16];
+	u8			keyId;
+	bool			bSet;
+	bool             bTxEnable;
+} RT_WAPI_KEY, *PRT_WAPI_KEY;
+
+typedef enum _RT_WAPI_PACKET_TYPE {
+	WAPI_NONE = 0,
+	WAPI_PREAUTHENTICATE = 1,
+	WAPI_STAKEY_REQUEST = 2,
+	WAPI_AUTHENTICATE_ACTIVE = 3,
+	WAPI_ACCESS_AUTHENTICATE_REQUEST = 4,
+	WAPI_ACCESS_AUTHENTICATE_RESPONSE = 5,
+	WAPI_CERTIFICATE_AUTHENTICATE_REQUEST = 6,
+	WAPI_CERTIFICATE_AUTHENTICATE_RESPONSE = 7,
+	WAPI_USK_REQUEST = 8,
+	WAPI_USK_RESPONSE = 9,
+	WAPI_USK_CONFIRM = 10,
+	WAPI_MSK_NOTIFICATION = 11,
+	WAPI_MSK_RESPONSE = 12
+} RT_WAPI_PACKET_TYPE;
+
+typedef struct	_RT_WAPI_STA_INFO {
+	struct list_head		list;
+	u8					PeerMacAddr[6];
+	RT_WAPI_KEY		      wapiUsk;
+	RT_WAPI_KEY		      wapiUskUpdate;
+	RT_WAPI_KEY		      wapiMsk;
+	RT_WAPI_KEY		      wapiMskUpdate;
+	u8					lastRxUnicastPN[16];
+	u8					lastTxUnicastPN[16];
+	u8					lastRxMulticastPN[16];
+	u8					lastRxUnicastPNBEQueue[16];
+	u8					lastRxUnicastPNBKQueue[16];
+	u8					lastRxUnicastPNVIQueue[16];
+	u8					lastRxUnicastPNVOQueue[16];
+	bool					bSetkeyOk;
+	bool					bAuthenticateInProgress;
+	bool					bAuthenticatorInUpdata;
+} RT_WAPI_STA_INFO, *PRT_WAPI_STA_INFO;
+
+/* Added for HW wapi en/decryption */
+typedef struct _RT_WAPI_CAM_ENTRY {
+	/* RT_LIST_ENTRY		list; */
+	u8			IsUsed;
+	u8			entry_idx;/* for cam entry */
+	u8			keyidx;	/* 0 or 1,new or old key */
+	u8			PeerMacAddr[6];
+	u8			type;	/* should be 110,wapi */
+} RT_WAPI_CAM_ENTRY, *PRT_WAPI_CAM_ENTRY;
+
+typedef struct _RT_WAPI_T {
+	/* BKID */
+	RT_WAPI_BKID		wapiBKID[WAPI_MAX_BKID_NUM];
+	struct list_head		wapiBKIDIdleList;
+	struct list_head		wapiBKIDStoreList;
+	/* Key for Tx Multicast/Broadcast */
+	RT_WAPI_KEY		      wapiTxMsk;
+
+	/* sec related */
+	u8				lastTxMulticastPN[16];
+	/* STA list */
+	RT_WAPI_STA_INFO	wapiSta[WAPI_MAX_STAINFO_NUM];
+	struct list_head		wapiSTAIdleList;
+	struct list_head		wapiSTAUsedList;
+	/*  */
+	bool				bWapiEnable;
+
+	/* store WAPI IE */
+	u8				wapiIE[256];
+	u8				wapiIELength;
+	bool				bWapiPSK;
+	/* last sequece number for wai packet */
+	u16				wapiSeqnumAndFragNum;
+	int extra_prefix_len;
+	int extra_postfix_len;
+
+	RT_WAPI_CAM_ENTRY	wapiCamEntry[WAPI_CAM_ENTRY_NUM];
+} RT_WAPI_T, *PRT_WAPI_T;
+
+typedef struct _WLAN_HEADER_WAPI_EXTENSION {
+	u8      KeyIdx;
+	u8      Reserved;
+	u8      PN[16];
+} WLAN_HEADER_WAPI_EXTENSION, *PWLAN_HEADER_WAPI_EXTENSION;
+
+u32 WapiComparePN(u8 *PN1, u8 *PN2);
+
+
+void rtw_wapi_init(_adapter *padapter);
+
+void rtw_wapi_free(_adapter *padapter);
+
+void rtw_wapi_disable_tx(_adapter *padapter);
+
+u8 rtw_wapi_is_wai_packet(_adapter *padapter, u8 *pkt_data);
+
+void rtw_wapi_update_info(_adapter *padapter, union recv_frame *precv_frame);
+
+u8 rtw_wapi_check_for_drop(_adapter *padapter, union recv_frame *precv_frame);
+
+void rtw_build_probe_resp_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_build_beacon_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_build_assoc_req_wapi_ie(_adapter *padapter, unsigned char *pframe, struct pkt_attrib *pattrib);
+
+void rtw_wapi_on_assoc_ok(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+
+void rtw_wapi_return_one_sta_info(_adapter *padapter, u8 *MacAddr);
+
+void rtw_wapi_return_all_sta_info(_adapter *padapter);
+
+void rtw_wapi_clear_cam_entry(_adapter *padapter, u8 *pMacAddr);
+
+void rtw_wapi_clear_all_cam_entry(_adapter *padapter);
+
+void rtw_wapi_set_key(_adapter *padapter, RT_WAPI_KEY *pWapiKey, RT_WAPI_STA_INFO *pWapiSta, u8 bGroupKey, u8 bUseDefaultKey);
+
+int rtw_wapi_create_event_send(_adapter *padapter, u8 EventId, u8 *MacAddr, u8 *Buff, u16 BufLen);
+
+u32	rtw_sms4_encrypt(_adapter *padapter, u8 *pxmitframe);
+
+u32	rtw_sms4_decrypt(_adapter *padapter, u8 *precvframe);
+
+void rtw_wapi_get_iv(_adapter *padapter, u8 *pRA, u8 *IV);
+
+u8 WapiIncreasePN(u8 *PN, u8 AddCount);
+
+bool rtw_wapi_drop_for_key_absent(_adapter *padapter, u8 *pRA);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/rtw_wifi_regd.h b/drivers/staging/rtl8188eu/include/rtw_wifi_regd.h
new file mode 100644
index 000000000000..2182712648bd
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_wifi_regd.h
@@ -0,0 +1,25 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2010  Realtek Corporation.
+ *
+ *****************************************************************************/
+
+#ifndef __RTW_WIFI_REGD_H__
+#define __RTW_WIFI_REGD_H__
+
+struct country_code_to_enum_rd {
+	u16 countrycode;
+	const char *iso_name;
+};
+
+enum country_code_type_t {
+	COUNTRY_CODE_USER = 0,
+
+	/*add new channel plan above this line */
+	COUNTRY_CODE_MAX
+};
+
+int rtw_regd_init(_adapter *padapter);
+void rtw_reg_notify_by_driver(_adapter *adapter);
+
+#endif /* __RTW_WIFI_REGD_H__ */
diff --git a/drivers/staging/rtl8188eu/include/rtw_xmit.h b/drivers/staging/rtl8188eu/include/rtw_xmit.h
new file mode 100644
index 000000000000..2064ca1001e5
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/rtw_xmit.h
@@ -0,0 +1,699 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _RTW_XMIT_H_
+#define _RTW_XMIT_H_
+
+
+	#ifdef CONFIG_USB_TX_AGGREGATION
+		#if defined(CONFIG_PLATFORM_ARM_SUNxI) || defined(CONFIG_PLATFORM_ARM_SUN6I) || defined(CONFIG_PLATFORM_ARM_SUN7I) || defined(CONFIG_PLATFORM_ARM_SUN8I) || defined(CONFIG_PLATFORM_ARM_SUN50IW1P1)
+			#define MAX_XMITBUF_SZ (12288)  /* 12k 1536*8 */
+		#elif defined (CONFIG_PLATFORM_MSTAR)
+			#define MAX_XMITBUF_SZ	7680	/* 7.5k */
+		#else
+			#define MAX_XMITBUF_SZ	(20480)	/* 20k */
+		#endif
+	#else
+		#define MAX_XMITBUF_SZ	(2048)
+	#endif
+
+	#ifdef CONFIG_SINGLE_XMIT_BUF
+		#define NR_XMITBUFF	(1)
+	#else
+		#define NR_XMITBUFF	(4)
+	#endif /* CONFIG_SINGLE_XMIT_BUF */
+
+		#ifdef USB_XMITBUF_ALIGN_SZ
+			#define XMITBUF_ALIGN_SZ (USB_XMITBUF_ALIGN_SZ)
+		#else
+			#define XMITBUF_ALIGN_SZ 512
+		#endif
+
+/* xmit extension buff defination */
+#define MAX_XMIT_EXTBUF_SZ	(1536)
+
+#ifdef CONFIG_SINGLE_XMIT_BUF
+	#define NR_XMIT_EXTBUFF	(1)
+#else
+	#define NR_XMIT_EXTBUFF	(32)
+#endif
+
+#define MAX_CMDBUF_SZ	(5120)	/* (4096) */
+
+#define MAX_NUMBLKS		(1)
+
+#define XMIT_VO_QUEUE (0)
+#define XMIT_VI_QUEUE (1)
+#define XMIT_BE_QUEUE (2)
+#define XMIT_BK_QUEUE (3)
+
+#define VO_QUEUE_INX		0
+#define VI_QUEUE_INX		1
+#define BE_QUEUE_INX		2
+#define BK_QUEUE_INX		3
+#define BCN_QUEUE_INX		4
+#define MGT_QUEUE_INX		5
+#define HIGH_QUEUE_INX		6
+#define TXCMD_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+	do {\
+		pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+		pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+		pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+		pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+		dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0 : (dot11txpn.val+1);\
+	} while (0)
+
+
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+	do {\
+		pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+		pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+		pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+		pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+		pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+		pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+		pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+		pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+		dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0 : (dot11txpn.val+1);\
+	} while (0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+	do {\
+		pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+		pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+		pattrib_iv[2] = 0;\
+		pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+		pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+		pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+		pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+		pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+		dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0 : (dot11txpn.val+1);\
+	} while (0)
+
+/* Check if AMPDU Tx is supported or not. If it is supported,
+* it need to check "amsdu in ampdu" is supported or not.
+* (ampdu_en, amsdu_ampdu_en) =
+* (0, x) : AMPDU is not enable, but AMSDU is valid to send.
+* (1, 0) : AMPDU is enable, AMSDU in AMPDU is not enable. So, AMSDU is not valid to send.
+* (1, 1) : AMPDU and AMSDU in AMPDU are enable. So, AMSDU is valid to send.
+*/
+#define IS_AMSDU_AMPDU_NOT_VALID(pattrib)\
+	 ((pattrib->ampdu_en == true) && (pattrib->amsdu_ampdu_en == false))
+
+#define IS_AMSDU_AMPDU_VALID(pattrib)\
+	 !((pattrib->ampdu_en == true) && (pattrib->amsdu_ampdu_en == false))
+
+#define HWXMIT_ENTRY	4
+
+/* For Buffer Descriptor ring architecture */
+#if defined(BUF_DESC_ARCH) || defined(CONFIG_TRX_BD_ARCH)
+	#define TX_BUFFER_SEG_NUM	1 /* 0:2 seg, 1: 4 seg, 2: 8 seg. */
+#endif
+
+#define TXDESC_SIZE 32 /* old IC (ex: 8188E) */
+
+#ifdef CONFIG_TX_EARLY_MODE
+	#define EARLY_MODE_INFO_SIZE	8
+#endif
+
+
+	#ifdef USB_PACKET_OFFSET_SZ
+		#define PACKET_OFFSET_SZ (USB_PACKET_OFFSET_SZ)
+	#else
+		#define PACKET_OFFSET_SZ (8)
+	#endif
+	#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
+
+enum TXDESC_SC {
+	SC_DONT_CARE = 0x00,
+	SC_UPPER = 0x01,
+	SC_LOWER = 0x02,
+	SC_DUPLICATE = 0x03
+};
+
+#ifdef CONFIG_TRX_BD_ARCH
+struct tx_buf_desc {
+#ifdef CONFIG_64BIT_DMA
+#define TX_BUFFER_SEG_SIZE	4	/* in unit of DWORD */
+#else
+#define TX_BUFFER_SEG_SIZE	2	/* in unit of DWORD */
+#endif
+	unsigned int dword[TX_BUFFER_SEG_SIZE * (2 << TX_BUFFER_SEG_NUM)];
+} __packed;
+#else
+struct tx_desc {
+	__le32 txdw0;
+	__le32 txdw1;
+	__le32 txdw2;
+	__le32 txdw3;
+	__le32 txdw4;
+	__le32 txdw5;
+	__le32 txdw6;
+	__le32 txdw7;
+
+#if defined(TXDESC_40_BYTES) || defined(TXDESC_64_BYTES)
+	__le32 txdw8;
+	__le32 txdw9;
+#endif /* TXDESC_40_BYTES */
+
+#ifdef TXDESC_64_BYTES
+	__le32 txdw10;
+	__le32 txdw11;
+
+	/* 2008/05/15 MH Because PCIE HW memory R/W 4K limit. And now,  our descriptor */
+	/* size is 40 bytes. If you use more than 102 descriptor( 103*40>4096), HW will execute */
+	/* memoryR/W CRC error. And then all DMA fetch will fail. We must decrease descriptor */
+	/* number or enlarge descriptor size as 64 bytes. */
+	__le32 txdw12;
+	__le32 txdw13;
+	__le32 txdw14;
+	__le32 txdw15;
+#endif
+};
+#endif
+
+#ifndef CONFIG_TRX_BD_ARCH
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE >> 2];
+};
+#endif
+
+struct	hw_xmit	{
+	/* _lock xmit_lock; */
+	/* _list	pending; */
+	_queue *sta_queue;
+	/* struct hw_txqueue *phwtxqueue; */
+	/* sint	txcmdcnt; */
+	int	accnt;
+};
+
+/* reduce size */
+struct pkt_attrib {
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+	u16	ether_type;
+	u16	seqnum;
+	u8	hw_ssn_sel;	/* for HW_SEQ0,1,2,3 */
+	u16	pkt_hdrlen;	/* the original 802.3 pkt header len */
+	u16	hdrlen;		/* the WLAN Header Len */
+	u32	pktlen;		/* the original 802.3 pkt raw_data len (not include ether_hdr data) */
+	u32	last_txcmdsz;
+	u8	nr_frags;
+	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
+#if defined(CONFIG_CONCURRENT_MODE)
+	u8	bmc_camid;
+#endif
+	u8	iv_len;
+	u8	icv_len;
+	u8	iv[18];
+	u8	icv[16];
+	u8	priority;
+	u8	ack_policy;
+	u8	mac_id;
+	u8	vcs_mode;	/* virtual carrier sense method */
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	key_idx;
+	u8	qos_en;
+	u8	ht_en;
+	u8	raid;/* rate adpative id */
+	u8	bwmode;
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi;/* short GI */
+	u8	ampdu_en;/* tx ampdu enable */
+	u8	ampdu_spacing; /* ampdu_min_spacing for peer sta's rx */
+	u8	amsdu;
+	u8	amsdu_ampdu_en;/* tx amsdu in ampdu enable */
+	u8	mdata;/* more data bit */
+	u8	pctrl;/* per packet txdesc control enable */
+	u8	triggered;/* for ap mode handling Power Saving sta */
+	u8	qsel;
+	u8	order;/* order bit */
+	u8	eosp;
+	u8	rate;
+	u8	intel_proxim;
+	u8	retry_ctrl;
+	u8   mbssid;
+	u8	ldpc;
+	u8	stbc;
+	struct sta_info *psta;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	u8	hw_tcp_csum;
+#endif
+
+	u8 rtsen;
+	u8 cts2self;
+	union Keytype	dot11tkiptxmickey;
+	/* union Keytype	dot11tkiprxmickey; */
+	union Keytype	dot118021x_UncstKey;
+
+#ifdef CONFIG_TDLS
+	u8 direct_link;
+	struct sta_info *ptdls_sta;
+#endif /* CONFIG_TDLS */
+	u8 key_type;
+
+	u8 icmp_pkt;
+
+#ifdef CONFIG_BEAMFORMING
+	u16 txbf_p_aid;/*beamforming Partial_AID*/
+	u16 txbf_g_id;/*beamforming Group ID*/
+
+	/*
+	 * 2'b00: Unicast NDPA
+	 * 2'b01: Broadcast NDPA
+	 * 2'b10: Beamforming Report Poll
+	 * 2'b11: Final Beamforming Report Poll
+	 */
+	u8 bf_pkt_type;
+#endif
+
+};
+
+#ifdef CONFIG_TX_AMSDU
+enum {
+	RTW_AMSDU_TIMER_UNSET = 0,
+	RTW_AMSDU_TIMER_SETTING,
+	RTW_AMSDU_TIMER_TIMEOUT,
+};
+#endif
+
+#define WLANHDR_OFFSET	64
+
+#define NULL_FRAMETAG		(0x0)
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+#define TXAGG_FRAMETAG	0x08
+
+enum {
+	XMITBUF_DATA = 0,
+	XMITBUF_MGNT = 1,
+	XMITBUF_CMD = 2,
+};
+
+bool rtw_xmit_ac_blocked(_adapter *adapter);
+
+struct  submit_ctx {
+	u32 submit_time; /* */
+	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
+	int status; /* status for operation */
+	struct completion done;
+};
+
+enum {
+	RTW_SCTX_SUBMITTED = -1,
+	RTW_SCTX_DONE_SUCCESS = 0,
+	RTW_SCTX_DONE_UNKNOWN,
+	RTW_SCTX_DONE_TIMEOUT,
+	RTW_SCTX_DONE_BUF_ALLOC,
+	RTW_SCTX_DONE_BUF_FREE,
+	RTW_SCTX_DONE_WRITE_PORT_ERR,
+	RTW_SCTX_DONE_TX_DESC_NA,
+	RTW_SCTX_DONE_TX_DENY,
+	RTW_SCTX_DONE_CCX_PKT_FAIL,
+	RTW_SCTX_DONE_DRV_STOP,
+	RTW_SCTX_DONE_DEV_REMOVE,
+	RTW_SCTX_DONE_CMD_ERROR,
+	RTX_SCTX_CSTR_WAIT_RPT2,
+};
+
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
+int rtw_sctx_wait(struct submit_ctx *sctx, const char *msg);
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
+void rtw_sctx_done(struct submit_ctx **sctx);
+
+struct xmit_buf {
+	_list	list;
+
+	_adapter *padapter;
+
+	u8 *pallocated_buf;
+
+	u8 *pbuf;
+
+	void *priv_data;
+
+	u16 buf_tag; /* 0: Normal xmitbuf, 1: extension xmitbuf, 2:cmd xmitbuf */
+	u16 flags;
+	u32 alloc_sz;
+
+	u32  len;
+
+	struct submit_ctx *sctx;
+
+	/* u32 sz[8]; */
+	u32	ff_hwaddr;
+#ifdef RTW_HALMAC
+	u8 bulkout_id; /* for halmac */
+#endif /* RTW_HALMAC */
+
+	PURB	pxmit_urb[8];
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+
+	u8 bpending[8];
+
+	sint last[8];
+
+#if defined(DBG_XMIT_BUF) || defined(DBG_XMIT_BUF_EXT)
+	u8 no;
+#endif
+
+};
+
+
+struct xmit_frame {
+	_list	list;
+
+	struct pkt_attrib attrib;
+
+	_pkt *pkt;
+
+	int	frame_tag;
+
+	_adapter *padapter;
+
+	u8	*buf_addr;
+
+	struct xmit_buf *pxmitbuf;
+
+#ifdef CONFIG_USB_TX_AGGREGATION
+	u8	agg_num;
+#endif
+	s8	pkt_offset;
+
+#ifdef CONFIG_XMIT_ACK
+	u8 ack_report;
+#endif
+
+	u8 *alloc_addr; /* the actual address this xmitframe allocated */
+	u8 ext_tag; /* 0:data, 1:mgmt */
+
+};
+
+struct tx_servq {
+	_list	tx_pending;
+	_queue	sta_pending;
+	int qcnt;
+};
+
+
+struct sta_xmit_priv {
+	_lock	lock;
+	sint	option;
+	sint	apsd_setting;	/* When bit mask is on, the associated edca queue supports APSD. */
+
+
+	/* struct tx_servq blk_q[MAX_NUMBLKS]; */
+	struct tx_servq	be_q;			/* priority == 0,3 */
+	struct tx_servq	bk_q;			/* priority == 1,2 */
+	struct tx_servq	vi_q;			/* priority == 4,5 */
+	struct tx_servq	vo_q;			/* priority == 6,7 */
+	_list	legacy_dz;
+	_list  apsd;
+
+	u16 txseq_tid[16];
+
+	/* uint	sta_tx_bytes; */
+	/* u64	sta_tx_pkts; */
+	/* uint	sta_tx_fail; */
+
+
+};
+
+
+struct	hw_txqueue	{
+	volatile sint	head;
+	volatile sint	tail;
+	volatile sint 	free_sz;	/* in units of 64 bytes */
+	volatile sint      free_cmdsz;
+	volatile sint	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	sint	ac_tag;
+};
+
+struct agg_pkt_info {
+	u16 offset;
+	u16 pkt_len;
+};
+
+enum cmdbuf_type {
+	CMDBUF_BEACON = 0x00,
+	CMDBUF_RSVD,
+	CMDBUF_MAX
+};
+
+u8 rtw_get_hwseq_no(_adapter *padapter);
+
+struct	xmit_priv	{
+
+	_lock	lock;
+
+	_sema	xmit_sema;
+	_sema	terminate_xmitthread_sema;
+
+	/* _queue	blk_strms[MAX_NUMBLKS]; */
+	_queue	be_pending;
+	_queue	bk_pending;
+	_queue	vi_pending;
+	_queue	vo_pending;
+	_queue	bm_pending;
+
+	/* _queue	legacy_dz_queue; */
+	/* _queue	apsd_queue; */
+
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+	_queue	free_xmit_queue;
+
+	/* uint mapping_addr; */
+	/* uint pkt_sz; */
+
+	u8 *xframe_ext_alloc_addr;
+	u8 *xframe_ext;
+	uint free_xframe_ext_cnt;
+	_queue free_xframe_ext_queue;
+
+	/* struct	hw_txqueue	be_txqueue; */
+	/* struct	hw_txqueue	bk_txqueue; */
+	/* struct	hw_txqueue	vi_txqueue; */
+	/* struct	hw_txqueue	vo_txqueue; */
+	/* struct	hw_txqueue	bmc_txqueue; */
+
+	uint	frag_len;
+
+	_adapter	*adapter;
+
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	/* u16  rts_thresh; */
+
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	last_tx_pkts;
+
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+
+	u8	wmm_para_seq[4];/* sequence for wmm ac parameter strength from large to small. it's value is 0->vo, 1->vi, 2->be, 3->bk. */
+
+	_sema	tx_retevt;/* all tx return event; */
+	u8		txirp_cnt;
+
+	struct tasklet_struct xmit_tasklet;
+	/* per AC pending irp */
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+
+	_queue free_xmitbuf_queue;
+	_queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;
+
+	_queue free_xmit_extbuf_queue;
+	u8 *pallocated_xmit_extbuf;
+	u8 *pxmit_extbuf;
+	uint free_xmit_extbuf_cnt;
+
+	struct xmit_buf	pcmd_xmitbuf[CMDBUF_MAX];
+	u8   hw_ssn_seq_no;/* mapping to REG_HW_SEQ 0,1,2,3 */
+	u16	nqos_ssn;
+#ifdef CONFIG_TX_EARLY_MODE
+
+#define MAX_AGG_PKT_NUM 256 /* Max tx ampdu coounts		 */
+
+	struct agg_pkt_info agg_pkt[MAX_AGG_PKT_NUM];
+#endif
+
+#ifdef CONFIG_XMIT_ACK
+	int	ack_tx;
+	_mutex ack_tx_mutex;
+	struct submit_ctx ack_tx_ops;
+	u8 seq_no;
+#endif
+
+#ifdef CONFIG_TX_AMSDU
+	struct timer_list amsdu_vo_timer;
+	u8 amsdu_vo_timeout;
+
+	struct timer_list amsdu_vi_timer;
+	u8 amsdu_vi_timeout;
+
+	struct timer_list amsdu_be_timer;
+	u8 amsdu_be_timeout;
+
+	struct timer_list amsdu_bk_timer;
+	u8 amsdu_bk_timeout;
+
+	u32 amsdu_debug_set_timer;
+	u32 amsdu_debug_timeout;
+	u32 amsdu_debug_coalesce_one;
+	u32 amsdu_debug_coalesce_two;
+
+#endif
+	_lock lock_sctx;
+};
+
+extern struct xmit_frame *__rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv,
+		enum cmdbuf_type buf_type);
+#define rtw_alloc_cmdxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_RSVD)
+#define rtw_alloc_bcnxmitframe(p) __rtw_alloc_cmdxmitframe(p, CMDBUF_BEACON)
+
+extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtw_count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int sz);
+extern void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len);
+static s32 update_attrib_sec_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+static void update_attrib_phy_info(_adapter *padapter, struct pkt_attrib *pattrib, struct sta_info *psta);
+extern s32 rtw_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
+extern s32 rtw_put_snap(u8 *data, u16 h_proto);
+
+extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv);
+extern s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue);
+struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac);
+extern s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, sint entry);
+
+extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
+extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
+#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
+extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+#ifdef CONFIG_IEEE80211W
+extern s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
+#endif /* CONFIG_IEEE80211W */
+#ifdef CONFIG_TDLS
+extern struct tdls_txmgmt *ptxmgmt;
+s32 rtw_xmit_tdls_coalesce(_adapter *padapter, struct xmit_frame *pxmitframe, struct tdls_txmgmt *ptxmgmt);
+s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
+#endif
+s32 _rtw_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag);
+void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+
+
+s32 rtw_txframes_pending(_adapter *padapter);
+s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry);
+
+
+s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv);
+
+
+void rtw_alloc_hwxmits(_adapter *padapter);
+void rtw_free_hwxmits(_adapter *padapter);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
+s32 rtw_monitor_xmit_entry(struct sk_buff *skb, struct net_device *ndev);
+#endif
+s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
+bool xmitframe_hiq_filter(struct xmit_frame *xmitframe);
+#if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
+sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
+void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
+void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
+void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
+#endif
+
+u8 rtw_get_tx_bw_mode(_adapter *adapter, struct sta_info *sta);
+
+void rtw_get_adapter_tx_rate_bmp_by_bw(_adapter *adapter, u8 bw, u16 *r_bmp_cck_ofdm, u32 *r_bmp_ht, u32 *r_bmp_vht);
+void rtw_update_tx_rate_bmp(struct dvobj_priv *dvobj);
+u16 rtw_get_tx_rate_bmp_cck_ofdm(struct dvobj_priv *dvobj);
+u32 rtw_get_tx_rate_bmp_ht_by_bw(struct dvobj_priv *dvobj, u8 bw);
+u32 rtw_get_tx_rate_bmp_vht_by_bw(struct dvobj_priv *dvobj, u8 bw);
+u8 rtw_get_tx_bw_bmp_of_ht_rate(struct dvobj_priv *dvobj, u8 rate, u8 max_bw);
+u8 rtw_get_tx_bw_bmp_of_vht_rate(struct dvobj_priv *dvobj, u8 rate, u8 max_bw);
+
+u8 query_ra_short_GI(struct sta_info *psta, u8 bw);
+
+u8	qos_acm(u8 acm_mask, u8 priority);
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+void	enqueue_pending_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+void enqueue_pending_xmitbuf_to_head(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+struct xmit_buf	*dequeue_pending_xmitbuf(struct xmit_priv *pxmitpriv);
+struct xmit_buf	*select_and_dequeue_pending_xmitbuf(_adapter *padapter);
+sint	check_pending_xmitbuf(struct xmit_priv *pxmitpriv);
+thread_return	rtw_xmit_thread(thread_context context);
+#endif
+
+#ifdef CONFIG_TX_AMSDU
+extern void rtw_amsdu_vo_timeout_handler(void *FunctionContext);
+extern void rtw_amsdu_vi_timeout_handler(void *FunctionContext);
+extern void rtw_amsdu_be_timeout_handler(void *FunctionContext);
+extern void rtw_amsdu_bk_timeout_handler(void *FunctionContext);
+
+extern u8 rtw_amsdu_get_timer_status(_adapter *padapter, u8 priority);
+extern void rtw_amsdu_set_timer_status(_adapter *padapter, u8 priority, u8 status);
+extern void rtw_amsdu_set_timer(_adapter *padapter, u8 priority);
+extern void rtw_amsdu_cancel_timer(_adapter *padapter, u8 priority);
+
+extern s32 rtw_xmitframe_coalesce_amsdu(_adapter *padapter, struct xmit_frame *pxmitframe, struct xmit_frame *pxmitframe_queue);	
+extern s32 check_amsdu(struct xmit_frame *pxmitframe);
+extern s32 check_amsdu_tx_support(_adapter *padapter);
+extern struct xmit_frame *rtw_get_xframe(struct xmit_priv *pxmitpriv, int *num_frame);
+#endif
+
+static void do_queue_select(_adapter *padapter, struct pkt_attrib *pattrib);
+u32	rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);
+
+#ifdef CONFIG_XMIT_ACK
+int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms);
+void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status);
+#endif /* CONFIG_XMIT_ACK */
+
+
+/* include after declaring struct xmit_buf, in order to avoid warning */
+#include <xmit_osdep.h>
+
+#endif /* _RTL871X_XMIT_H_ */
diff --git a/drivers/staging/rtl8188eu/include/sta_info.h b/drivers/staging/rtl8188eu/include/sta_info.h
new file mode 100644
index 000000000000..b3906631fbfb
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/sta_info.h
@@ -0,0 +1,647 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+
+#define IBSS_START_MAC_ID	2
+#define NUM_STA MACID_NUM_SW_LIMIT
+
+#ifndef CONFIG_RTW_MACADDR_ACL
+	#define CONFIG_RTW_MACADDR_ACL 1
+#endif
+
+#ifndef CONFIG_RTW_PRE_LINK_STA
+	#define CONFIG_RTW_PRE_LINK_STA 0
+#endif
+
+#define NUM_ACL 16
+#define RTW_ACL_MODE_DISABLED				0
+#define RTW_ACL_MODE_ACCEPT_UNLESS_LISTED	1
+#define RTW_ACL_MODE_DENY_UNLESS_LISTED		2
+#define RTW_ACL_MODE_MAX					3
+
+#if CONFIG_RTW_MACADDR_ACL
+extern const char *const _acl_mode_str[];
+#define acl_mode_str(mode) (((mode) >= RTW_ACL_MODE_MAX) ? _acl_mode_str[RTW_ACL_MODE_DISABLED] : _acl_mode_str[(mode)])
+#endif
+
+#ifndef RTW_PRE_LINK_STA_NUM
+	#define RTW_PRE_LINK_STA_NUM 8
+#endif
+
+struct pre_link_sta_node_t {
+	u8 valid;
+	u8 addr[ETH_ALEN];
+};
+
+struct pre_link_sta_ctl_t {
+	_lock lock;
+	u8 num;
+	struct pre_link_sta_node_t node[RTW_PRE_LINK_STA_NUM];
+};
+
+#ifdef CONFIG_TDLS
+#define MAX_ALLOWED_TDLS_STA_NUM	4
+#endif
+
+enum sta_info_update_type {
+	STA_INFO_UPDATE_NONE = 0,
+	STA_INFO_UPDATE_BW = BIT(0),
+	STA_INFO_UPDATE_RATE = BIT(1),
+	STA_INFO_UPDATE_PROTECTION_MODE = BIT(2),
+	STA_INFO_UPDATE_CAP = BIT(3),
+	STA_INFO_UPDATE_HT_CAP = BIT(4),
+	STA_INFO_UPDATE_VHT_CAP = BIT(5),
+	STA_INFO_UPDATE_ALL = STA_INFO_UPDATE_BW
+			      | STA_INFO_UPDATE_RATE
+			      | STA_INFO_UPDATE_PROTECTION_MODE
+			      | STA_INFO_UPDATE_CAP
+			      | STA_INFO_UPDATE_HT_CAP
+			      | STA_INFO_UPDATE_VHT_CAP,
+	STA_INFO_UPDATE_MAX
+};
+
+struct rtw_wlan_acl_node {
+	_list		        list;
+	u8       addr[ETH_ALEN];
+	u8       valid;
+};
+
+struct wlan_acl_pool {
+	int mode;
+	int num;
+	struct rtw_wlan_acl_node aclnode[NUM_ACL];
+	_queue	acl_node_q;
+};
+
+typedef struct _RSSI_STA {
+
+	s32 undecorated_smoothed_pwdb;
+	s32 undecorated_smoothed_cck;
+	s32 undecorated_smoothed_ofdm;
+	u8 ofdm_pkt;
+	u8 cck_pkt;
+	u16 cck_sum_power;
+	u8 is_send_rssi;
+	u64 packet_map;
+	u8 valid_bit;
+} RSSI_STA, *PRSSI_STA;
+
+struct	stainfo_stats	{
+
+	u64 rx_mgnt_pkts;
+		u64 rx_beacon_pkts;
+		u64 rx_probereq_pkts;
+		u64 rx_probersp_pkts;
+		u64 rx_probersp_bm_pkts;
+		u64 rx_probersp_uo_pkts;
+	u64 rx_ctrl_pkts;
+	u64 rx_data_pkts;
+	u64 rx_data_last_pkts;		/* For Read & Clear requirement in proc_get_rx_stat() */
+	u64 rx_data_qos_pkts[TID_NUM];
+	u64	last_rx_mgnt_pkts;
+		u64 last_rx_beacon_pkts;
+		u64 last_rx_probereq_pkts;
+		u64 last_rx_probersp_pkts;
+		u64 last_rx_probersp_bm_pkts;
+		u64 last_rx_probersp_uo_pkts;
+	u64	last_rx_ctrl_pkts;
+	u64	last_rx_data_pkts;
+	u64 last_rx_data_qos_pkts[TID_NUM];
+#ifdef CONFIG_TDLS
+	u64 rx_tdls_disc_rsp_pkts;
+	u64 last_rx_tdls_disc_rsp_pkts;
+#endif
+	u64	rx_bytes;
+	u64	rx_drops;
+
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64  tx_drops;
+
+	u32 duplicate_cnt;	/* Read & Clear, in proc_get_rx_stat() */
+	u32 rxratecnt[128];	/* Read & Clear, in proc_get_rx_stat() */
+	u32 tx_ok_cnt;		/* Read & Clear, in proc_get_tx_stat() */
+	u32 tx_fail_cnt;	/* Read & Clear, in proc_get_tx_stat() */
+	u32 tx_retry_cnt;	/* Read & Clear, in proc_get_tx_stat() */
+};
+
+#ifndef DBG_SESSION_TRACKER
+#define DBG_SESSION_TRACKER 0
+#endif
+
+/* session tracker status */
+#define ST_STATUS_NONE		0
+#define ST_STATUS_CHECK		BIT0
+#define ST_STATUS_ESTABLISH	BIT1
+#define ST_STATUS_EXPIRE	BIT2
+
+#define ST_EXPIRE_MS (10 * 1000)
+
+struct session_tracker {
+	_list list; /* session_tracker_queue */
+	u32 local_naddr;
+	__be16 local_port;
+	u32 remote_naddr;
+	__be16 remote_port;
+	u32 set_time;
+	u8 status;
+};
+
+/* session tracker cmd */
+#define ST_CMD_ADD 0
+#define ST_CMD_DEL 1
+#define ST_CMD_CHK 2
+
+struct st_cmd_parm {
+	u8 cmd;
+	struct sta_info *sta;
+	u32 local_naddr; /* TODO: IPV6 */
+	u16 local_port;
+	u32 remote_naddr; /* TODO: IPV6 */
+	u16 remote_port;
+};
+
+typedef bool (*st_match_rule)(_adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+
+struct st_register {
+	u8 s_proto;
+	st_match_rule rule;
+};
+
+#define SESSION_TRACKER_REG_ID_WFD 0
+#define SESSION_TRACKER_REG_ID_NUM 1
+
+struct st_ctl_t {
+	struct st_register reg[SESSION_TRACKER_REG_ID_NUM];
+	_queue tracker_q;
+};
+
+void rtw_st_ctl_init(struct st_ctl_t *st_ctl);
+void rtw_st_ctl_deinit(struct st_ctl_t *st_ctl);
+void rtw_st_ctl_register(struct st_ctl_t *st_ctl, u8 st_reg_id, struct st_register *reg);
+void rtw_st_ctl_unregister(struct st_ctl_t *st_ctl, u8 st_reg_id);
+bool rtw_st_ctl_chk_reg_s_proto(struct st_ctl_t *st_ctl, u8 s_proto);
+bool rtw_st_ctl_chk_reg_rule(struct st_ctl_t *st_ctl, _adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
+void dump_st_ctl(void *sel, struct st_ctl_t *st_ctl);
+
+#ifdef CONFIG_TDLS
+struct TDLS_PeerKey {
+	u8 kck[16]; /* TPK-KCK */
+	u8 tk[16]; /* TPK-TK; only CCMP will be used */
+} ;
+#endif /* CONFIG_TDLS */
+
+#ifdef DBG_RX_DFRAME_RAW_DATA
+struct sta_recv_dframe_info {
+
+	u8 sta_data_rate;
+	u8 sta_sgi;
+	u8 sta_bw_mode;
+	s8 sta_mimo_signal_strength[4];
+	s8 sta_RxPwr[4];
+	u8 sta_ofdm_snr[4];
+};
+#endif
+
+struct sta_info {
+
+	_lock	lock;
+	_list	list; /* free_sta_queue */
+	_list	hash_list; /* sta_hash */
+	/* _list asoc_list; */ /* 20061114 */
+	/* _list sleep_list; */ /* sleep_q */
+	/* _list wakeup_list; */ /* wakeup_q */
+	_adapter *padapter;
+
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+
+#ifdef DBG_RX_DFRAME_RAW_DATA
+	struct sta_recv_dframe_info  sta_dframe_info;
+#endif
+	_queue sleep_q;
+	unsigned int sleepq_len;
+
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	u8	hwaddr[ETH_ALEN];
+	u16 hwseq;
+	u8	ra_rpt_linked;
+
+	uint	ieee8021x_blocked;	/* 0: allowed, 1:blocked */
+	uint	dot118021XPrivacy; /* aes, tkip... */
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+	union pn48		dot11txpn;			/* PN48 used for Unicast xmit */
+#ifdef CONFIG_GTK_OL
+	u8 kek[RTW_KEK_LEN];
+	u8 kck[RTW_KCK_LEN];
+	u8 replay_ctr[RTW_REPLAY_CTR_LEN];
+#endif /* CONFIG_GTK_OL */
+#ifdef CONFIG_IEEE80211W
+	union pn48		dot11wtxpn;			/* PN48 used for Unicast mgmt xmit. */
+	struct timer_list dot11w_expire_timer;
+#endif /* CONFIG_IEEE80211W */
+	union pn48		dot11rxpn;			/* PN48 used for Unicast recv. */
+
+
+	u8	bssrateset[16];
+	u32	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+
+	u8	cts2self;
+	u8	rtsen;
+
+	u8	raid;
+	u8	init_rate;
+	u64	ra_mask;
+	u8	wireless_mode;	/* NETWORK_TYPE */
+	u8	bw_mode;
+
+	u8	ldpc;
+	u8	stbc;
+
+#ifdef CONFIG_BEAMFORMING
+	u16 txbf_paid;
+	u16 txbf_gid;
+#endif
+
+	struct stainfo_stats sta_stats;
+
+#ifdef CONFIG_TDLS
+	u32	tdls_sta_state;
+	u8	SNonce[32];
+	u8	ANonce[32];
+	u32	TDLS_PeerKey_Lifetime;
+	u32	TPK_count;
+	_timer	TPK_timer;
+	struct TDLS_PeerKey	tpk;
+#ifdef CONFIG_TDLS_CH_SW
+	u16	ch_switch_time;
+	u16	ch_switch_timeout;
+	/* u8	option; */
+	_timer	ch_sw_timer;
+	_timer	delay_timer;
+	_timer	stay_on_base_chnl_timer;
+	_timer	ch_sw_monitor_timer;
+#endif
+	struct timer_list handshake_timer;
+	u8 alive_count;
+	_timer	pti_timer;
+	u8	TDLS_RSNIE[20];	/* Save peer's RSNIE, used for sending TDLS_SETUP_RSP */
+#endif /* CONFIG_TDLS */
+
+	/* for A-MPDU TX, ADDBA timeout check	 */
+	struct timer_list addba_retry_timer;
+
+	/* for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl recvreorder_ctrl[TID_NUM];
+	ATOMIC_T continual_no_rx_packet[TID_NUM];
+	/* for A-MPDU Tx */
+	/* unsigned char		ampdu_txen_bitmap; */
+	u16	BA_starting_seqctrl[16];
+	struct ht_priv	htpriv;
+
+	/* Notes:	 */
+	/* STA_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO	 */
+	/* scan_q: AP CAP/INFO */
+
+	/* AP_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO */
+	/* sta_info: (AP & STA) CAP/INFO */
+
+	unsigned int expire_to;
+
+#ifdef CONFIG_AP_MODE
+
+	_list asoc_list;
+	_list auth_list;
+
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	u16 capability;
+	int flags;
+
+	int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
+	int wpa_group_cipher;
+	int wpa2_group_cipher;
+	int wpa_pairwise_cipher;
+	int wpa2_pairwise_cipher;
+
+	u8 bpairwise_key_installed;
+#ifdef CONFIG_RTW_80211R
+	u8 ft_pairwise_key_installed;
+#endif
+
+#ifdef CONFIG_NATIVEAP_MLME
+	u8 wpa_ie[32];
+
+	u8 nonerp_set;
+	u8 no_short_slot_time_set;
+	u8 no_short_preamble_set;
+	u8 no_ht_gf_set;
+	u8 no_ht_set;
+	u8 ht_20mhz_set;
+	u8 ht_40mhz_intolerant;
+#endif /* CONFIG_NATIVEAP_MLME */
+
+#ifdef CONFIG_ATMEL_RC_PATCH
+	u8 flag_atmel_rc;
+#endif
+
+	u8 qos_info;
+
+	u8 max_sp_len;
+	u8 uapsd_bk;/* BIT(0): Delivery enabled, BIT(1): Trigger enabled */
+	u8 uapsd_be;
+	u8 uapsd_vi;
+	u8 uapsd_vo;
+
+	u8 has_legacy_ac;
+	unsigned int sleepq_ac_len;
+
+#ifdef CONFIG_P2P
+	/* p2p priv data */
+	u8 is_p2p_device;
+	u8 p2p_status_code;
+
+	/* p2p client info */
+	u8 dev_addr[ETH_ALEN];
+	/* u8 iface_addr[ETH_ALEN]; */ /* = hwaddr[ETH_ALEN] */
+	u8 dev_cap;
+	u16 config_methods;
+	u8 primary_dev_type[8];
+	u8 num_of_secdev_type;
+	u8 secdev_types_list[32];/* 32/8 == 4; */
+	u16 dev_name_len;
+	u8 dev_name[32];
+#endif /* CONFIG_P2P */
+
+#ifdef CONFIG_WFD
+	u8 op_wfd_mode;
+#endif
+
+#ifdef CONFIG_TX_MCAST2UNI
+	u8 under_exist_checking;
+#endif /* CONFIG_TX_MCAST2UNI */
+
+	u8 keep_alive_trycnt;
+
+#ifdef CONFIG_AUTO_AP_MODE
+	u8 isrc; /* this device is rc */
+	u16 pid; /* pairing id */
+#endif
+
+#endif /* CONFIG_AP_MODE	 */
+
+#ifdef CONFIG_IOCTL_CFG80211
+	u8 *passoc_req;
+	u32 assoc_req_len;
+#endif
+
+	/* for DM */
+	RSSI_STA	 rssi_stat;
+
+	/* ODM_STA_INFO_T */
+	/* ================ODM Relative Info======================= */
+	/* Please be care, dont declare too much structure here. It will cost memory * STA support num. */
+	/*  */
+	/*  */
+	/* 2011/10/20 MH Add for ODM STA info.	 */
+	/*  */
+	/* Driver Write */
+	u8		bValid;				/* record the sta status link or not? */
+	/* u8		WirelessMode;		 */ /* */
+	u8		IOTPeer;			/* Enum value.	HT_IOT_PEER_E */
+	/* ODM Write */
+	/* 1 PHY_STATUS_INFO */
+	u8		RSSI_Path[4];		/*  */
+	u8		RSSI_Ave;
+	u8		RXEVM[4];
+	u8		RXSNR[4];
+
+	u8		rssi_level;			/* for Refresh RA mask */
+	/* ODM Write */
+	/* 1 TX_INFO (may changed by IC) */
+	/* TX_INFO_T		pTxInfo;				 */ /* Define in IC folder. Move lower layer. */
+	/*  */
+	/* ================ODM Relative Info======================= */
+	/*  */
+
+	/* To store the sequence number of received management frame */
+	u16 RxMgmtFrameSeqNum;
+
+	struct st_ctl_t st_ctl;
+};
+
+#define sta_rx_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts \
+	 + sta->sta_stats.rx_ctrl_pkts \
+	 + sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts \
+	 + sta->sta_stats.last_rx_ctrl_pkts \
+	 + sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_data_pkts(sta) \
+	(sta->sta_stats.rx_data_pkts)
+
+#define sta_rx_data_qos_pkts(sta, i) \
+	(sta->sta_stats.rx_data_qos_pkts[i])
+
+#define sta_last_rx_data_pkts(sta) \
+	(sta->sta_stats.last_rx_data_pkts)
+
+#define sta_last_rx_data_qos_pkts(sta, i) \
+	(sta->sta_stats.last_rx_data_qos_pkts[i])
+
+#define sta_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts)
+
+#define sta_last_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts)
+
+#define sta_rx_beacon_pkts(sta) \
+	(sta->sta_stats.rx_beacon_pkts)
+
+#define sta_last_rx_beacon_pkts(sta) \
+	(sta->sta_stats.last_rx_beacon_pkts)
+
+#define sta_rx_probereq_pkts(sta) \
+	(sta->sta_stats.rx_probereq_pkts)
+
+#define sta_last_rx_probereq_pkts(sta) \
+	(sta->sta_stats.last_rx_probereq_pkts)
+
+#define sta_rx_probersp_pkts(sta) \
+	(sta->sta_stats.rx_probersp_pkts)
+
+#define sta_last_rx_probersp_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_pkts)
+
+#define sta_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.rx_probersp_bm_pkts)
+
+#define sta_last_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_bm_pkts)
+
+#define sta_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.rx_probersp_uo_pkts)
+
+#define sta_last_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_uo_pkts)
+
+#define sta_update_last_rx_pkts(sta) \
+	do { \
+		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
+		sta->sta_stats.last_rx_beacon_pkts = sta->sta_stats.rx_beacon_pkts; \
+		sta->sta_stats.last_rx_probereq_pkts = sta->sta_stats.rx_probereq_pkts; \
+		sta->sta_stats.last_rx_probersp_pkts = sta->sta_stats.rx_probersp_pkts; \
+		sta->sta_stats.last_rx_probersp_bm_pkts = sta->sta_stats.rx_probersp_bm_pkts; \
+		sta->sta_stats.last_rx_probersp_uo_pkts = sta->sta_stats.rx_probersp_uo_pkts; \
+		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
+		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
+	} while (0)
+
+#define STA_RX_PKTS_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts
+
+#define STA_LAST_RX_PKTS_ARG(sta) \
+	sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.last_rx_data_pkts
+
+#define STA_RX_PKTS_DIFF_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts - sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts - sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts - sta->sta_stats.last_rx_data_pkts
+
+#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
+
+#ifdef CONFIG_WFD
+#define STA_OP_WFD_MODE(sta) (sta)->op_wfd_mode
+#define STA_SET_OP_WFD_MODE(sta, mode) (sta)->op_wfd_mode = (mode)
+#else
+#define STA_OP_WFD_MODE(sta) 0
+#define STA_SET_OP_WFD_MODE(sta, mode) do {} while (0)
+#endif
+
+struct	sta_priv {
+
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	_queue	free_sta_queue;
+
+	_lock sta_hash_lock;
+	_list   sta_hash[NUM_STA];
+	int asoc_sta_count;
+	_queue sleep_q;
+	_queue wakeup_q;
+
+	_adapter *padapter;
+
+	u32 adhoc_expire_to;
+
+#ifdef CONFIG_AP_MODE
+	_list asoc_list;
+	_list auth_list;
+	_lock asoc_list_lock;
+	_lock auth_list_lock;
+	u8 asoc_list_cnt;
+	u8 auth_list_cnt;
+
+	unsigned int auth_to;  /* sec, time to expire in authenticating. */
+	unsigned int assoc_to; /* sec, time to expire before associating. */
+	unsigned int expire_to; /* sec , time to expire after associated. */
+
+	/* pointers to STA info; based on allocated AID or NULL if AID free
+	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
+	 * and so on
+	 */
+	struct sta_info *sta_aid[NUM_STA];
+
+	u16 sta_dz_bitmap;/* only support 15 stations, staion aid bitmap for sleeping sta. */
+	u16 tim_bitmap;/* only support 15 stations, aid=0~15 mapping bit0~bit15	 */
+
+	u16 max_num_sta;
+
+#if CONFIG_RTW_MACADDR_ACL
+	struct wlan_acl_pool acl_list;
+#endif
+
+	#if CONFIG_RTW_PRE_LINK_STA
+	struct pre_link_sta_ctl_t pre_link_sta_ctl;
+	#endif
+
+#endif /* CONFIG_AP_MODE */
+
+#ifdef CONFIG_ATMEL_RC_PATCH
+	u8 atmel_rc_pattern[6];
+#endif
+	struct sta_info *c2h_sta;
+	struct submit_ctx *gotc2h;
+};
+
+
+__inline static u32 wifi_mac_hash(u8 *mac)
+{
+	u32 x;
+
+	x = mac[0];
+	x = (x << 2) ^ mac[1];
+	x = (x << 2) ^ mac[2];
+	x = (x << 2) ^ mac[3];
+	x = (x << 2) ^ mac[4];
+	x = (x << 2) ^ mac[5];
+
+	x ^= x >> 8;
+	x  = x & (NUM_STA - 1);
+
+	return x;
+}
+
+
+extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);
+
+#define stainfo_offset_valid(offset) (offset < NUM_STA && offset >= 0)
+int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta);
+struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset);
+
+extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
+extern u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta);
+extern void rtw_free_all_stainfo(_adapter *padapter);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+extern u32 rtw_init_bcmc_stainfo(_adapter *padapter);
+extern struct sta_info *rtw_get_bcmc_stainfo(_adapter *padapter);
+
+#if CONFIG_RTW_MACADDR_ACL
+extern u8 rtw_access_ctrl(_adapter *adapter, u8 *mac_addr);
+void dump_macaddr_acl(void *sel, _adapter *adapter);
+#endif
+
+bool rtw_is_pre_link_sta(struct sta_priv *stapriv, u8 *addr);
+#if CONFIG_RTW_PRE_LINK_STA
+struct sta_info *rtw_pre_link_sta_add(struct sta_priv *stapriv, u8 *hwaddr);
+void rtw_pre_link_sta_del(struct sta_priv *stapriv, u8 *hwaddr);
+void rtw_pre_link_sta_ctl_reset(struct sta_priv *stapriv);
+void rtw_pre_link_sta_ctl_init(struct sta_priv *stapriv);
+void rtw_pre_link_sta_ctl_deinit(struct sta_priv *stapriv);
+void dump_pre_link_sta_ctl(void *sel, struct sta_priv *stapriv);
+#endif /* CONFIG_RTW_PRE_LINK_STA */
+
+#endif /* _STA_INFO_H_ */
diff --git a/drivers/staging/rtl8188eu/include/usb_hal.h b/drivers/staging/rtl8188eu/include/usb_hal.h
new file mode 100644
index 000000000000..ccb3132b5fad
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/usb_hal.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __USB_HAL_H__
+#define __USB_HAL_H__
+
+int usb_init_recv_priv(_adapter *padapter, u16 ini_in_buf_sz);
+void usb_free_recv_priv(_adapter *padapter, u16 ini_in_buf_sz);
+#ifdef CONFIG_FW_C2H_REG
+void usb_c2h_hisr_hdl(_adapter *adapter, u8 *buf);
+#endif
+
+u8 rtw_set_hal_ops(_adapter *padapter);
+
+void rtl8188eu_set_hal_ops(_adapter *padapter);
+
+#ifdef CONFIG_INTEL_PROXIM
+extern _adapter  *rtw_usb_get_sw_pointer(void);
+#endif /* CONFIG_INTEL_PROXIM */
+
+#endif /* __USB_HAL_H__ */
diff --git a/drivers/staging/rtl8188eu/include/usb_ops.h b/drivers/staging/rtl8188eu/include/usb_ops.h
new file mode 100644
index 000000000000..aadbb3891dc0
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/usb_ops.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+
+#define REALTEK_USB_VENQT_READ		0xC0
+#define REALTEK_USB_VENQT_WRITE	0x40
+#define REALTEK_USB_VENQT_CMD_REQ	0x05
+#define REALTEK_USB_VENQT_CMD_IDX	0x00
+#define REALTEK_USB_IN_INT_EP_IDX	1
+
+enum {
+	VENDOR_WRITE = 0x00,
+	VENDOR_READ = 0x01,
+};
+#define ALIGNMENT_UNIT				16
+#define MAX_VENDOR_REQ_CMD_SIZE	254		/* 8188cu SIE Support */
+#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE + ALIGNMENT_UNIT)
+
+#include <usb_ops_linux.h>
+
+void rtl8188eu_set_hw_type(struct dvobj_priv *pdvobj);
+#ifdef CONFIG_SUPPORT_USB_INT
+void interrupt_handler_8188eu(_adapter *padapter, u16 pkt_len, u8 *pbuf);
+#endif
+
+void usb_set_intf_ops(_adapter *padapter, struct _io_ops *pops);
+
+enum RTW_USB_SPEED {
+	RTW_USB_SPEED_UNKNOWN	= 0,
+	RTW_USB_SPEED_1_1	= 1,
+	RTW_USB_SPEED_2		= 2,
+	RTW_USB_SPEED_3		= 3,
+};
+
+#define IS_FULL_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_1_1)
+#define IS_HIGH_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_2)
+#define IS_SUPER_SPEED_USB(Adapter)	(adapter_to_dvobj(Adapter)->usb_speed == RTW_USB_SPEED_3)
+
+#define USB_SUPER_SPEED_BULK_SIZE	1024	/* usb 3.0 */
+#define USB_HIGH_SPEED_BULK_SIZE	512		/* usb 2.0 */
+#define USB_FULL_SPEED_BULK_SIZE	64		/* usb 1.1 */
+
+static inline u8 rtw_usb_bulk_size_boundary(_adapter *padapter, int buf_len)
+{
+	u8 rst = true;
+
+	if (IS_SUPER_SPEED_USB(padapter))
+		rst = (0 == (buf_len) % USB_SUPER_SPEED_BULK_SIZE) ? true : false;
+	if (IS_HIGH_SPEED_USB(padapter))
+		rst = (0 == (buf_len) % USB_HIGH_SPEED_BULK_SIZE) ? true : false;
+	else
+		rst = (0 == (buf_len) % USB_FULL_SPEED_BULK_SIZE) ? true : false;
+	return rst;
+}
+
+
+#endif /* __USB_OPS_H_ */
diff --git a/drivers/staging/rtl8188eu/include/usb_ops_linux.h b/drivers/staging/rtl8188eu/include/usb_ops_linux.h
new file mode 100644
index 000000000000..507477953daa
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/usb_ops_linux.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __USB_OPS_LINUX_H__
+#define __USB_OPS_LINUX_H__
+
+#define VENDOR_CMD_MAX_DATA_LEN	254
+#define FW_START_ADDRESS	0x1000
+
+#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10/* ms */
+#define RTW_USB_CONTROL_MSG_TIMEOUT	500/* ms */
+
+#define RECV_BULK_IN_ADDR		0x80/* assign by drv, not real address */
+#define RECV_INT_IN_ADDR		0x81/* assign by drv, not real address */
+
+#define INTERRUPT_MSG_FORMAT_LEN 60
+
+#if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	/* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
+	#define MAX_USBCTRL_VENDORREQ_TIMES	10
+#else
+	#define MAX_USBCTRL_VENDORREQ_TIMES	1
+#endif
+
+#define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
+#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
+#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
+#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
+#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
+#define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 12))
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
+#else
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
+		((timeout_ms) == 0) || ((timeout_ms) * HZ / 1000 > 0) ? ((timeout_ms) * HZ / 1000) : 1)
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
+		((timeout_ms) == 0) || ((timeout_ms) * HZ / 1000 > 0) ? ((timeout_ms) * HZ / 1000) : 1)
+#endif
+
+
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+int usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+int usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, __le16 val);
+int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, __le32 val);
+#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+void usb_read_port_cancel(struct intf_hdl *pintfhdl);
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+void usb_write_port_cancel(struct intf_hdl *pintfhdl);
+
+int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
+		u16 value, u16 index, void *pdata, u16 len, u8 requesttype);
+#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
+
+u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr);
+u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr);
+u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr);
+int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+int usb_write16(struct intf_hdl *pintfhdl, u32 addr, __le16 val);
+int usb_write32(struct intf_hdl *pintfhdl, u32 addr, __le32 val);
+int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_recv_tasklet(void *priv);
+
+#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
+void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs);
+u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr);
+#endif
+#endif
diff --git a/drivers/staging/rtl8188eu/include/usb_osintf.h b/drivers/staging/rtl8188eu/include/usb_osintf.h
new file mode 100644
index 000000000000..94ff336262bd
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/usb_osintf.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include <usb_vendor_req.h>
+
+#define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)
+
+
+u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv, RT_USB_BREQUEST brequest, RT_USB_WVALUE wvalue, u8 windex, void *data, u8 datalen, u8 isdirectionin);
+void nat25_db_expire(_adapter *priv);
+int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method);
+int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/usb_vendor_req.h b/drivers/staging/rtl8188eu/include/usb_vendor_req.h
new file mode 100644
index 000000000000..b5cc7c270628
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/usb_vendor_req.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+/* 4	Set/Get Register related wIndex/Data */
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+/* 4	Set/Get SYSCLK related	wValue or Data */
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+typedef enum _RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+} RT_USB_BREQUEST;
+
+
+typedef enum _RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+} RT_USB_WVALUE;
+
+#endif
diff --git a/drivers/staging/rtl8188eu/include/wifi.h b/drivers/staging/rtl8188eu/include/wifi.h
new file mode 100644
index 000000000000..a6fc5b44131a
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/wifi.h
@@ -0,0 +1,1252 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+
+#ifdef BIT
+/* #error	"BIT define occurred earlier elsewhere!\n" */
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_WMM_LEN		24
+
+#ifdef CONFIG_APPEND_VENDOR_IE_ENABLE
+#define WLAN_MAX_VENDOR_IE_LEN 255
+#define WLAN_MAX_VENDOR_IE_NUM 5
+#define WIFI_BEACON_VENDOR_IE_BIT BIT(0)
+#define WIFI_PROBEREQ_VENDOR_IE_BIT BIT(1)
+#define WIFI_PROBERESP_VENDOR_IE_BIT BIT(2)
+#define WIFI_ASSOCREQ_VENDOR_IE_BIT BIT(3)
+#define WIFI_ASSOCRESP_VENDOR_IE_BIT BIT(4)
+#endif
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+/* This value is tested by WiFi 11n Test Plan 5.2.3.
+ * This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration. */
+#define	WiFiNavUpperUs				30000	/* 30 ms */
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7) | BIT(3)),	/* !< QoS Data	 */
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+	/* below is for mgt frame */
+	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_ACTION_NOACK = (BIT(7) | BIT(6) | BIT(5) | WIFI_MGT_TYPE),
+
+	/* below is for control frame */
+	WIFI_BF_REPORT_POLL = (BIT(6) | WIFI_CTRL_TYPE),
+	WIFI_NDPA         = (BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+	/* below is for data frame */
+	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	/* WPA reason */
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	/* belowing are Realtek definition */
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+	_RSON_TDLS_TEAR_TOOFAR_			= 25,
+	_RSON_TDLS_TEAR_UN_RSN_			= 26,
+};
+
+/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
+/* IEEE 802.11h */
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_SEC_DISABLED_			= 5,
+	_STATS_NOT_IN_SAME_BSS_		= 7,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+	_STATS_REFUSED_TEMPORARILY_ = 30,
+	_STATS_DECLINE_REQ_			= 37,
+	_STATS_INVALID_PARAMETERS_	= 38,
+	_STATS_INVALID_RSNIE_			= 72,
+};
+
+/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
+/* entended */
+/* IEEE 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+/* IEEE 802.11h */
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+/* IEEE 802.11g */
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
+#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
+/* IEEE 802.11w */
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+/* IEEE 802.11i */
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+/* IEEE 802.11r */
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while (0)
+
+#define GetToDs(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while (0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while (0)
+
+#define GetFrDs(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while (0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while (0)
+
+#define GetMFrag(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while (0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while (0)
+
+#define GetRetry(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while (0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while (0)
+
+#define GetPwrMgt(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while (0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while (0)
+
+#define GetMData(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while (0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while (0)
+
+#define GetPrivacy(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while (0)
+
+
+#define GetOrder(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf)) & (_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf, type)	\
+	do {	\
+		*(__le16 *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(__le16 *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while (0)
+
+#define get_frame_sub_type(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+
+#define set_frame_sub_type(pbuf, type) \
+	do {    \
+		*(__le16 *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(type); \
+	} while (0)
+
+
+#define GetSequence(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & cpu_to_le16(~(0x000f))) | \
+				cpu_to_le16(0x0f & (num));     \
+	} while (0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 22) = \
+			cpu_to_le16((le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & 0x000f) | \
+			(0xfff0 & (num << 4))); \
+	} while (0)
+
+#define set_duration(pbuf, dur) \
+	do {    \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while (0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while (0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf))) & 0xf)
+
+#define SetEOSP(pbuf, eosp)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((eosp & 1) << 4); \
+	} while (0)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
+	} while (0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
+	} while (0)
+
+#define GetAid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1) | GetFrDs(pbuf)) == 3 ? 30 : 24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
+
+#define get_addr2_ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
+
+
+#define MacAddr_isBcst(addr) \
+	(\
+	 ((addr[0] == 0xff) && (addr[1] == 0xff) && \
+	  (addr[2] == 0xff) && (addr[3] == 0xff) && \
+	  (addr[4] == 0xff) && (addr[5] == 0xff)) ? true : false \
+	)
+
+__inline static int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return true;
+	else
+		return false;
+}
+
+__inline static unsigned char *get_ra(unsigned char *pframe)
+{
+	unsigned char	*ra;
+	ra = GetAddr1Ptr(pframe);
+	return ra;
+}
+__inline static unsigned char *get_ta(unsigned char *pframe)
+{
+	unsigned char	*ta;
+	ta = get_addr2_ptr(pframe);
+	return ta;
+}
+
+__inline static unsigned char *get_da(unsigned char *pframe)
+{
+	unsigned char	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		da = GetAddr3Ptr(pframe);
+		break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char *get_sa(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = get_addr2_ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = get_addr2_ptr(pframe);
+		break;
+	default:	/* ToDs=1, FromDs=1 */
+		sa = GetAddr4Ptr(pframe);
+		break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char *get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char	*sa = NULL;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	/* ToDs=0, FromDs=0 */
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x01:	/* ToDs=0, FromDs=1 */
+		sa = get_addr2_ptr(pframe);
+		break;
+	case 0x02:	/* ToDs=1, FromDs=0 */
+		sa = GetAddr1Ptr(pframe);
+		break;
+	case 0x03:	/* ToDs=1, FromDs=1 */
+		sa = GetAddr1Ptr(pframe);
+		break;
+	}
+
+	return sa;
+}
+
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if (WIFI_CTRL_TYPE == GetFrameType(pframe))
+		return true;
+	else
+		return false;
+}
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A) ? 16 : 10)
+#define _ACKCTSLNG_				14	/* 14 bytes long, including crclng */
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	/* excluding wlan_hdr */
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+#define _PUBLIC_ACTION_IE_OFFSET_	8
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _COUNTRY_IE_			7
+#define _CHLGETXT_IE_			16
+#define _SUPPORTED_CH_IE_		36
+#define _CH_SWTICH_ANNOUNCE_	37	/* Secondary Channel Offset */
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _MDIE_						54
+#define _FTIE_						55
+#define _TIMEOUT_ITVL_IE_			56
+#define _SRC_IE_				59
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 /* _HT_EXTRA_INFO_IE_ */
+#define _WAPI_IE_					68
+
+
+/* #define EID_BSSCoexistence			72 */ /* 20/40 BSS Coexistence
+ * #define EID_BSSIntolerantChlReport	73 */
+#define _RIC_Descriptor_IE_			75
+#ifdef CONFIG_IEEE80211W
+#define _MME_IE_					76 /* 802.11w Management MIC element */
+#endif /* CONFIG_IEEE80211W */
+#define _LINK_ID_IE_					101
+#define _CH_SWITCH_TIMING_		104
+#define _PTI_BUFFER_STATUS_		106
+#define _EXT_CAP_IE_				127
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+typedef	enum _ELEMENT_ID {
+	EID_SsId					= 0, /* service set identifier (0:32) */
+	EID_SupRates				= 1, /* supported rates (1:8) */
+	EID_FHParms				= 2, /* FH parameter set (5) */
+	EID_DSParms				= 3, /* DS parameter set (1) */
+	EID_CFParms				= 4, /* CF parameter set (6) */
+	EID_Tim						= 5, /* Traffic Information Map (4:254) */
+	EID_IbssParms				= 6, /* IBSS parameter set (2) */
+	EID_Country					= 7, /* */
+
+	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
+	EID_QBSSLoad				= 11,
+	EID_EDCAParms				= 12,
+	EID_TSpec					= 13,
+	EID_TClass					= 14,
+	EID_Schedule				= 15,
+	/*  */
+
+	EID_Ctext					= 16, /* challenge text*/
+	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/
+
+	/* vivi for WIFITest, 802.11h AP, 20100427 */
+	/* 2010/12/26 MH The definition we can declare always!! */
+	EID_PowerCap				= 33,
+	EID_SupportedChannels		= 36,
+	EID_ChlSwitchAnnounce		= 37,
+
+	EID_MeasureRequest			= 38, /* Measurement Request */
+	EID_MeasureReport			= 39, /* Measurement Report */
+
+	EID_ERPInfo				= 42,
+
+	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
+	EID_TSDelay				= 43,
+	EID_TCLASProc				= 44,
+	EID_HTCapability			= 45,
+	EID_QoSCap					= 46,
+	/*  */
+
+	EID_WPA2					= 48,
+	EID_ExtSupRates			= 50,
+
+	EID_FTIE					= 55, /* Defined in 802.11r */
+	EID_Timeout				= 56, /* Defined in 802.11r */
+
+	EID_SupRegulatory			= 59, /* Supported Requlatory Classes 802.11y */
+	EID_HTInfo					= 61,
+	EID_SecondaryChnlOffset		= 62,
+
+	EID_BSSCoexistence			= 72, /* 20/40 BSS Coexistence */
+	EID_BSSIntolerantChlReport	= 73,
+	EID_OBSS					= 74, /* Overlapping BSS Scan Parameters */
+
+	EID_LinkIdentifier			= 101, /* Defined in 802.11z */
+	EID_WakeupSchedule		= 102, /* Defined in 802.11z */
+	EID_ChnlSwitchTimeing		= 104, /* Defined in 802.11z */
+	EID_PTIControl				= 105, /* Defined in 802.11z */
+	EID_PUBufferStatus			= 106, /* Defined in 802.11z */
+
+	EID_EXTCapability			= 127, /* Extended Capabilities */
+	/* From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18. */
+	EID_Aironet					= 133, /* 0x85: Aironet Element for Cisco CCX */
+	EID_CiscoIP					= 149, /* 0x95: IP Address IE for Cisco CCX */
+
+	EID_CellPwr					= 150, /* 0x96: Cell Power Limit IE. Ref. 0x96. */
+
+	EID_CCKM					= 156,
+
+	EID_Vendor					= 221, /* 0xDD: Vendor Specific */
+
+	EID_WAPI					= 68,
+	EID_VHTCapability 			= 191, /* Based on 802.11ac D2.0 */
+	EID_VHTOperation 			= 192, /* Based on 802.11ac D2.0 */
+	EID_AID						= 197, /* Based on 802.11ac D4.0 */
+	EID_OpModeNotification		= 199, /* Based on 802.11ac D3.0 */
+} ELEMENT_ID, *PELEMENT_ID;
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+#define cap_PBCC	BIT(6)
+#define cap_ChAgility	BIT(7)
+#define cap_SpecMgmt	BIT(8)
+#define cap_QoS	BIT(9)
+#define cap_ShortSlot	BIT(10)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		/* WPA */
+#define _IEEE8021X_PSK_			2		/* WPA with pre-shared key */
+
+#ifdef CONFIG_IEEE80211W
+#define _MME_IE_LENGTH_  18
+#endif /* CONFIG_IEEE80211W */
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  /* for WMM STA */
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+#define set_order_bit(pbuf)	\
+		do	{	\
+			*(__le16 *)(pbuf) |= cpu_to_le16(_ORDER_); \
+		} while (0)
+
+
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define ACT_CAT_VENDOR				0x7F/* 127 */
+
+/**
+ * struct rtw_ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct rtw_ieee80211_bar {
+	__le16 frame_control;
+	__le16 duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	__le16 control;
+	__le16 start_seq_num;
+} __attribute__((packed));
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+/**
+* struct rtw_ieee80211_ht_cap - HT capabilities
+*
+* This structure refers to "HT capabilities element" as
+* described in 802.11n draft section 7.3.2.52
+*/
+
+struct rtw_ieee80211_ht_cap {
+	__le16	cap_info;
+	unsigned char	ampdu_params_info;
+	unsigned char	supp_mcs_set[16];
+	__le16	extended_ht_cap_info;
+	__le32 tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__((packed));
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char	control_chan;
+	unsigned char		ht_param;
+	__le16	operation_mode;
+	__le16	stbc_param;
+	unsigned char		basic_set[16];
+} __attribute__((packed));
+
+
+struct HT_caps_element {
+	union {
+		struct {
+			__le16	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			__le16	HT_ext_caps;
+			__le32	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	} u;
+} __attribute__((packed));
+
+struct HT_info_element {
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+}  __attribute__((packed));
+
+struct AC_param {
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	__le16	TXOP_limit;
+}  __attribute__((packed));
+
+struct WMM_para_element {
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+}  __attribute__((packed));
+
+struct ADDBA_request {
+	unsigned char		dialog_token;
+	__le16	BA_para_set;
+	__le16	BA_timeout_value;
+	__le16	BA_starting_seqctrl;
+}  __attribute__((packed));
+
+typedef enum _HT_CAP_AMPDU_FACTOR {
+	MAX_AMPDU_FACTOR_8K		= 0,
+	MAX_AMPDU_FACTOR_16K	= 1,
+	MAX_AMPDU_FACTOR_32K	= 2,
+	MAX_AMPDU_FACTOR_64K	= 3,
+} HT_CAP_AMPDU_FACTOR;
+
+typedef enum _HT_CAP_AMPDU_DENSITY {
+	AMPDU_DENSITY_VALUE_0 = 0 , /* For no restriction */
+	AMPDU_DENSITY_VALUE_1 = 1 , /* For 1/4 us */
+	AMPDU_DENSITY_VALUE_2 = 2 , /* For 1/2 us */
+	AMPDU_DENSITY_VALUE_3 = 3 , /* For 1 us */
+	AMPDU_DENSITY_VALUE_4 = 4 , /* For 2 us */
+	AMPDU_DENSITY_VALUE_5 = 5 , /* For 4 us */
+	AMPDU_DENSITY_VALUE_6 = 6 , /* For 8 us */
+	AMPDU_DENSITY_VALUE_7 = 7 , /* For 16 us */
+} HT_CAP_AMPDU_DENSITY;
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_LDPC_CODING		0x0001
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC_1R		0x0100
+#define IEEE80211_HT_CAP_RX_STBC_2R		0x0200
+#define IEEE80211_HT_CAP_RX_STBC_3R		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+#define RTW_IEEE80211_HT_CAP_40MHZ_INTOLERANT	((u16) BIT(14))
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT capability TXBF capability */
+#define IEEE80211_HT_CAP_TXBF_RX_NDP		0x00000008
+#define IEEE80211_HT_CAP_TXBF_TX_NDP		0x00000010
+#define IEEE80211_HT_CAP_TXBF_EXPLICIT_COMP_STEERING_CAP	0x00000400
+
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE		0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0)
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+#endif
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+#define OP_MODE_PURE                    0
+#define OP_MODE_MAY_BE_LEGACY_STAS      1
+#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
+#define OP_MODE_MIXED                   3
+
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
+#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
+#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))
+
+#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
+	((u16) (0x0001 | 0x0002))
+#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
+#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
+#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
+#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))
+
+#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
+#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
+#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
+#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
+
+
+
+/* #endif */
+
+/*	===============WPS Section=============== */
+/*	For WPSv1.0 */
+#define WPSOUI							0x0050f204
+/*	WPS attribute ID */
+#define WPS_ATTR_VER1					0x104A
+#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
+#define WPS_ATTR_RESP_TYPE			0x103B
+#define WPS_ATTR_UUID_E				0x1047
+#define WPS_ATTR_MANUFACTURER		0x1021
+#define WPS_ATTR_MODEL_NAME			0x1023
+#define WPS_ATTR_MODEL_NUMBER		0x1024
+#define WPS_ATTR_SERIAL_NUMBER		0x1042
+#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
+#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
+#define WPS_ATTR_DEVICE_NAME			0x1011
+#define WPS_ATTR_CONF_METHOD			0x1008
+#define WPS_ATTR_RF_BANDS				0x103C
+#define WPS_ATTR_DEVICE_PWID			0x1012
+#define WPS_ATTR_REQUEST_TYPE			0x103A
+#define WPS_ATTR_ASSOCIATION_STATE	0x1002
+#define WPS_ATTR_CONFIG_ERROR			0x1009
+#define WPS_ATTR_VENDOR_EXT			0x1049
+#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
+
+/*	Value of WPS attribute "WPS_ATTR_DEVICE_NAME */
+#define WPS_MAX_DEVICE_NAME_LEN		32
+
+/*	Value of WPS Request Type Attribute */
+#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
+#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
+#define WPS_REQ_TYPE_REGISTRAR					0x02
+#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
+
+/*	Value of WPS Response Type Attribute */
+#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
+#define WPS_RESPONSE_TYPE_8021X		0x01
+#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
+#define WPS_RESPONSE_TYPE_AP			0x03
+
+/*	Value of WPS WiFi Simple Configuration State Attribute */
+#define WPS_WSC_STATE_NOT_CONFIG	0x01
+#define WPS_WSC_STATE_CONFIG			0x02
+
+/*	Value of WPS Version Attribute */
+#define WPS_VERSION_1					0x10
+
+/*	Value of WPS Configuration Method Attribute */
+#define WPS_CONFIG_METHOD_FLASH		0x0001
+#define WPS_CONFIG_METHOD_ETHERNET	0x0002
+#define WPS_CONFIG_METHOD_LABEL		0x0004
+#define WPS_CONFIG_METHOD_DISPLAY	0x0008
+#define WPS_CONFIG_METHOD_E_NFC		0x0010
+#define WPS_CONFIG_METHOD_I_NFC		0x0020
+#define WPS_CONFIG_METHOD_NFC		0x0040
+#define WPS_CONFIG_METHOD_PBC		0x0080
+#define WPS_CONFIG_METHOD_KEYPAD	0x0100
+#define WPS_CONFIG_METHOD_VPBC		0x0280
+#define WPS_CONFIG_METHOD_PPBC		0x0480
+#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
+#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
+
+/*	Value of Category ID of WPS Primary Device Type Attribute */
+#define WPS_PDT_CID_DISPLAYS			0x0007
+#define WPS_PDT_CID_MULIT_MEDIA		0x0008
+#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
+
+/*	Value of Sub Category ID of WPS Primary Device Type Attribute */
+#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
+#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
+
+/*	Value of Device Password ID */
+#define WPS_DPID_PIN					0x0000
+#define WPS_DPID_USER_SPEC			0x0001
+#define WPS_DPID_MACHINE_SPEC			0x0002
+#define WPS_DPID_REKEY					0x0003
+#define WPS_DPID_PBC					0x0004
+#define WPS_DPID_REGISTRAR_SPEC		0x0005
+
+/*	Value of WPS RF Bands Attribute */
+#define WPS_RF_BANDS_2_4_GHZ		0x01
+#define WPS_RF_BANDS_5_GHZ		0x02
+
+/*	Value of WPS Association State Attribute */
+#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
+#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
+#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
+#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
+#define WPS_ASSOC_STATE_IP_FAILURE				0x04
+
+/*	=====================P2P Section===================== */
+/*	For P2P */
+#define	P2POUI							0x506F9A09
+
+/*	P2P Attribute ID */
+#define	P2P_ATTR_STATUS					0x00
+#define	P2P_ATTR_MINOR_REASON_CODE		0x01
+#define	P2P_ATTR_CAPABILITY				0x02
+#define	P2P_ATTR_DEVICE_ID				0x03
+#define	P2P_ATTR_GO_INTENT				0x04
+#define	P2P_ATTR_CONF_TIMEOUT			0x05
+#define	P2P_ATTR_LISTEN_CH				0x06
+#define	P2P_ATTR_GROUP_BSSID				0x07
+#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
+#define	P2P_ATTR_INTENDED_IF_ADDR		0x09
+#define	P2P_ATTR_MANAGEABILITY			0x0A
+#define	P2P_ATTR_CH_LIST					0x0B
+#define	P2P_ATTR_NOA						0x0C
+#define	P2P_ATTR_DEVICE_INFO				0x0D
+#define	P2P_ATTR_GROUP_INFO				0x0E
+#define	P2P_ATTR_GROUP_ID					0x0F
+#define	P2P_ATTR_INTERFACE				0x10
+#define	P2P_ATTR_OPERATING_CH			0x11
+#define	P2P_ATTR_INVITATION_FLAGS		0x12
+
+/*	Value of Status Attribute */
+#define	P2P_STATUS_SUCCESS						0x00
+#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
+#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
+#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
+#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
+#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
+#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
+#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
+#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
+#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
+
+/*	Value of Inviation Flags Attribute */
+#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
+
+#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
+				 P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
+				 P2P_DEVCAP_CONCURRENT_OPERATION | \
+				 P2P_DEVCAP_INVITATION_PROC)
+
+#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
+
+/*	Value of Device Capability Bitmap */
+#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
+#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
+#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
+#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
+#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
+#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
+
+/*	Value of Group Capability Bitmap */
+#define	P2P_GRPCAP_GO							BIT(0)
+#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
+#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
+#define	P2P_GRPCAP_INTRABSS					BIT(3)
+#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
+#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
+#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
+
+/*	P2P Public Action Frame ( Management Frame ) */
+#define	P2P_PUB_ACTION_ACTION				0x09
+
+/*	P2P Public Action Frame Type */
+#define	P2P_GO_NEGO_REQ						0
+#define	P2P_GO_NEGO_RESP						1
+#define	P2P_GO_NEGO_CONF						2
+#define	P2P_INVIT_REQ							3
+#define	P2P_INVIT_RESP							4
+#define	P2P_DEVDISC_REQ						5
+#define	P2P_DEVDISC_RESP						6
+#define	P2P_PROVISION_DISC_REQ				7
+#define	P2P_PROVISION_DISC_RESP				8
+
+/*	P2P Action Frame Type */
+#define	P2P_NOTICE_OF_ABSENCE	0
+#define	P2P_PRESENCE_REQUEST		1
+#define	P2P_PRESENCE_RESPONSE	2
+#define	P2P_GO_DISC_REQUEST		3
+
+
+#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
+
+#define	P2P_PROVISIONING_SCAN_CNT			3
+
+#define	P2P_WILDCARD_SSID_LEN				7
+
+#define	P2P_FINDPHASE_EX_NONE				0	/* default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase */
+#define	P2P_FINDPHASE_EX_FULL				1	/* used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase */
+#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
+#define	P2P_FINDPHASE_EX_MAX					4
+#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
+
+#define	P2P_PROVISION_TIMEOUT				5000	/*	5 seconds timeout for sending the provision discovery request */
+#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	/*	3 seconds timeout for sending the provision discovery request under concurrent mode */
+#define	P2P_GO_NEGO_TIMEOUT					5000	/*	5 seconds timeout for receiving the group negotation response */
+#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	/*	3 seconds timeout for sending the negotiation request under concurrent mode */
+#define	P2P_TX_PRESCAN_TIMEOUT				100		/*	100ms */
+#define	P2P_INVITE_TIMEOUT					5000	/*	5 seconds timeout for sending the invitation request */
+#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	/*	3 seconds timeout for sending the invitation request under concurrent mode */
+#define	P2P_RESET_SCAN_CH						25000	/*	25 seconds timeout to reset the scan channel (based on channel plan) */
+#define	P2P_MAX_INTENT						15
+
+#define	P2P_MAX_NOA_NUM						2
+
+/*	WPS Configuration Method */
+#define	WPS_CM_NONE							0x0000
+#define	WPS_CM_LABEL							0x0004
+#define	WPS_CM_DISPLYA						0x0008
+#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
+#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
+#define	WPS_CM_NFC_INTERFACE					0x0040
+#define	WPS_CM_PUSH_BUTTON					0x0080
+#define	WPS_CM_KEYPAD						0x0100
+#define	WPS_CM_SW_PUHS_BUTTON				0x0280
+#define	WPS_CM_HW_PUHS_BUTTON				0x0480
+#define	WPS_CM_SW_DISPLAY_PIN				0x2008
+#define	WPS_CM_LCD_DISPLAY_PIN				0x4008
+
+enum P2P_ROLE {
+	P2P_ROLE_DISABLE = 0,
+	P2P_ROLE_DEVICE = 1,
+	P2P_ROLE_CLIENT = 2,
+	P2P_ROLE_GO = 3
+};
+
+enum P2P_STATE {
+	P2P_STATE_NONE = 0,							/*	P2P disable */
+	P2P_STATE_IDLE = 1,								/*	P2P had enabled and do nothing ,  buddy adapters is linked */
+	P2P_STATE_LISTEN = 2,							/*	In pure listen state */
+	P2P_STATE_SCAN = 3,							/*	In scan phase */
+	P2P_STATE_FIND_PHASE_LISTEN = 4,				/*	In the listen state of find phase */
+	P2P_STATE_FIND_PHASE_SEARCH = 5,				/*	In the search state of find phase */
+	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			/*	In P2P provisioning discovery */
+	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
+	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
+	P2P_STATE_GONEGO_ING = 9,						/*	Doing the group owner negoitation handshake */
+	P2P_STATE_GONEGO_OK = 10,						/*	finish the group negoitation handshake with success */
+	P2P_STATE_GONEGO_FAIL = 11,					/*	finish the group negoitation handshake with failure */
+	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		/*	receiving the P2P Inviation request and match with the profile. */
+	P2P_STATE_PROVISIONING_ING = 13,				/*	Doing the P2P WPS */
+	P2P_STATE_PROVISIONING_DONE = 14,			/*	Finish the P2P WPS */
+	P2P_STATE_TX_INVITE_REQ = 15,					/*	Transmit the P2P Invitation request */
+	P2P_STATE_RX_INVITE_RESP_OK = 16,				/*	Receiving the P2P Invitation response */
+	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	/*	receiving the P2P Inviation request and dismatch with the profile. */
+	P2P_STATE_RECV_INVITE_REQ_GO = 18,			/*	receiving the P2P Inviation request and this wifi is GO. */
+	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			/*	receiving the P2P Inviation request to join an existing P2P Group. */
+	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			/*	recveing the P2P Inviation response with failure */
+	P2P_STATE_RX_INFOR_NOREADY = 21,			/* receiving p2p negoitation response with information is not available */
+	P2P_STATE_TX_INFOR_NOREADY = 22,			/* sending p2p negoitation response with information is not available */
+};
+
+enum P2P_WPSINFO {
+	P2P_NO_WPSINFO						= 0,
+	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
+	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
+	P2P_GOT_WPSINFO_PBC					= 3,
+};
+
+#define	P2P_PRIVATE_IOCTL_SET_LEN		64
+
+enum P2P_PROTO_WK_ID {
+	P2P_FIND_PHASE_WK = 0,
+	P2P_RESTORE_STATE_WK = 1,
+	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
+	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
+	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
+	P2P_AP_P2P_CH_SWITCH_PROCESS_WK = 5,
+	P2P_RO_CH_WK = 6,
+	P2P_CANCEL_RO_CH_WK = 7,
+};
+
+#ifdef CONFIG_P2P_PS
+enum P2P_PS_STATE {
+	P2P_PS_DISABLE = 0,
+	P2P_PS_ENABLE = 1,
+	P2P_PS_SCAN = 2,
+	P2P_PS_SCAN_DONE = 3,
+	P2P_PS_ALLSTASLEEP = 4, /* for P2P GO */
+};
+
+enum P2P_PS_MODE {
+	P2P_PS_NONE = 0,
+	P2P_PS_CTWINDOW = 1,
+	P2P_PS_NOA	 = 2,
+	P2P_PS_MIX = 3, /* CTWindow and NoA */
+};
+#endif /* CONFIG_P2P_PS */
+
+/*	=====================WFD Section=====================
+ *	For Wi-Fi Display */
+#define	WFD_ATTR_DEVICE_INFO			0x00
+#define	WFD_ATTR_ASSOC_BSSID			0x01
+#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
+#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
+#define	WFD_ATTR_SESSION_INFO		0x09
+#define	WFD_ATTR_ALTER_MAC			0x0a
+
+/*	For WFD Device Information Attribute */
+#define	WFD_DEVINFO_SOURCE					0x0000
+#define	WFD_DEVINFO_PSINK					0x0001
+#define	WFD_DEVINFO_SSINK					0x0002
+#define	WFD_DEVINFO_DUAL					0x0003
+
+#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
+#define	WFD_DEVINFO_WSD						0x0040
+#define	WFD_DEVINFO_PC_TDLS					0x0080
+#define	WFD_DEVINFO_HDCP_SUPPORT			0x0100
+
+#ifdef CONFIG_TX_MCAST2UNI
+#define IP_MCAST_MAC(mac)		((mac[0] == 0x01) && (mac[1] == 0x00) && (mac[2] == 0x5e))
+#define ICMPV6_MCAST_MAC(mac)	((mac[0] == 0x33) && (mac[1] == 0x33) && (mac[2] != 0xff))
+#endif /* CONFIG_TX_MCAST2UNI */
+
+#ifdef CONFIG_IOCTL_CFG80211
+/* Regulatroy Domain */
+struct regd_pair_mapping {
+	u16 reg_dmnenum;
+	u16 reg_5ghz_ctl;
+	u16 reg_2ghz_ctl;
+};
+
+struct rtw_regulatory {
+	char alpha2[2];
+	u16 country_code;
+	u16 max_power_level;
+	u32 tp_scale;
+	u16 current_rd;
+	u16 current_rd_ext;
+	int16_t power_limit;
+	struct regd_pair_mapping *regpair;
+};
+#endif
+
+#ifdef CONFIG_WAPI_SUPPORT
+#ifndef IW_AUTH_WAPI_VERSION_1
+#define IW_AUTH_WAPI_VERSION_1		0x00000008
+#endif
+#ifndef IW_AUTH_KEY_MGMT_WAPI_PSK
+#define IW_AUTH_KEY_MGMT_WAPI_PSK	0x04
+#endif
+#ifndef IW_AUTH_WAPI_ENABLED
+#define IW_AUTH_WAPI_ENABLED		0x20
+#endif
+#ifndef IW_ENCODE_ALG_SM4
+#define IW_ENCODE_ALG_SM4			0x20
+#endif
+#endif
+
+#endif /* _WIFI_H_ */
diff --git a/drivers/staging/rtl8188eu/include/wlan_bssdef.h b/drivers/staging/rtl8188eu/include/wlan_bssdef.h
new file mode 100644
index 000000000000..293de033f763
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/wlan_bssdef.h
@@ -0,0 +1,347 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+#define MAX_IE_SZ	768
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           /* in dBm */
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        /* Set of 8 data rates */
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  /* Set of 16 data rates */
+
+typedef  u32  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+typedef struct _NDIS_802_11_SSID {
+	u32  SsidLength;
+	u8  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE {
+	Ndis802_11FH,
+	Ndis802_11DS,
+	Ndis802_11OFDM5,
+	Ndis802_11OFDM24,
+	Ndis802_11NetworkTypeMax    /* not a real type, defined as an upper bound */
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH {
+	u32           Length;             /* Length of structure */
+	u32           HopPattern;         /* As defined by 802.11, MSB set */
+	u32           HopSet;             /* to one if non-802.11 */
+	u32           DwellTime;          /* units are Kusec */
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+typedef struct _NDIS_802_11_CONFIGURATION {
+	u32           Length;             /* Length of structure */
+	u32           BeaconPeriod;       /* units are Kusec */
+	u32           ATIMWindow;         /* units are Kusec */
+	u32           DSConfig;           /* channel number */
+	NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	Ndis802_11IBSS,
+	Ndis802_11Infrastructure,
+	Ndis802_11AutoUnknown,
+	Ndis802_11InfrastructureMax,     /* Not a real value, defined as upper bound */
+	Ndis802_11APMode,
+	Ndis802_11Monitor,
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+typedef struct _NDIS_802_11_FIXED_IEs {
+	u8  Timestamp[8];
+	u16  BeaconInterval;
+	u16  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+typedef struct _NDIS_802_11_VARIABLE_IEs {
+	u8  ElementID;
+	u8  Length;
+	u8  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+/*
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (u32)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeWAPI,
+	Ndis802_11AuthModeMax               /* Not a real mode, defined as upper bound */
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS {
+	Ndis802_11WEPEnabled,
+	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+	Ndis802_11WEPDisabled,
+	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+	Ndis802_11WEPKeyAbsent,
+	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+	Ndis802_11WEPNotSupported,
+	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+	Ndis802_11Encryption2Enabled,
+	Ndis802_11Encryption2KeyAbsent,
+	Ndis802_11Encryption3Enabled,
+	Ndis802_11Encryption3KeyAbsent,
+	Ndis802_11_EncrypteionWAPI
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI {
+	u16 Capabilities;
+	u16 ListenInterval;
+	NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI {
+	u16 Capabilities;
+	u16 StatusCode;
+	u16 AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION {
+	u32                   Length;
+	u16                  AvailableRequestFixedIEs;
+	NDIS_802_11_AI_REQFI    RequestFixedIEs;
+	u32                   RequestIELength;
+	u32                   OffsetRequestIEs;
+	u16                  AvailableResponseFixedIEs;
+	NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+	u32                   ResponseIELength;
+	u32                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS {
+	Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+/* Key mapping keys require a BSSID */
+typedef struct _NDIS_802_11_KEY {
+	u32           Length;             /* Length of this structure */
+	u32           KeyIndex;
+	u32           KeyLength;          /* length of key in bytes */
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	NDIS_802_11_KEY_RSC KeyRSC;
+	u8           KeyMaterial[32];     /* variable length depending on above field */
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY {
+	u32                   Length;        /* Length of this structure */
+	u32                   KeyIndex;
+	NDIS_802_11_MAC_ADDRESS BSSID;
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP {
+	u32     Length;        /* Length of this structure */
+	u32     KeyIndex;      /* 0 is the per-client key, 1-N are the global keys */
+	u32     KeyLength;     /* length of key in bytes */
+	u8     KeyMaterial[16];/* variable length depending on above field */
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST {
+	u32 Length;            /* Length of structure */
+	NDIS_802_11_MAC_ADDRESS Bssid;
+	u32 Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE {
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    /* not a real type, defined as an upper bound */
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION {
+	NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+/* mask for authentication/integrity fields */
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+/* MIC check time, 60 seconds. */
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT {
+	NDIS_802_11_STATUS_INDICATION       Status;
+	NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+
+typedef struct _NDIS_802_11_TEST {
+	u32 Length;
+	u32 Type;
+	union {
+		NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+		NDIS_802_11_RSSI RssiTrigger;
+	} tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+typedef struct _WLAN_PHY_INFO {
+	u8	SignalStrength;/* (in percentage) */
+	u8	SignalQuality;/* (in percentage) */
+	u8	Optimum_antenna;  /* for Antenna diversity */
+	u8	Reserved_0;
+} WLAN_PHY_INFO, *PWLAN_PHY_INFO;
+
+typedef struct _WLAN_BCN_INFO {
+	/* these infor get from rtw_get_encrypt_info when
+	 *	 * translate scan to UI */
+	u8 encryp_protocol;/* ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI */
+	int group_cipher; /* WPA/WPA2 group cipher */
+	int pairwise_cipher;/* //WPA/WPA2/WEP pairwise cipher */
+	int is_8021x;
+
+	/* bwmode 20/40 and ch_offset UP/LOW */
+	unsigned short	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+} WLAN_BCN_INFO, *PWLAN_BCN_INFO;
+
+/* temporally add #pragma pack for structure alignment issue of
+*   WLAN_BSSID_EX and get_WLAN_BSSID_EX_sz()
+*/
+typedef struct _WLAN_BSSID_EX {
+	u32  Length;
+	NDIS_802_11_MAC_ADDRESS  MacAddress;
+	u8  Reserved[2];/* [0]: IS beacon frame */
+	NDIS_802_11_SSID  Ssid;
+	u32  Privacy;
+	NDIS_802_11_RSSI  Rssi;/* (in dBM,raw data ,get from PHY) */
+	NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	NDIS_802_11_CONFIGURATION  Configuration;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	NDIS_802_11_RATES_EX  SupportedRates;
+	WLAN_PHY_INFO	PhyInfo;
+	u32  IELength;
+	u8  IEs[MAX_IE_SZ];	/* (timestamp, beacon interval, and capability information) */
+}
+__attribute__((packed))
+WLAN_BSSID_EX, *PWLAN_BSSID_EX;
+
+#define BSS_EX_IES(bss_ex) ((bss_ex)->IEs)
+#define BSS_EX_IES_LEN(bss_ex) ((bss_ex)->IELength)
+#define BSS_EX_FIXED_IE_OFFSET(bss_ex) ((bss_ex)->Reserved[0] == 2 ? 0 : 12)
+#define BSS_EX_TLV_IES(bss_ex) (BSS_EX_IES((bss_ex)) + BSS_EX_FIXED_IE_OFFSET((bss_ex)))
+#define BSS_EX_TLV_IES_LEN(bss_ex) (BSS_EX_IES_LEN((bss_ex)) - BSS_EX_FIXED_IE_OFFSET((bss_ex)))
+
+__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
+{
+	return sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + bss->IELength;
+}
+
+struct	wlan_network {
+	_list	list;
+	int	network_type;	/* refer to ieee80211.h for WIRELESS_11A/B/G */
+	int	fixed;			/* set to fixed when not to be removed as site-surveying */
+	unsigned long	last_scanned; /* timestamp for the network */
+	int	aid;			/* will only be valid when a BSS is joinned. */
+	int	join_res;
+	WLAN_BSSID_EX	network; /* must be the last item */
+	WLAN_BCN_INFO	BcnInfo;
+};
+
+enum VRTL_CARRIER_SENSE {
+	DISABLE_VCS,
+	ENABLE_VCS,
+	AUTO_VCS
+};
+
+enum VCS_TYPE {
+	NONE_VCS,
+	RTS_CTS,
+	CTS_TO_SELF
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP {
+	NO_LIMIT,
+	TWO_MSDU,
+	FOUR_MSDU,
+	SIX_MSDU
+};
+
+
+/* john */
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+*	WPA2
+*/
+
+typedef struct _PMKID_CANDIDATE {
+	NDIS_802_11_MAC_ADDRESS BSSID;
+	u32 Flags;
+} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
+
+typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST {
+	u32 Version;       /* Version of the structure */
+	u32 NumCandidates; /* No. of pmkid candidates */
+	PMKID_CANDIDATE CandidateList[1];
+} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
+
+
+typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION {
+	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+
+} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
+
+typedef struct _NDIS_802_11_CAPABILITY {
+	u32  Length;
+	u32  Version;
+	u32  NoOfPMKIDs;
+	u32  NoOfAuthEncryptPairsSupported;
+	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
+
+} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
+
+#endif /* #ifndef WLAN_BSSDEF_H_ */
diff --git a/drivers/staging/rtl8188eu/include/xmit_osdep.h b/drivers/staging/rtl8188eu/include/xmit_osdep.h
new file mode 100644
index 000000000000..5c85804d7188
--- /dev/null
+++ b/drivers/staging/rtl8188eu/include/xmit_osdep.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved. */
+
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+
+struct pkt_file {
+	_pkt *pkt;
+	SIZE_T pkt_len;	 /* the remainder length of the open_file */
+	_buffer *cur_buffer;
+	u8 *buf_start;
+	u8 *cur_addr;
+	SIZE_T buf_len;
+};
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+extern int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
+
+void rtw_os_xmit_schedule(_adapter *padapter);
+
+int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz, u8 flag);
+void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf, u32 free_sz, u8 flag);
+
+extern void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib);
+
+extern uint rtw_remainder_len(struct pkt_file *pfile);
+extern void _rtw_open_pktfile(_pkt *pkt, struct pkt_file *pfile);
+extern uint _rtw_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen);
+extern sint rtw_endofpktfile(struct pkt_file *pfile);
+
+extern void rtw_os_pkt_complete(_adapter *padapter, _pkt *pkt);
+extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
+
+void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed);
+
+void dump_os_queue(void *sel, _adapter *padapter);
+
+#endif /* __XMIT_OSDEP_H_ */
-- 
2.31.1

