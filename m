Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 98616330479
	for <lists+linux-kernel@lfdr.de>; Sun,  7 Mar 2021 21:26:09 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232856AbhCGUZe (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Sun, 7 Mar 2021 15:25:34 -0500
Received: from mail.kernel.org ([198.145.29.99]:52604 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S232840AbhCGUYs (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Sun, 7 Mar 2021 15:24:48 -0500
Received: by mail.kernel.org (Postfix) with ESMTPSA id 5214165165;
        Sun,  7 Mar 2021 20:24:47 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1615148688;
        bh=UmfVznXdujptH7iDjtQZJwzESDxYSA0yJcfu47yQfRw=;
        h=From:To:Cc:Subject:Date:From;
        b=u5QZ2Yj0ZSEch5VxVe05DThbOYPpY5rA2d40HW/Gmaw0EOXC1oaXnPRxswMe1C7HP
         igQyFj4D5qPZMXM4hRlyInlJ/9LKNhA6fGqmQwAxnYOa90TbQevLU+rhySaR6Rx78V
         J9P9uTnDUIfDZ5tbJpKzHdD1PwlrceD2Ys24Ar/acinuO0AiYkHMems7IJRvs064pi
         YYc7GTPxsOi7qRYZJ7pUeP8Yy1vt4mgyzb4rJFvk28PbkReRGTJPKpYOeOjz5INfUT
         2LQHTvg4eZEIV53PQNT9qUZym0BLZSDZ1VnZ+HdMGuMFLD3/PMnpPBaplBR0yfBF3D
         huq5AZ9ULiEEg==
From:   Arnd Bergmann <arnd@kernel.org>
To:     Lee Jones <lee.jones@linaro.org>
Cc:     Arnd Bergmann <arnd@arndb.de>,
        Linus Walleij <linus.walleij@linaro.org>,
        linux-kernel@vger.kernel.org
Subject: [PATCH] [RESEND] mfd: remove ab3100 driver
Date:   Sun,  7 Mar 2021 21:23:25 +0100
Message-Id: <20210307202441.1955498-1-arnd@kernel.org>
X-Mailer: git-send-email 2.29.2
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

From: Arnd Bergmann <arnd@arndb.de>

The ST-Ericsson U300 platform has been removed, so this driver is no
longer needed.

Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
Signed-off-by: Arnd Bergmann <arnd@arndb.de>
---
 drivers/mfd/Kconfig        |  26 +-
 drivers/mfd/Makefile       |   2 -
 drivers/mfd/ab3100-core.c  | 929 -------------------------------------
 drivers/mfd/ab3100-otp.c   | 240 ----------
 include/linux/mfd/ab3100.h | 128 -----
 5 files changed, 1 insertion(+), 1324 deletions(-)
 delete mode 100644 drivers/mfd/ab3100-core.c
 delete mode 100644 drivers/mfd/ab3100-otp.c
 delete mode 100644 include/linux/mfd/ab3100.h

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index a03de3f7a8ed..9a14531855a1 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1235,7 +1235,7 @@ config MFD_SC27XX_PMIC
 
 config ABX500_CORE
 	bool "ST-Ericsson ABX500 Mixed Signal Circuit register functions"
-	default y if ARCH_U300 || ARCH_U8500 || COMPILE_TEST
+	default y if ARCH_U8500 || COMPILE_TEST
 	help
 	  Say yes here if you have the ABX500 Mixed Signal IC family
 	  chips. This core driver expose register access functions.
@@ -1243,30 +1243,6 @@ config ABX500_CORE
 	  remain unchanged when IC changes. Binding of the functions to
 	  actual register access is done by the IC core driver.
 
-config AB3100_CORE
-	bool "ST-Ericsson AB3100 Mixed Signal Circuit core functions"
-	depends on I2C=y && ABX500_CORE
-	select MFD_CORE
-	default y if ARCH_U300
-	help
-	  Select this to enable the AB3100 Mixed Signal IC core
-	  functionality. This connects to a AB3100 on the I2C bus
-	  and expose a number of symbols needed for dependent devices
-	  to read and write registers and subscribe to events from
-	  this multi-functional IC. This is needed to use other features
-	  of the AB3100 such as battery-backed RTC, charging control,
-	  LEDs, vibrator, system power and temperature, power management
-	  and ALSA sound.
-
-config AB3100_OTP
-	tristate "ST-Ericsson AB3100 OTP functions"
-	depends on AB3100_CORE
-	default y if AB3100_CORE
-	help
-	  Select this to enable the AB3100 Mixed Signal IC OTP (one-time
-	  programmable memory) support. This exposes a sysfs file to read
-	  out OTP values.
-
 config AB8500_CORE
 	bool "ST-Ericsson AB8500 Mixed Signal Power Management chip"
 	depends on ABX500_CORE && MFD_DB8500_PRCMU
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index bb5e8f2a8e3a..d686496201b3 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -178,8 +178,6 @@ obj-$(CONFIG_MFD_PCF50633)	+= pcf50633.o
 obj-$(CONFIG_PCF50633_ADC)	+= pcf50633-adc.o
 obj-$(CONFIG_PCF50633_GPIO)	+= pcf50633-gpio.o
 obj-$(CONFIG_ABX500_CORE)	+= abx500-core.o
-obj-$(CONFIG_AB3100_CORE)	+= ab3100-core.o
-obj-$(CONFIG_AB3100_OTP)	+= ab3100-otp.o
 obj-$(CONFIG_AB8500_DEBUG)	+= ab8500-debugfs.o
 obj-$(CONFIG_MFD_DB8500_PRCMU)	+= db8500-prcmu.o
 # ab8500-core need to come after db8500-prcmu (which provides the channel)
diff --git a/drivers/mfd/ab3100-core.c b/drivers/mfd/ab3100-core.c
deleted file mode 100644
index ee71ae04b5e6..000000000000
--- a/drivers/mfd/ab3100-core.c
+++ /dev/null
@@ -1,929 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Copyright (C) 2007-2010 ST-Ericsson
- * Low-level core for exclusive access to the AB3100 IC on the I2C bus
- * and some basic chip-configuration.
- * Author: Linus Walleij <linus.walleij@stericsson.com>
- */
-
-#include <linux/i2c.h>
-#include <linux/mutex.h>
-#include <linux/list.h>
-#include <linux/notifier.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-#include <linux/random.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/mfd/core.h>
-#include <linux/mfd/ab3100.h>
-#include <linux/mfd/abx500.h>
-
-/* These are the only registers inside AB3100 used in this main file */
-
-/* Interrupt event registers */
-#define AB3100_EVENTA1		0x21
-#define AB3100_EVENTA2		0x22
-#define AB3100_EVENTA3		0x23
-
-/* AB3100 DAC converter registers */
-#define AB3100_DIS		0x00
-#define AB3100_D0C		0x01
-#define AB3100_D1C		0x02
-#define AB3100_D2C		0x03
-#define AB3100_D3C		0x04
-
-/* Chip ID register */
-#define AB3100_CID		0x20
-
-/* AB3100 interrupt registers */
-#define AB3100_IMRA1		0x24
-#define AB3100_IMRA2		0x25
-#define AB3100_IMRA3		0x26
-#define AB3100_IMRB1		0x2B
-#define AB3100_IMRB2		0x2C
-#define AB3100_IMRB3		0x2D
-
-/* System Power Monitoring and control registers */
-#define AB3100_MCA		0x2E
-#define AB3100_MCB		0x2F
-
-/* SIM power up */
-#define AB3100_SUP		0x50
-
-/*
- * I2C communication
- *
- * The AB3100 is usually assigned address 0x48 (7-bit)
- * The chip is defined in the platform i2c_board_data section.
- */
-static int ab3100_get_chip_id(struct device *dev)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	return (int)ab3100->chip_id;
-}
-
-static int ab3100_set_register_interruptible(struct ab3100 *ab3100,
-	u8 reg, u8 regval)
-{
-	u8 regandval[2] = {reg, regval};
-	int err;
-
-	err = mutex_lock_interruptible(&ab3100->access_mutex);
-	if (err)
-		return err;
-
-	/*
-	 * A two-byte write message with the first byte containing the register
-	 * number and the second byte containing the value to be written
-	 * effectively sets a register in the AB3100.
-	 */
-	err = i2c_master_send(ab3100->i2c_client, regandval, 2);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (write register): %d\n",
-			err);
-	} else if (err != 2) {
-		dev_err(ab3100->dev,
-			"write error (write register)\n"
-			"  %d bytes transferred (expected 2)\n",
-			err);
-		err = -EIO;
-	} else {
-		/* All is well */
-		err = 0;
-	}
-	mutex_unlock(&ab3100->access_mutex);
-	return err;
-}
-
-static int set_register_interruptible(struct device *dev,
-	u8 bank, u8 reg, u8 value)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	return ab3100_set_register_interruptible(ab3100, reg, value);
-}
-
-/*
- * The test registers exist at an I2C bus address up one
- * from the ordinary base. They are not supposed to be used
- * in production code, but sometimes you have to do that
- * anyway. It's currently only used from this file so declare
- * it static and do not export.
- */
-static int ab3100_set_test_register_interruptible(struct ab3100 *ab3100,
-				    u8 reg, u8 regval)
-{
-	u8 regandval[2] = {reg, regval};
-	int err;
-
-	err = mutex_lock_interruptible(&ab3100->access_mutex);
-	if (err)
-		return err;
-
-	err = i2c_master_send(ab3100->testreg_client, regandval, 2);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (write test register): %d\n",
-			err);
-	} else if (err != 2) {
-		dev_err(ab3100->dev,
-			"write error (write test register)\n"
-			"  %d bytes transferred (expected 2)\n",
-			err);
-		err = -EIO;
-	} else {
-		/* All is well */
-		err = 0;
-	}
-	mutex_unlock(&ab3100->access_mutex);
-
-	return err;
-}
-
-static int ab3100_get_register_interruptible(struct ab3100 *ab3100,
-					     u8 reg, u8 *regval)
-{
-	int err;
-
-	err = mutex_lock_interruptible(&ab3100->access_mutex);
-	if (err)
-		return err;
-
-	/*
-	 * AB3100 require an I2C "stop" command between each message, else
-	 * it will not work. The only way of achieveing this with the
-	 * message transport layer is to send the read and write messages
-	 * separately.
-	 */
-	err = i2c_master_send(ab3100->i2c_client, &reg, 1);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (send register address): %d\n",
-			err);
-		goto get_reg_out_unlock;
-	} else if (err != 1) {
-		dev_err(ab3100->dev,
-			"write error (send register address)\n"
-			"  %d bytes transferred (expected 1)\n",
-			err);
-		err = -EIO;
-		goto get_reg_out_unlock;
-	} else {
-		/* All is well */
-		err = 0;
-	}
-
-	err = i2c_master_recv(ab3100->i2c_client, regval, 1);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (read register): %d\n",
-			err);
-		goto get_reg_out_unlock;
-	} else if (err != 1) {
-		dev_err(ab3100->dev,
-			"write error (read register)\n"
-			"  %d bytes transferred (expected 1)\n",
-			err);
-		err = -EIO;
-		goto get_reg_out_unlock;
-	} else {
-		/* All is well */
-		err = 0;
-	}
-
- get_reg_out_unlock:
-	mutex_unlock(&ab3100->access_mutex);
-	return err;
-}
-
-static int get_register_interruptible(struct device *dev, u8 bank, u8 reg,
-				      u8 *value)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	return ab3100_get_register_interruptible(ab3100, reg, value);
-}
-
-static int ab3100_get_register_page_interruptible(struct ab3100 *ab3100,
-			     u8 first_reg, u8 *regvals, u8 numregs)
-{
-	int err;
-
-	if (ab3100->chip_id == 0xa0 ||
-	    ab3100->chip_id == 0xa1)
-		/* These don't support paged reads */
-		return -EIO;
-
-	err = mutex_lock_interruptible(&ab3100->access_mutex);
-	if (err)
-		return err;
-
-	/*
-	 * Paged read also require an I2C "stop" command.
-	 */
-	err = i2c_master_send(ab3100->i2c_client, &first_reg, 1);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (send first register address): %d\n",
-			err);
-		goto get_reg_page_out_unlock;
-	} else if (err != 1) {
-		dev_err(ab3100->dev,
-			"write error (send first register address)\n"
-			"  %d bytes transferred (expected 1)\n",
-			err);
-		err = -EIO;
-		goto get_reg_page_out_unlock;
-	}
-
-	err = i2c_master_recv(ab3100->i2c_client, regvals, numregs);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (read register page): %d\n",
-			err);
-		goto get_reg_page_out_unlock;
-	} else if (err != numregs) {
-		dev_err(ab3100->dev,
-			"write error (read register page)\n"
-			"  %d bytes transferred (expected %d)\n",
-			err, numregs);
-		err = -EIO;
-		goto get_reg_page_out_unlock;
-	}
-
-	/* All is well */
-	err = 0;
-
- get_reg_page_out_unlock:
-	mutex_unlock(&ab3100->access_mutex);
-	return err;
-}
-
-static int get_register_page_interruptible(struct device *dev, u8 bank,
-	u8 first_reg, u8 *regvals, u8 numregs)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	return ab3100_get_register_page_interruptible(ab3100,
-			first_reg, regvals, numregs);
-}
-
-static int ab3100_mask_and_set_register_interruptible(struct ab3100 *ab3100,
-				 u8 reg, u8 andmask, u8 ormask)
-{
-	u8 regandval[2] = {reg, 0};
-	int err;
-
-	err = mutex_lock_interruptible(&ab3100->access_mutex);
-	if (err)
-		return err;
-
-	/* First read out the target register */
-	err = i2c_master_send(ab3100->i2c_client, &reg, 1);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (maskset send address): %d\n",
-			err);
-		goto get_maskset_unlock;
-	} else if (err != 1) {
-		dev_err(ab3100->dev,
-			"write error (maskset send address)\n"
-			"  %d bytes transferred (expected 1)\n",
-			err);
-		err = -EIO;
-		goto get_maskset_unlock;
-	}
-
-	err = i2c_master_recv(ab3100->i2c_client, &regandval[1], 1);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (maskset read register): %d\n",
-			err);
-		goto get_maskset_unlock;
-	} else if (err != 1) {
-		dev_err(ab3100->dev,
-			"write error (maskset read register)\n"
-			"  %d bytes transferred (expected 1)\n",
-			err);
-		err = -EIO;
-		goto get_maskset_unlock;
-	}
-
-	/* Modify the register */
-	regandval[1] &= andmask;
-	regandval[1] |= ormask;
-
-	/* Write the register */
-	err = i2c_master_send(ab3100->i2c_client, regandval, 2);
-	if (err < 0) {
-		dev_err(ab3100->dev,
-			"write error (write register): %d\n",
-			err);
-		goto get_maskset_unlock;
-	} else if (err != 2) {
-		dev_err(ab3100->dev,
-			"write error (write register)\n"
-			"  %d bytes transferred (expected 2)\n",
-			err);
-		err = -EIO;
-		goto get_maskset_unlock;
-	}
-
-	/* All is well */
-	err = 0;
-
- get_maskset_unlock:
-	mutex_unlock(&ab3100->access_mutex);
-	return err;
-}
-
-static int mask_and_set_register_interruptible(struct device *dev, u8 bank,
-	u8 reg, u8 bitmask, u8 bitvalues)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	return ab3100_mask_and_set_register_interruptible(ab3100,
-			reg, bitmask, (bitmask & bitvalues));
-}
-
-/*
- * Register a simple callback for handling any AB3100 events.
- */
-int ab3100_event_register(struct ab3100 *ab3100,
-			  struct notifier_block *nb)
-{
-	return blocking_notifier_chain_register(&ab3100->event_subscribers,
-					       nb);
-}
-EXPORT_SYMBOL(ab3100_event_register);
-
-/*
- * Remove a previously registered callback.
- */
-int ab3100_event_unregister(struct ab3100 *ab3100,
-			    struct notifier_block *nb)
-{
-	return blocking_notifier_chain_unregister(&ab3100->event_subscribers,
-					    nb);
-}
-EXPORT_SYMBOL(ab3100_event_unregister);
-
-
-static int ab3100_event_registers_startup_state_get(struct device *dev,
-					     u8 *event)
-{
-	struct ab3100 *ab3100 = dev_get_drvdata(dev->parent);
-
-	if (!ab3100->startup_events_read)
-		return -EAGAIN; /* Try again later */
-	memcpy(event, ab3100->startup_events, 3);
-
-	return 0;
-}
-
-static struct abx500_ops ab3100_ops = {
-	.get_chip_id = ab3100_get_chip_id,
-	.set_register = set_register_interruptible,
-	.get_register = get_register_interruptible,
-	.get_register_page = get_register_page_interruptible,
-	.set_register_page = NULL,
-	.mask_and_set_register = mask_and_set_register_interruptible,
-	.event_registers_startup_state_get =
-		ab3100_event_registers_startup_state_get,
-	.startup_irq_enabled = NULL,
-};
-
-/*
- * This is a threaded interrupt handler so we can make some
- * I2C calls etc.
- */
-static irqreturn_t ab3100_irq_handler(int irq, void *data)
-{
-	struct ab3100 *ab3100 = data;
-	u8 event_regs[3];
-	u32 fatevent;
-	int err;
-
-	err = ab3100_get_register_page_interruptible(ab3100, AB3100_EVENTA1,
-				       event_regs, 3);
-	if (err)
-		goto err_event;
-
-	fatevent = (event_regs[0] << 16) |
-		(event_regs[1] << 8) |
-		event_regs[2];
-
-	if (!ab3100->startup_events_read) {
-		ab3100->startup_events[0] = event_regs[0];
-		ab3100->startup_events[1] = event_regs[1];
-		ab3100->startup_events[2] = event_regs[2];
-		ab3100->startup_events_read = true;
-	}
-	/*
-	 * The notified parties will have to mask out the events
-	 * they're interested in and react to them. They will be
-	 * notified on all events, then they use the fatevent value
-	 * to determine if they're interested.
-	 */
-	blocking_notifier_call_chain(&ab3100->event_subscribers,
-				     fatevent, NULL);
-
-	dev_dbg(ab3100->dev,
-		"IRQ Event: 0x%08x\n", fatevent);
-
-	return IRQ_HANDLED;
-
- err_event:
-	dev_dbg(ab3100->dev,
-		"error reading event status\n");
-	return IRQ_HANDLED;
-}
-
-#ifdef CONFIG_DEBUG_FS
-/*
- * Some debugfs entries only exposed if we're using debug
- */
-static int ab3100_registers_print(struct seq_file *s, void *p)
-{
-	struct ab3100 *ab3100 = s->private;
-	u8 value;
-	u8 reg;
-
-	seq_puts(s, "AB3100 registers:\n");
-
-	for (reg = 0; reg < 0xff; reg++) {
-		ab3100_get_register_interruptible(ab3100, reg, &value);
-		seq_printf(s, "[0x%x]:  0x%x\n", reg, value);
-	}
-	return 0;
-}
-
-static int ab3100_registers_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ab3100_registers_print, inode->i_private);
-}
-
-static const struct file_operations ab3100_registers_fops = {
-	.open = ab3100_registers_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-	.owner = THIS_MODULE,
-};
-
-struct ab3100_get_set_reg_priv {
-	struct ab3100 *ab3100;
-	bool mode;
-};
-
-static ssize_t ab3100_get_set_reg(struct file *file,
-				  const char __user *user_buf,
-				  size_t count, loff_t *ppos)
-{
-	struct ab3100_get_set_reg_priv *priv = file->private_data;
-	struct ab3100 *ab3100 = priv->ab3100;
-	char buf[32];
-	ssize_t buf_size;
-	int regp;
-	u8 user_reg;
-	int err;
-	int i = 0;
-
-	/* Get userspace string and assure termination */
-	buf_size = min((ssize_t)count, (ssize_t)(sizeof(buf)-1));
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	/*
-	 * The idea is here to parse a string which is either
-	 * "0xnn" for reading a register, or "0xaa 0xbb" for
-	 * writing 0xbb to the register 0xaa. First move past
-	 * whitespace and then begin to parse the register.
-	 */
-	while ((i < buf_size) && (buf[i] == ' '))
-		i++;
-	regp = i;
-
-	/*
-	 * Advance pointer to end of string then terminate
-	 * the register string. This is needed to satisfy
-	 * the kstrtou8() function.
-	 */
-	while ((i < buf_size) && (buf[i] != ' '))
-		i++;
-	buf[i] = '\0';
-
-	err = kstrtou8(&buf[regp], 16, &user_reg);
-	if (err)
-		return err;
-
-	/* Either we read or we write a register here */
-	if (!priv->mode) {
-		/* Reading */
-		u8 regvalue;
-
-		ab3100_get_register_interruptible(ab3100, user_reg, &regvalue);
-
-		dev_info(ab3100->dev,
-			 "debug read AB3100 reg[0x%02x]: 0x%02x\n",
-			 user_reg, regvalue);
-	} else {
-		int valp;
-		u8 user_value;
-		u8 regvalue;
-
-		/*
-		 * Writing, we need some value to write to
-		 * the register so keep parsing the string
-		 * from userspace.
-		 */
-		i++;
-		while ((i < buf_size) && (buf[i] == ' '))
-			i++;
-		valp = i;
-		while ((i < buf_size) && (buf[i] != ' '))
-			i++;
-		buf[i] = '\0';
-
-		err = kstrtou8(&buf[valp], 16, &user_value);
-		if (err)
-			return err;
-
-		ab3100_set_register_interruptible(ab3100, user_reg, user_value);
-		ab3100_get_register_interruptible(ab3100, user_reg, &regvalue);
-
-		dev_info(ab3100->dev,
-			 "debug write reg[0x%02x]\n"
-			 "  with 0x%02x, after readback: 0x%02x\n",
-			 user_reg, user_value, regvalue);
-	}
-	return buf_size;
-}
-
-static const struct file_operations ab3100_get_set_reg_fops = {
-	.open = simple_open,
-	.write = ab3100_get_set_reg,
-	.llseek = noop_llseek,
-};
-
-static struct ab3100_get_set_reg_priv ab3100_get_priv;
-static struct ab3100_get_set_reg_priv ab3100_set_priv;
-
-static void ab3100_setup_debugfs(struct ab3100 *ab3100)
-{
-	struct dentry *ab3100_dir;
-
-	ab3100_dir = debugfs_create_dir("ab3100", NULL);
-
-	debugfs_create_file("registers", S_IRUGO, ab3100_dir, ab3100,
-			    &ab3100_registers_fops);
-
-	ab3100_get_priv.ab3100 = ab3100;
-	ab3100_get_priv.mode = false;
-	debugfs_create_file("get_reg", S_IWUSR, ab3100_dir, &ab3100_get_priv,
-			    &ab3100_get_set_reg_fops);
-
-	ab3100_set_priv.ab3100 = ab3100;
-	ab3100_set_priv.mode = true;
-	debugfs_create_file("set_reg", S_IWUSR, ab3100_dir, &ab3100_set_priv,
-			    &ab3100_get_set_reg_fops);
-}
-#else
-static inline void ab3100_setup_debugfs(struct ab3100 *ab3100)
-{
-}
-#endif
-
-/*
- * Basic set-up, datastructure creation/destruction and I2C interface.
- * This sets up a default config in the AB3100 chip so that it
- * will work as expected.
- */
-
-struct ab3100_init_setting {
-	u8 abreg;
-	u8 setting;
-};
-
-static const struct ab3100_init_setting ab3100_init_settings[] = {
-	{
-		.abreg = AB3100_MCA,
-		.setting = 0x01
-	}, {
-		.abreg = AB3100_MCB,
-		.setting = 0x30
-	}, {
-		.abreg = AB3100_IMRA1,
-		.setting = 0x00
-	}, {
-		.abreg = AB3100_IMRA2,
-		.setting = 0xFF
-	}, {
-		.abreg = AB3100_IMRA3,
-		.setting = 0x01
-	}, {
-		.abreg = AB3100_IMRB1,
-		.setting = 0xBF
-	}, {
-		.abreg = AB3100_IMRB2,
-		.setting = 0xFF
-	}, {
-		.abreg = AB3100_IMRB3,
-		.setting = 0xFF
-	}, {
-		.abreg = AB3100_SUP,
-		.setting = 0x00
-	}, {
-		.abreg = AB3100_DIS,
-		.setting = 0xF0
-	}, {
-		.abreg = AB3100_D0C,
-		.setting = 0x00
-	}, {
-		.abreg = AB3100_D1C,
-		.setting = 0x00
-	}, {
-		.abreg = AB3100_D2C,
-		.setting = 0x00
-	}, {
-		.abreg = AB3100_D3C,
-		.setting = 0x00
-	},
-};
-
-static int ab3100_setup(struct ab3100 *ab3100)
-{
-	int err = 0;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ab3100_init_settings); i++) {
-		err = ab3100_set_register_interruptible(ab3100,
-					  ab3100_init_settings[i].abreg,
-					  ab3100_init_settings[i].setting);
-		if (err)
-			goto exit_no_setup;
-	}
-
-	/*
-	 * Special trick to make the AB3100 use the 32kHz clock (RTC)
-	 * bit 3 in test register 0x02 is a special, undocumented test
-	 * register bit that only exist in AB3100 P1E
-	 */
-	if (ab3100->chip_id == 0xc4) {
-		dev_warn(ab3100->dev,
-			 "AB3100 P1E variant detected forcing chip to 32KHz\n");
-		err = ab3100_set_test_register_interruptible(ab3100,
-			0x02, 0x08);
-	}
-
- exit_no_setup:
-	return err;
-}
-
-/* The subdevices of the AB3100 */
-static struct mfd_cell ab3100_devs[] = {
-	{
-		.name = "ab3100-dac",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-leds",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-power",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-regulators",
-		.of_compatible = "stericsson,ab3100-regulators",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-sim",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-uart",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-rtc",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-charger",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-boost",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-adc",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-fuelgauge",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-vibrator",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-otp",
-		.id = -1,
-	},
-	{
-		.name = "ab3100-codec",
-		.id = -1,
-	},
-};
-
-struct ab_family_id {
-	u8	id;
-	char	*name;
-};
-
-static const struct ab_family_id ids[] = {
-	/* AB3100 */
-	{
-		.id = 0xc0,
-		.name = "P1A"
-	}, {
-		.id = 0xc1,
-		.name = "P1B"
-	}, {
-		.id = 0xc2,
-		.name = "P1C"
-	}, {
-		.id = 0xc3,
-		.name = "P1D"
-	}, {
-		.id = 0xc4,
-		.name = "P1E"
-	}, {
-		.id = 0xc5,
-		.name = "P1F/R1A"
-	}, {
-		.id = 0xc6,
-		.name = "P1G/R1A"
-	}, {
-		.id = 0xc7,
-		.name = "P2A/R2A"
-	}, {
-		.id = 0xc8,
-		.name = "P2B/R2B"
-	},
-	/* AB3000 variants, not supported */
-	{
-		.id = 0xa0
-	}, {
-		.id = 0xa1
-	}, {
-		.id = 0xa2
-	}, {
-		.id = 0xa3
-	}, {
-		.id = 0xa4
-	}, {
-		.id = 0xa5
-	}, {
-		.id = 0xa6
-	}, {
-		.id = 0xa7
-	},
-	/* Terminator */
-	{
-		.id = 0x00,
-	},
-};
-
-static int ab3100_probe(struct i2c_client *client,
-				  const struct i2c_device_id *id)
-{
-	struct ab3100 *ab3100;
-	struct ab3100_platform_data *ab3100_plf_data =
-		dev_get_platdata(&client->dev);
-	int err;
-	int i;
-
-	ab3100 = devm_kzalloc(&client->dev, sizeof(struct ab3100), GFP_KERNEL);
-	if (!ab3100)
-		return -ENOMEM;
-
-	/* Initialize data structure */
-	mutex_init(&ab3100->access_mutex);
-	BLOCKING_INIT_NOTIFIER_HEAD(&ab3100->event_subscribers);
-
-	ab3100->i2c_client = client;
-	ab3100->dev = &ab3100->i2c_client->dev;
-
-	i2c_set_clientdata(client, ab3100);
-
-	/* Read chip ID register */
-	err = ab3100_get_register_interruptible(ab3100, AB3100_CID,
-						&ab3100->chip_id);
-	if (err) {
-		dev_err(&client->dev,
-			"failed to communicate with AB3100 chip\n");
-		goto exit_no_detect;
-	}
-
-	for (i = 0; ids[i].id != 0x0; i++) {
-		if (ids[i].id == ab3100->chip_id) {
-			if (ids[i].name)
-				break;
-
-			dev_err(&client->dev, "AB3000 is not supported\n");
-			goto exit_no_detect;
-		}
-	}
-
-	snprintf(&ab3100->chip_name[0],
-		 sizeof(ab3100->chip_name) - 1, "AB3100 %s", ids[i].name);
-
-	if (ids[i].id == 0x0) {
-		dev_err(&client->dev, "unknown analog baseband chip id: 0x%x\n",
-			ab3100->chip_id);
-		dev_err(&client->dev,
-			"accepting it anyway. Please update the driver.\n");
-		goto exit_no_detect;
-	}
-
-	dev_info(&client->dev, "Detected chip: %s\n",
-		 &ab3100->chip_name[0]);
-
-	/* Attach a second dummy i2c_client to the test register address */
-	ab3100->testreg_client = i2c_new_dummy_device(client->adapter,
-					       client->addr + 1);
-	if (IS_ERR(ab3100->testreg_client)) {
-		err = PTR_ERR(ab3100->testreg_client);
-		goto exit_no_testreg_client;
-	}
-
-	err = ab3100_setup(ab3100);
-	if (err)
-		goto exit_no_setup;
-
-	err = devm_request_threaded_irq(&client->dev,
-					client->irq, NULL, ab3100_irq_handler,
-					IRQF_ONESHOT, "ab3100-core", ab3100);
-	if (err)
-		goto exit_no_irq;
-
-	err = abx500_register_ops(&client->dev, &ab3100_ops);
-	if (err)
-		goto exit_no_ops;
-
-	/* Set up and register the platform devices. */
-	for (i = 0; i < ARRAY_SIZE(ab3100_devs); i++) {
-		ab3100_devs[i].platform_data = ab3100_plf_data;
-		ab3100_devs[i].pdata_size = sizeof(struct ab3100_platform_data);
-	}
-
-	err = mfd_add_devices(&client->dev, 0, ab3100_devs,
-			      ARRAY_SIZE(ab3100_devs), NULL, 0, NULL);
-
-	ab3100_setup_debugfs(ab3100);
-
-	return 0;
-
- exit_no_ops:
- exit_no_irq:
- exit_no_setup:
-	i2c_unregister_device(ab3100->testreg_client);
- exit_no_testreg_client:
- exit_no_detect:
-	return err;
-}
-
-static const struct i2c_device_id ab3100_id[] = {
-	{ "ab3100", 0 },
-	{ }
-};
-
-static struct i2c_driver ab3100_driver = {
-	.driver = {
-		.name			= "ab3100",
-		.suppress_bind_attrs	= true,
-	},
-	.id_table	= ab3100_id,
-	.probe		= ab3100_probe,
-};
-
-static int __init ab3100_i2c_init(void)
-{
-	return i2c_add_driver(&ab3100_driver);
-}
-subsys_initcall(ab3100_i2c_init);
diff --git a/drivers/mfd/ab3100-otp.c b/drivers/mfd/ab3100-otp.c
deleted file mode 100644
index c393102e3a39..000000000000
--- a/drivers/mfd/ab3100-otp.c
+++ /dev/null
@@ -1,240 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * drivers/mfd/ab3100_otp.c
- *
- * Copyright (C) 2007-2009 ST-Ericsson AB
- * Driver to read out OTP from the AB3100 Mixed-signal circuit
- * Author: Linus Walleij <linus.walleij@stericsson.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/mfd/abx500.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-
-/* The OTP registers */
-#define AB3100_OTP0		0xb0
-#define AB3100_OTP1		0xb1
-#define AB3100_OTP2		0xb2
-#define AB3100_OTP3		0xb3
-#define AB3100_OTP4		0xb4
-#define AB3100_OTP5		0xb5
-#define AB3100_OTP6		0xb6
-#define AB3100_OTP7		0xb7
-#define AB3100_OTPP		0xbf
-
-/**
- * struct ab3100_otp
- * @dev: containing device
- * @locked: whether the OTP is locked, after locking, no more bits
- *       can be changed but before locking it is still possible
- *       to change bits from 1->0.
- * @freq: clocking frequency for the OTP, this frequency is either
- *       32768Hz or 1MHz/30
- * @paf: product activation flag, indicates whether this is a real
- *       product (paf true) or a lab board etc (paf false)
- * @imeich: if this is set it is possible to override the
- *       IMEI number found in the tac, fac and svn fields with
- *       (secured) software
- * @cid: customer ID
- * @tac: type allocation code of the IMEI
- * @fac: final assembly code of the IMEI
- * @svn: software version number of the IMEI
- * @debugfs: a debugfs file used when dumping to file
- */
-struct ab3100_otp {
-	struct device *dev;
-	bool locked;
-	u32 freq;
-	bool paf;
-	bool imeich;
-	u16 cid:14;
-	u32 tac:20;
-	u8 fac;
-	u32 svn:20;
-	struct dentry *debugfs;
-};
-
-static int __init ab3100_otp_read(struct ab3100_otp *otp)
-{
-	u8 otpval[8];
-	u8 otpp;
-	int err;
-
-	err = abx500_get_register_interruptible(otp->dev, 0,
-		AB3100_OTPP, &otpp);
-	if (err) {
-		dev_err(otp->dev, "unable to read OTPP register\n");
-		return err;
-	}
-
-	err = abx500_get_register_page_interruptible(otp->dev, 0,
-		AB3100_OTP0, otpval, 8);
-	if (err) {
-		dev_err(otp->dev, "unable to read OTP register page\n");
-		return err;
-	}
-
-	/* Cache OTP properties, they never change by nature */
-	otp->locked = (otpp & 0x80);
-	otp->freq = (otpp & 0x40) ? 32768 : 34100;
-	otp->paf = (otpval[1] & 0x80);
-	otp->imeich = (otpval[1] & 0x40);
-	otp->cid = ((otpval[1] << 8) | otpval[0]) & 0x3fff;
-	otp->tac = ((otpval[4] & 0x0f) << 16) | (otpval[3] << 8) | otpval[2];
-	otp->fac = ((otpval[5] & 0x0f) << 4) | (otpval[4] >> 4);
-	otp->svn = (otpval[7] << 12) | (otpval[6] << 4) | (otpval[5] >> 4);
-	return 0;
-}
-
-/*
- * This is a simple debugfs human-readable file that dumps out
- * the contents of the OTP.
- */
-#ifdef CONFIG_DEBUG_FS
-static int ab3100_show_otp(struct seq_file *s, void *v)
-{
-	struct ab3100_otp *otp = s->private;
-
-	seq_printf(s, "OTP is %s\n", otp->locked ? "LOCKED" : "UNLOCKED");
-	seq_printf(s, "OTP clock switch startup is %uHz\n", otp->freq);
-	seq_printf(s, "PAF is %s\n", otp->paf ? "SET" : "NOT SET");
-	seq_printf(s, "IMEI is %s\n", otp->imeich ?
-		   "CHANGEABLE" : "NOT CHANGEABLE");
-	seq_printf(s, "CID: 0x%04x (decimal: %d)\n", otp->cid, otp->cid);
-	seq_printf(s, "IMEI: %u-%u-%u\n", otp->tac, otp->fac, otp->svn);
-	return 0;
-}
-
-static int ab3100_otp_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ab3100_show_otp, inode->i_private);
-}
-
-static const struct file_operations ab3100_otp_operations = {
-	.open		= ab3100_otp_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static void __init ab3100_otp_init_debugfs(struct device *dev,
-					   struct ab3100_otp *otp)
-{
-	otp->debugfs = debugfs_create_file("ab3100_otp", S_IFREG | S_IRUGO,
-					   NULL, otp, &ab3100_otp_operations);
-}
-
-static void __exit ab3100_otp_exit_debugfs(struct ab3100_otp *otp)
-{
-	debugfs_remove(otp->debugfs);
-}
-#else
-/* Compile this out if debugfs not selected */
-static inline void __init ab3100_otp_init_debugfs(struct device *dev,
-						  struct ab3100_otp *otp)
-{
-}
-
-static inline void __exit ab3100_otp_exit_debugfs(struct ab3100_otp *otp)
-{
-}
-#endif
-
-#define SHOW_AB3100_ATTR(name) \
-static ssize_t ab3100_otp_##name##_show(struct device *dev, \
-			       struct device_attribute *attr, \
-			       char *buf) \
-{\
-	struct ab3100_otp *otp = dev_get_drvdata(dev); \
-	return sprintf(buf, "%u\n", otp->name); \
-}
-
-SHOW_AB3100_ATTR(locked)
-SHOW_AB3100_ATTR(freq)
-SHOW_AB3100_ATTR(paf)
-SHOW_AB3100_ATTR(imeich)
-SHOW_AB3100_ATTR(cid)
-SHOW_AB3100_ATTR(fac)
-SHOW_AB3100_ATTR(tac)
-SHOW_AB3100_ATTR(svn)
-
-static struct device_attribute ab3100_otp_attrs[] = {
-	__ATTR(locked, S_IRUGO, ab3100_otp_locked_show, NULL),
-	__ATTR(freq, S_IRUGO, ab3100_otp_freq_show, NULL),
-	__ATTR(paf, S_IRUGO, ab3100_otp_paf_show, NULL),
-	__ATTR(imeich, S_IRUGO, ab3100_otp_imeich_show, NULL),
-	__ATTR(cid, S_IRUGO, ab3100_otp_cid_show, NULL),
-	__ATTR(fac, S_IRUGO, ab3100_otp_fac_show, NULL),
-	__ATTR(tac, S_IRUGO, ab3100_otp_tac_show, NULL),
-	__ATTR(svn, S_IRUGO, ab3100_otp_svn_show, NULL),
-};
-
-static int __init ab3100_otp_probe(struct platform_device *pdev)
-{
-	struct ab3100_otp *otp;
-	int err = 0;
-	int i;
-
-	otp = devm_kzalloc(&pdev->dev, sizeof(struct ab3100_otp), GFP_KERNEL);
-	if (!otp)
-		return -ENOMEM;
-
-	otp->dev = &pdev->dev;
-
-	/* Replace platform data coming in with a local struct */
-	platform_set_drvdata(pdev, otp);
-
-	err = ab3100_otp_read(otp);
-	if (err)
-		return err;
-
-	dev_info(&pdev->dev, "AB3100 OTP readout registered\n");
-
-	/* sysfs entries */
-	for (i = 0; i < ARRAY_SIZE(ab3100_otp_attrs); i++) {
-		err = device_create_file(&pdev->dev,
-					 &ab3100_otp_attrs[i]);
-		if (err)
-			goto err;
-	}
-
-	/* debugfs entries */
-	ab3100_otp_init_debugfs(&pdev->dev, otp);
-
-	return 0;
-
-err:
-	while (--i >= 0)
-		device_remove_file(&pdev->dev, &ab3100_otp_attrs[i]);
-	return err;
-}
-
-static int __exit ab3100_otp_remove(struct platform_device *pdev)
-{
-	struct ab3100_otp *otp = platform_get_drvdata(pdev);
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(ab3100_otp_attrs); i++)
-		device_remove_file(&pdev->dev,
-				   &ab3100_otp_attrs[i]);
-	ab3100_otp_exit_debugfs(otp);
-	return 0;
-}
-
-static struct platform_driver ab3100_otp_driver = {
-	.driver = {
-		.name = "ab3100-otp",
-	},
-	.remove	 = __exit_p(ab3100_otp_remove),
-};
-
-module_platform_driver_probe(ab3100_otp_driver, ab3100_otp_probe);
-
-MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
-MODULE_DESCRIPTION("AB3100 OTP Readout Driver");
-MODULE_LICENSE("GPL");
diff --git a/include/linux/mfd/ab3100.h b/include/linux/mfd/ab3100.h
deleted file mode 100644
index a881d8495186..000000000000
--- a/include/linux/mfd/ab3100.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Copyright (C) 2007-2009 ST-Ericsson AB
- * AB3100 core access functions
- * Author: Linus Walleij <linus.walleij@stericsson.com>
- */
-
-#include <linux/regulator/machine.h>
-
-struct device;
-
-#ifndef MFD_AB3100_H
-#define MFD_AB3100_H
-
-
-#define AB3100_P1A	0xc0
-#define AB3100_P1B	0xc1
-#define AB3100_P1C	0xc2
-#define AB3100_P1D	0xc3
-#define AB3100_P1E	0xc4
-#define AB3100_P1F	0xc5
-#define AB3100_P1G	0xc6
-#define AB3100_R2A	0xc7
-#define AB3100_R2B	0xc8
-
-/*
- * AB3100, EVENTA1, A2 and A3 event register flags
- * these are catenated into a single 32-bit flag in the code
- * for event notification broadcasts.
- */
-#define AB3100_EVENTA1_ONSWA				(0x01<<16)
-#define AB3100_EVENTA1_ONSWB				(0x02<<16)
-#define AB3100_EVENTA1_ONSWC				(0x04<<16)
-#define AB3100_EVENTA1_DCIO				(0x08<<16)
-#define AB3100_EVENTA1_OVER_TEMP			(0x10<<16)
-#define AB3100_EVENTA1_SIM_OFF				(0x20<<16)
-#define AB3100_EVENTA1_VBUS				(0x40<<16)
-#define AB3100_EVENTA1_VSET_USB				(0x80<<16)
-
-#define AB3100_EVENTA2_READY_TX				(0x01<<8)
-#define AB3100_EVENTA2_READY_RX				(0x02<<8)
-#define AB3100_EVENTA2_OVERRUN_ERROR			(0x04<<8)
-#define AB3100_EVENTA2_FRAMING_ERROR			(0x08<<8)
-#define AB3100_EVENTA2_CHARG_OVERCURRENT		(0x10<<8)
-#define AB3100_EVENTA2_MIDR				(0x20<<8)
-#define AB3100_EVENTA2_BATTERY_REM			(0x40<<8)
-#define AB3100_EVENTA2_ALARM				(0x80<<8)
-
-#define AB3100_EVENTA3_ADC_TRIG5			(0x01)
-#define AB3100_EVENTA3_ADC_TRIG4			(0x02)
-#define AB3100_EVENTA3_ADC_TRIG3			(0x04)
-#define AB3100_EVENTA3_ADC_TRIG2			(0x08)
-#define AB3100_EVENTA3_ADC_TRIGVBAT			(0x10)
-#define AB3100_EVENTA3_ADC_TRIGVTX			(0x20)
-#define AB3100_EVENTA3_ADC_TRIG1			(0x40)
-#define AB3100_EVENTA3_ADC_TRIG0			(0x80)
-
-/* AB3100, STR register flags */
-#define AB3100_STR_ONSWA				(0x01)
-#define AB3100_STR_ONSWB				(0x02)
-#define AB3100_STR_ONSWC				(0x04)
-#define AB3100_STR_DCIO					(0x08)
-#define AB3100_STR_BOOT_MODE				(0x10)
-#define AB3100_STR_SIM_OFF				(0x20)
-#define AB3100_STR_BATT_REMOVAL				(0x40)
-#define AB3100_STR_VBUS					(0x80)
-
-/*
- * AB3100 contains 8 regulators, one external regulator controller
- * and a buck converter, further the LDO E and buck converter can
- * have separate settings if they are in sleep mode, this is
- * modeled as a separate regulator.
- */
-#define AB3100_NUM_REGULATORS				10
-
-/**
- * struct ab3100
- * @access_mutex: lock out concurrent accesses to the AB3100 registers
- * @dev: pointer to the containing device
- * @i2c_client: I2C client for this chip
- * @testreg_client: secondary client for test registers
- * @chip_name: name of this chip variant
- * @chip_id: 8 bit chip ID for this chip variant
- * @event_subscribers: event subscribers are listed here
- * @startup_events: a copy of the first reading of the event registers
- * @startup_events_read: whether the first events have been read
- *
- * This struct is PRIVATE and devices using it should NOT
- * access ANY fields. It is used as a token for calling the
- * AB3100 functions.
- */
-struct ab3100 {
-	struct mutex access_mutex;
-	struct device *dev;
-	struct i2c_client *i2c_client;
-	struct i2c_client *testreg_client;
-	char chip_name[32];
-	u8 chip_id;
-	struct blocking_notifier_head event_subscribers;
-	u8 startup_events[3];
-	bool startup_events_read;
-};
-
-/**
- * struct ab3100_platform_data
- * Data supplied to initialize board connections to the AB3100
- * @reg_constraints: regulator constraints for target board
- *     the order of these constraints are: LDO A, C, D, E,
- *     F, G, H, K, EXT and BUCK.
- * @reg_initvals: initial values for the regulator registers
- *     plus two sleep settings for LDO E and the BUCK converter.
- *     exactly AB3100_NUM_REGULATORS+2 values must be sent in.
- *     Order: LDO A, C, E, E sleep, F, G, H, K, EXT, BUCK,
- *     BUCK sleep, LDO D. (LDO D need to be initialized last.)
- * @external_voltage: voltage level of the external regulator.
- */
-struct ab3100_platform_data {
-	struct regulator_init_data reg_constraints[AB3100_NUM_REGULATORS];
-	u8 reg_initvals[AB3100_NUM_REGULATORS+2];
-	int external_voltage;
-};
-
-int ab3100_event_register(struct ab3100 *ab3100,
-			  struct notifier_block *nb);
-int ab3100_event_unregister(struct ab3100 *ab3100,
-			    struct notifier_block *nb);
-
-#endif /*  MFD_AB3100_H */
-- 
2.29.2

